<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Allen个人博客</title>
  
  <subtitle>hello world~</subtitle>
  <link href="http://cxinxian.github.io/atom.xml" rel="self"/>
  
  <link href="http://cxinxian.github.io/"/>
  <updated>2025-02-21T14:03:06.370Z</updated>
  <id>http://cxinxian.github.io/</id>
  
  <author>
    <name>Allen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 高并发框架</title>
    <link href="http://cxinxian.github.io/2022/07/17/python/python%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    <id>http://cxinxian.github.io/2022/07/17/python/python%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6/</id>
    <published>2022-07-17T10:12:03.000Z</published>
    <updated>2025-02-21T14:03:06.370Z</updated>
    
    <content type="html"><![CDATA[<p>python编程中，我们使用到的并发框架主要有以下几种</p><span id="more"></span><h2 id="一、并发框架"><a href="#一、并发框架" class="headerlink" title="一、并发框架"></a>一、并发框架</h2><p><strong>greenlet、eventlet、gevnet（推荐）</strong></p><ul><li><strong>greenlet</strong>：轻量级的并行编程，调度麻烦，用生成器实现的协程而且不是真正意义上的协程，只是实现代码执行过程中的挂起、唤醒操作。Greenlet 没有自己的调度过程，所以一般不会直接使用。greenlet：<a href="http://greenlet.readthedocs.org/en/latest/">http://greenlet.readthedocs.org/en/latest/</a></li><li><strong>eventlet</strong>：是在 greenlet 的基础上实现了自己的 GreenThread，实际上就是 greenlet 类的扩展封装，而与 Greenlet 的不同是，eventlet 实现了自己调度器称为 Hub，Hub 类似于 Tornado 的 IOLoop，是单实例的。在 Hub 中有一个 event loop，根据不同的事件来切换到对应的 GreenThread。同时 Eventlet 还实现了一系列的补丁来使 Python 标准库中的 socket 等等 module 来支持 GreenThread 的切换。eventlet 的 Hub 可以被定制来实现自己调度过程。eventlet 目前支持 CPython 2.7 和 3.4+ 并将在未来删除，仅保留 CPython 3.5+ 支持。</li><li><strong>gevent</strong>：基于 libev 与 Greenlet 实现。不同于 eventlet 的用 python 实现 hub 调度，Gevent 通过 Cython 调用 libev 来实现一个高效的 event loop 调度循环。同时类似于 Event，Gevent 也有自己的 monkey_patch，在打了补丁后，完全可以使用 python 线程的方式来无感知的使用协程，减少了开发成本。gevent 官方文档：<a href="http://www.gevent.org/contents.html">http://www.gevent.org/contents.html</a></li></ul><h2 id="二、关于-gevent"><a href="#二、关于-gevent" class="headerlink" title="二、关于 gevent"></a>二、关于 gevent</h2><h3 id="2-1、gevent的特点"><a href="#2-1、gevent的特点" class="headerlink" title="2.1、gevent的特点"></a>2.1、gevent的特点</h3><ol><li>基于 libev 的快速事件循环，Linux 上面的是 epoll 机制</li><li>基于 greenlet 的轻量级执行单元</li><li>API 复用了 Python 标准库里的内容。API 的概念和 Python 标准库一致（如事件，队列）</li><li>TCP&#x2F;UDP&#x2F;HTTP 服务器</li><li>支持 SSL 的协作式 sockets</li><li>子进程支持（通过 gevent.subprocess）</li><li>线程池</li><li>greenlets 是确定性的。给定相同的绿色配置和相同的输入集，它们总是产生相同的输出</li><li>gevent 每次遇到 io 操作，需要耗时等待时，会自动跳到下一个协程继续执行。</li><li>gevent 的代码风格和线程非常相似，运行出来后的效果也非常相似。</li><li>通过 monkey patching 功能来使得第三方模块变成协作式</li></ol><hr><blockquote><p>libevent 时一个事件分发引擎，greenlet 提供了轻量级线程的支持，gevent 就是基于这两个的一个专门处理网络逻辑的并行库。</p></blockquote><ol><li><strong>gevent.spawn</strong> 启动的所有协程，都是运行在同一个线程之中，所以协程不能跨线程同步数据。</li><li><strong>gevent.queue.Queue</strong> 是协程安全的。</li><li>gevent 启动的并发协程，具体到 task function，不能有长时间阻塞的IO操作。因为 gevent 的协程特点是：当前协程阻塞了才会切换到别的协程。如果当前协程长时间阻塞，则不能显示（gevent.sleep(0)，或隐式，由 gevent 来做）切换到别的协程。导致程序出问题。</li><li>如果有长时间阻塞的 IO 操作，还是用传统的线程模型比较好。</li><li>因为 gevent 的特点总结是：事件驱动 + 协程 + 非阻塞 IO，事件驱动指的是 libevnt 对 epool 的封装，是基于事件的方式处理 IO。协程指的是 greenlet，非阻塞 IO 指的是 gevent 已经 pathc 过的各种库，例如 socket 和 select 等等。</li><li>使用 gevent 的协程，最好要用 gevent 自身的非阻塞的库。如 httplib,socket,select 等等。</li><li>gevent 适合处理大量无阻塞的任务，如果有实在不能把阻塞的部分变为非阻塞再交给 gevent 处理，就把阻塞的部分改为异步吧。</li></ol><p><strong>原理</strong></p><blockquote><p>原理：程序的重要部分是将任务函数封装到 gevent.spawn。</p><ul><li>初始化的 greenlet 列表存在数组 threads 中，此数组被传给 <strong>gevent.joinall</strong> 函数。</li><li><strong>gevent.joinall</strong> 会阻塞当前流程，并执行所有给定的 greenlet ， 执行流程只会在所有 greenlet 执行完后才会继续向下走。</li></ul></blockquote><p>gevent 实现了 python 标准库里面大部分的阻塞式系统调用，包括 socket、ssl、threading 和 select 等模块，而将这些阻塞式调用变为协作式运行。</p><h3 id="2-2、猴子补丁（monkey-patch）"><a href="#2-2、猴子补丁（monkey-patch）" class="headerlink" title="2.2、猴子补丁（monkey patch）"></a>2.2、猴子补丁（monkey patch）</h3><ul><li><strong>猴子补丁的由来</strong>：猴子补丁的这个叫法起源于 Zope 框架，大家在修正 Zope 的 bug 时，经常在程序后面追加更新部分，这些被称作是 “杂牌军补丁（guerillapatch）”，后来 guerilla 就渐渐的写成了 gorllia（猩猩），再后来就写成了 monkey(猴子)，所以猴子补丁的叫法是这么莫名其妙得来的。<strong>后来在动态语言中，不改变源代码而对功能进行追加和变更，统称为“猴子补丁”。</strong> 所以猴子补丁并不是 Python 中专有。猴子补丁这种东西充分利用了动态语言的灵活性，可以对现有的语言 API 进行追加，替换，修改Bug，甚至性能优化等等。使用猴子补丁的方式，gevent 能够修改标准库里面大部分的阻塞式系统调用，包括 socket、ssl、threading 和 select 等模块，而变为协作式运行。也就是通过猴子补丁的 monkey.patch_xxx() 来将 python 标准库中模块或函数 改成 gevent 中相应的具有协程的协作式对象。这样在不改变原有代码的情况下，将应用的阻塞式方法，变成协程式。</li><li>**猴子补丁使用注意事项。**猴子补丁的功能很强大，但是也带来了很多的风险，尤其是像 gevnet 这种直接进行 API 替换的补丁，整个 Python 进程所使用的模块都会被替换，可能自己的代码能hold 住，但是其它第三方库，有时候问题并不好排查，即使排查出来也是很棘手，所以，就像松本建议的那样，<strong>如果要使用猴子补丁，那么只是做功能追加，尽量避免大规模的 API 覆盖。虽然猴子补丁仍然是邪恶的（evil），但在这种情况下它是“有用的邪恶（useful evil）”</strong></li></ul><h3 id="2-3、Linux-的-epoll-和-libev"><a href="#2-3、Linux-的-epoll-和-libev" class="headerlink" title="2.3、Linux 的 epoll 和 libev"></a>2.3、Linux 的 epoll 和 libev</h3><ul><li>Linux 的 epoll 机制：epoll 是 Linux 内核为处理大批量文件描述符而作了改进的 poll，是 Linux 下 <strong>多路复用 IO</strong> select&#x2F;poll 的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU 利用率。epoll 的优点：支持一个进程打开大数目的 socket 描述符。select 的一个进程所打开的 FD 由 FD_SETSIZE 的设置来限定，而 epoll 没有这个限制，它所支持的 FD 上限是最大可打开文件的数目，远大于 2048，而且 IO 效率不随 FD 数目增加而线性下降：由于 epoll 只会对 “活跃” 的 socket 进行操作，于是只有 “活跃” 的socket 才会主动去调用 callback 函数，其他 idle 状态的 socket 则不会。epoll 使用 mmap 加速内核与用户空间的消息传递。epoll 是通过内核与用户空间 mmap 同一块内存实现的。</li><li>libev 机制：提供了指定文件描述符事件发生时调用回调函数机制。libev 是一个事件循环器：向 libev 注册感兴趣的事件，比如 socket 可读事件，libev 会对所注册的事件源进行管理，并在事件发生时触发相应的程序。</li></ul><h3 id="三、使用示例"><a href="#三、使用示例" class="headerlink" title="三、使用示例"></a>三、使用示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;get: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(url))</span><br><span class="line">    response = requests.get(url).content</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(url, <span class="built_in">len</span>(response)))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    gevent.joinall([</span><br><span class="line">        gevent.spawn(fetch, <span class="string">&quot;https://stackoverflow.com/&quot;</span>),</span><br><span class="line">        gevent.spawn(fetch, <span class="string">&quot;https://www.douban.com&quot;</span>),</span><br><span class="line">        gevent.spawn(fetch, <span class="string">&quot;https://www.github.com&quot;</span>)</span><br><span class="line">    ])</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">urls = [<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;www.github.com&#x27;</span>, <span class="string">&#x27;www.douban.com&#x27;</span>]</span><br><span class="line">    <span class="comment"># 获取域名ip</span></span><br><span class="line">jobs = [gevent.spawn(socket.gethostbyname, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">gevent.joinall(jobs, timeout=<span class="number">2</span>)</span><br><span class="line">result = [job.value <span class="keyword">for</span> job <span class="keyword">in</span> jobs]</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h2 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h2><p><a href="https://blog.csdn.net/freeking101/article/details/53097420/">https://blog.csdn.net/freeking101/article/details/53097420/</a></p><p><a href="http://www.xuebuyuan.com/1604603.html">http://www.xuebuyuan.com/1604603.html</a></p><p>Gevent 指南(中文)：<a href="http://xlambda.com/gevent-tutorial">http://xlambda.com/gevent-tutorial</a><br>Gevent 指南(中文)下载地址：<a href="http://download.csdn.net/download/freeking101/9924351">http://download.csdn.net/download/freeking101/9924351</a><br>初试Gevent – 高性能的 Python 并发<a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020">框架</a>：<a href="http://python.jobbole.com/87041">http://python.jobbole.com/87041</a></p><p>Python 开发使用 Gevent：<a href="http://sdiehl.github.io/gevent-tutorial/">http://sdiehl.github.io/gevent-tutorial/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;python编程中，我们使用到的并发框架主要有以下几种&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://cxinxian.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>线程池的拒绝策略</title>
    <link href="http://cxinxian.github.io/2022/06/13/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5/"/>
    <id>http://cxinxian.github.io/2022/06/13/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5/</id>
    <published>2022-06-13T06:01:20.000Z</published>
    <updated>2025-02-21T12:58:15.246Z</updated>
    
    <content type="html"><![CDATA[<p>在使用线程池 ThreadPoolExecutor 创建线程池时，我们都会使用到这样的一个参数 <code>RejectedExecutionHandler handler</code>，这就是线程池拒绝策略的抽象接口，在 Java 中提供了4种策略供我们使用，分别是<code>AbortPlicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy</code> ,下面就会展开分析这4种策略的区别。</p><span id="more"></span><p>拒绝策略的主要作用就是，当线程池达到最大的线程数或者线程队列满了的情况下，需要线程池对后续提交的线程任务做出的处理方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment"> *        pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment"> *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment"> *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment"> *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment"> *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment"> *        creates a new thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment"> *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;</span></span><br><span class="line"><span class="comment"> *         or &#123;<span class="doctag">@code</span> threadFactory&#125; or &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><p>拒绝策略的核心是: <code>rejectedExecution</code> 方法，我们要想实现自定义的拒绝逻辑可以通过实现这个接口方法 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一、AbortPolicy"><a href="#一、AbortPolicy" class="headerlink" title="一、AbortPolicy"></a>一、AbortPolicy</h2><p>直接丢弃任务，抛出 <code>RejectedExecutionExecption</code> 异常，是默认策略。</p><p>RejectiedExectionExecption 属于 RuntimeException，会让你知道任务被拒绝了，我们便可以根据业务逻辑来决定是否重试或放弃任务。</p><h2 id="二、CallerRunsPolicy"><a href="#二、CallerRunsPolicy" class="headerlink" title="二、CallerRunsPolicy"></a>二、CallerRunsPolicy</h2><p>只用调用者所在的线程处理任务</p><p>当有新的任务提交后，线程池没有被关闭且没有执行能力，则把这个任务提交给提交任务的线程执行，也即谁提交的任务，谁负责执行。</p><p>好处是：</p><blockquote><ol><li>新提交的任务不会被丢弃，不会造成业务损失。</li><li>谁提交任务谁执行，相当于提交任务的线程负责任务的执行，如果执行任务是比较耗时的，那在这段时间内，提交任务的线程将会被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于一个负反馈。与此同时，线程池中的线程也可以充分利用这段时间来执行其他任务，腾出一定的空间，相当于给线程池一定的缓冲期。</li></ol></blockquote><p>缺点是：</p><blockquote><p>当流量过大，线程池处理的任务一直在占用执行，没有设置超时，导致线程池被打满触发饱和策略 CallerRunsPolicy ,而此时主线程去处理提交任务，而任务又是阻塞的，主线程也会被 hang 住，导致主线程超时，引发故障。</p></blockquote><h2 id="三、DiscardOldestPolicy"><a href="#三、DiscardOldestPolicy" class="headerlink" title="三、DiscardOldestPolicy"></a>三、DiscardOldestPolicy</h2><p>丢弃等待队列中等待时间最长的任务，执行当前任务</p><p>线程池没有关闭但是没有执行能力，使用该策略则会丢弃任务队列中的头节点，通常是存活时间最长的任务，这种策略 与 <code>AbortPolicy</code> 策略不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的。这样就可以腾出空间给新提交的任务线程，这样的风险就是会丢失数据。</p><h2 id="四、DiscardPolicy"><a href="#四、DiscardPolicy" class="headerlink" title="四、DiscardPolicy"></a>四、DiscardPolicy</h2><p>直接丢弃任务，不抛异常。</p><p>当线程池满了或者队列满了，新提交的线程任务会被直接丢弃，不会有任何的异常通知，同样的风险也是会丢失数据。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用线程池 ThreadPoolExecutor 创建线程池时，我们都会使用到这样的一个参数 &lt;code&gt;RejectedExecutionHandler handler&lt;/code&gt;，这就是线程池拒绝策略的抽象接口，在 Java 中提供了4种策略供我们使用，分别是&lt;code&gt;AbortPlicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy&lt;/code&gt; ,下面就会展开分析这4种策略的区别。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://cxinxian.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Docker 笔记</title>
    <link href="http://cxinxian.github.io/2022/01/01/docker/docker%E7%AC%94%E8%AE%B0/"/>
    <id>http://cxinxian.github.io/2022/01/01/docker/docker%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-01T06:45:10.000Z</published>
    <updated>2025-02-21T10:05:26.847Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 是基于 <a href="https://www.runoob.com/go/go-tutorial.html">go语言</a> 并遵从 Apacher2.0 协议的开源应用容器引擎。</p><p>Docker 能够让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器，也可以实现虚拟化。</p><span id="more"></span><p>容器时完全使用沙箱机制，相互之间不会有任何接口，性能开销极低。</p><ul><li>官网地址：<a href="https://www.docker.com/">https://www.docker.com/</a> </li><li>文档地址：<a href="https://docs.docker.com/">https://docs.docker.com/</a> </li><li>仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a></li></ul><h2 id="一、关于Docker"><a href="#一、关于Docker" class="headerlink" title="一、关于Docker"></a>一、关于Docker</h2><p>在了解Docker 之前，我们都知道虚拟机。其实虚拟机和 Docker 都属于虚拟化技术。</p><p>它们之间的区别如下：</p><ul><li><p>虚拟机：通Vmware 可以虚拟化出一个新的操作系统环境，缺点是非常笨重，占用空间大，启动满。</p></li><li><p>Docker：与虚拟机相比起来，docker更加轻巧，占用空间小，启动快。</p></li><li><p>传统的虚拟机，虚拟出一套硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件。</p></li><li><p>容器内的应用直接运行在宿主主机的内核，容器时没有自己的内核，也没有虚拟我们的硬件，所以就更轻便</p></li><li><p>每个容器之间是相互隔离，每个容器内都有一个属于自己的文件系统，互不影响。</p></li></ul><p><img src="/../assets/blogImg/docker/docker/docker-assets/image-20220321162541913.png" alt="image-20220321162541913"></p><h3 id="1-1、Docker-能干什么？"><a href="#1-1、Docker-能干什么？" class="headerlink" title="1.1、Docker 能干什么？"></a>1.1、Docker 能干什么？</h3><p>Docker 是一个用于开发，交付和运行的应用程序的开发平台。Docker 能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker ，可以与管理应用程序相同的方式来管理基础架构。能够快速交付，测试和部署代码，减少编写代码和在生产环境中运行代码之间的延迟。</p><p><strong>主要应用场景如下：</strong></p><ul><li>Web 应用的自动化打包和发布</li><li>自动化测试和持续集成、发布</li><li>在服务型环境中部署和调整数据库或其他后台应用</li><li>从头编译或拓展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 Paas 环境</li></ul><p><strong>优点：</strong></p><ul><li>能够快速地交付和部署应用，非常适合持续集成和持续交付流程（CI&#x2F;CD）</li><li>响应式部署升级和扩缩容</li><li>更简单的系统运维</li><li>更高效地利用计算机资源</li></ul><h3 id="1-2、Docker-的组成部分"><a href="#1-2、Docker-的组成部分" class="headerlink" title="1.2、Docker 的组成部分"></a>1.2、Docker 的组成部分</h3><p><strong>Docker 核心概念</strong></p><ul><li>**镜像（Image）：**Docker 镜像就相当于一个root 文件系统。用于创建Docker容器的模板，可以理解为一个基础的文件模板，通过镜像可以创建多个容器。</li><li>**容器（Container）：**独立运行的一个或一组应用，是镜像的运行时实体。镜像和容器的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停。每个容器的运行是相互独立、相互隔离的。</li><li>**仓库（Repository）：**仓库是存放镜像的地方，用来保存镜像。</li></ul><p>**Docker 逻辑上由三部分组成：**Daemon(守护进程)、Rest API(API,所有客户端都通过API进行操作)、Client(客户端)</p><p><img src="/../assets/blogImg/docker/docker/docker-assets/image-20220322092715451.png" alt="image-20220322092715451"></p><p>Docker 使用C&#x2F;S 架构模式，Docker 的守护进程（daemon）运行在主机上，使用远程API 来管理和创建 Docker 容器。Docker 容器通过  Docker 镜像来创建。</p><p><strong>Docker 为什么比 vm 快？</strong></p><p>1、Docker 比 vm 更少的抽象层。</p><p>2、Docker 利用的时宿主主机内核，vm 需要 Guest OS。</p><p><img src="/../assets/blogImg/docker/docker/docker-assets/image-20220322134905047.png" alt="image-20220322134905047"></p><p>在新建容器时，Docker 不需要像虚拟机一样重新加载一个操作系统内核，避免引导，虚拟机时加载 Guest OS , 是分钟级别的；而Docker 是利用宿主主机的操作系统，属于秒级。</p><h2 id="二、Docker安装和卸载（CentOS）"><a href="#二、Docker安装和卸载（CentOS）" class="headerlink" title="二、Docker安装和卸载（CentOS）"></a>二、Docker安装和卸载（CentOS）</h2><p>如果系统上存在较旧的 Docke 版本，可以先进行卸载操作（较旧的Docke 版本称为 docker 或 docker-engine）,如果已安装这些程序，请卸载它们以及相关依赖项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载旧版本docker</span></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">docker-client \</span><br><span class="line">docker-client-latest \</span><br><span class="line">docker-common \</span><br><span class="line">docker-latest \ </span><br><span class="line">docker-latest-logrotate \</span><br><span class="line">docker-logrotate \ </span><br><span class="line">docker-engine</span><br></pre></td></tr></table></figure><blockquote><p>使用 Docker 仓库进行安装</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装所需的软件包。</span></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 docker 可以设置选择以下几个地址进行安装</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、使用官方源地址（很慢）</span></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、选国内阿里云作为源地址</span></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3、选清华源地址</span></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 Docker Engine-Community 和 ontainerd</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从高到低列出存储库中可用的 Docker Engine-Community 版本</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">选择安装特版本的软件包</span></span><br><span class="line">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli &lt;VERSION_STRING&gt; containerd.io</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 Docker</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行 hello-world 映像来验证是否正确安装docker,该命令执行时，会检查本地是否存在 hello-world 镜像，如果没有，则从远端仓库 pull 拉取到本地</span></span><br><span class="line">sudo docker run hello-world</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>卸载 docker</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除安装包</span></span><br><span class="line">yum remove docker-ce</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除镜像、容器、配置文件内容</span></span><br><span class="line">rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure><h2 id="三、Docker-的使用"><a href="#三、Docker-的使用" class="headerlink" title="三、Docker 的使用"></a>三、Docker 的使用</h2><h3 id="3-1、Docker-命令"><a href="#3-1、Docker-命令" class="headerlink" title="3.1、Docker 命令"></a>3.1、Docker 命令</h3><p>Docker 命令可以分为以下几大类：</p><p>docker 信息、镜像命令（包含镜像信息、镜像管理）、容器命令（包含容器信息、容器管理）</p><h4 id="3-1-1、docker-信息"><a href="#3-1-1、docker-信息" class="headerlink" title="3.1.1、docker 信息"></a>3.1.1、docker 信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker info# 显示docker 系统信息，包括版本信息，镜像信息</span><br><span class="line">docker version# 显示docker 版本信息</span><br><span class="line">docker --help# 查看帮助信息</span><br></pre></td></tr></table></figure><h4 id="3-1-2、镜像命令"><a href="#3-1-2、镜像命令" class="headerlink" title="3.1.2、镜像命令"></a>3.1.2、镜像命令</h4><h5 id="3-1-2-1、查看镜像"><a href="#3-1-2-1、查看镜像" class="headerlink" title="3.1.2.1、查看镜像"></a>3.1.2.1、查看镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看主机上的所有镜像信息</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   5 months ago   13.3kB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释</span></span><br><span class="line">REPOSITORY# 镜像的仓库源</span><br><span class="line">TAG# 镜像的标记，表示不同的版本</span><br><span class="line">IMAGE ID# 镜像 ID</span><br><span class="line">CREATED# 镜像创建时间</span><br><span class="line">SIZE# 镜像大小</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选参数</span></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             # 显示所有镜像信息</span><br><span class="line">      --digests         # 显示概要信息</span><br><span class="line">  -f, --filter filter   # 根据指定信息过滤输出镜像信息</span><br><span class="line">      --format string   # 格式化打印输出</span><br><span class="line">      --no-trunc        # 不截断输出显示信息</span><br><span class="line">  -q, --quiet           # 仅显示镜像的 id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有镜像的 <span class="built_in">id</span> 信息</span></span><br><span class="line">docker images -aq</span><br></pre></td></tr></table></figure><h5 id="3-1-2-2、获取镜像"><a href="#3-1-2-2、获取镜像" class="headerlink" title="3.1.2.2、获取镜像"></a>3.1.2.2、获取镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从源仓库中获取镜像（没有指定版本，默认拉起最新的版本）</span></span><br><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><h5 id="3-1-2-3、搜索镜像"><a href="#3-1-2-3、搜索镜像" class="headerlink" title="3.1.2.3、搜索镜像"></a>3.1.2.3、搜索镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索指定的镜像</span></span><br><span class="line">docker search nginx</span><br><span class="line"></span><br><span class="line">[root@lsWnMbX2XF ~]# docker search nginx</span><br><span class="line">NAME                                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">nginx                                             Official build of Nginx.                        16492     [OK]       </span><br><span class="line">bitnami/nginx                                     Bitnami nginx Docker Image                      120   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选项</span></span><br><span class="line">Options:</span><br><span class="line">  -f, --filter filter   # 过滤条件</span><br><span class="line">      --format string   # 格式化输出</span><br><span class="line">      --limit int       # 限制输出最大数</span><br><span class="line">      --no-trunc        # 不截断输出</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-1-2-4、删除镜像"><a href="#3-1-2-4、删除镜像" class="headerlink" title="3.1.2.4、删除镜像"></a>3.1.2.4、删除镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除镜像使用 docker rmi 命令</span></span><br><span class="line">docker rmi -f 镜像名称或镜像id# 删除指定的镜像</span><br><span class="line">docker rmi -f 镜像id 镜像id# 删除指定的多个进行</span><br><span class="line">docker rmi -f $(docker images -aq)    # 删除docker 上的所有镜像 </span><br></pre></td></tr></table></figure><h5 id="3-1-2-5、更新镜像"><a href="#3-1-2-5、更新镜像" class="headerlink" title="3.1.2.5、更新镜像"></a>3.1.2.5、更新镜像</h5><p>当镜像有需要更新的情况下，比如在一个 CentOS 容器中做了更新后，希望这些更新能够作用到镜像上面，可以通过下面的命令来解决。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如 通过 docker run -t -i CentOS /bin/bash 命令进入了一个容器，使用 apt-get update 命令来进行更新。</span></span><br><span class="line">docker commit -m=&quot;hash update&quot; -a=&quot;my&quot; 5e07a0cec452  my/CentOS:v2</span><br><span class="line">sha256:5e07a0cec452cd2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数解释</span></span><br><span class="line">-m: 提交的描述信息</span><br><span class="line">-a: 指定镜像作者</span><br><span class="line">5e07a0cec452：容器ID</span><br><span class="line">my/CentOS:v2: 指定要创建目标镜像名</span><br></pre></td></tr></table></figure><h5 id="3-1-2-6、查看镜像的变更"><a href="#3-1-2-6、查看镜像的变更" class="headerlink" title="3.1.2.6、查看镜像的变更"></a>3.1.2.6、查看镜像的变更</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 dockers <span class="built_in">history</span> 可以查看镜像的变更历史 或者说 查看镜像的 dockerfile</span></span><br><span class="line">docker history image</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看详细信息</span></span><br><span class="line">docker history --format &#123;&#123;.CreatedBy&#125;&#125; --no-trunc=true 镜像id |sed &quot;s/\/bin\/sh\ -c\ \#(nop)\ //g&quot;|sed &quot;s/\/bin\/sh\ -c/RUN/g&quot; | tac</span><br></pre></td></tr></table></figure><h4 id="3-1-3、容器命令"><a href="#3-1-3、容器命令" class="headerlink" title="3.1.3、容器命令"></a>3.1.3、容器命令</h4><blockquote><p>当通过 docker run 来启动一个容器时，docker 运行的操作主要包括一下几个步骤：</p><ul><li>检查本地是否存在指定的镜像，不存在就从远程仓库源中下载；</li><li>利用进行创建容器，并启动容器；</li><li>分配一个文件系统给容器，并在只读镜像层外面挂载一层可读写层；</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中；</li><li>从网桥的地址池配置一个IP地址给容器；</li><li>执行用户指定的应用程序；</li><li>执行完毕后容器被自动停止。</li></ul></blockquote><h5 id="3-1-3-1、启动容器"><a href="#3-1-3-1、启动容器" class="headerlink" title="3.1.3.1、启动容器"></a>3.1.3.1、启动容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 CentOs 镜像启动一个容器，参数以命令行进入该容器,可以进入容器进行交互操作</span></span><br><span class="line">docker run -it CentOS /bin/bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line">Option:</span><br><span class="line">-i: #交互式操作</span><br><span class="line">-t: #终端</span><br><span class="line">-CentOs: #镜像</span><br><span class="line">/bin/bash: #放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</span><br><span class="line"></span><br><span class="line">-d:#后台运行容器</span><br><span class="line">-name:#给当前运行容器指定名称</span><br><span class="line">-p:#为运行容器指定端口映射</span><br><span class="line">-P:#随机指定暴露端口映射</span><br><span class="line">-v:#指定挂载数据卷</span><br><span class="line">-w:#指定容器中的工作目录</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入 <span class="built_in">exit</span> 命令可以推出当前容器，这样会导致容器的停止</span></span><br><span class="line">root@66811deee943:/# exit</span><br><span class="line">exit</span><br><span class="line">[root@lsWnMbX2XF ~]# </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们可以通过 dokcer <span class="built_in">exec</span> -it [容器<span class="built_in">id</span>/容器name] /bin/bash 获得shell进入容器，然后再 <span class="built_in">exit</span> 退出的话，则不会导致容器的停止。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">除此之外还可以通过 ctrl + p + q 来从当前运行的容器退出到后台继续运行</span></span><br><span class="line">[root@lsWnMbX2XF ~]# docker exec -it e57e6d41e443 /bin/bash</span><br><span class="line">root@e57e6d41e443:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@e57e6d41e443:/# exit</span><br><span class="line">exit</span><br><span class="line">[root@lsWnMbX2XF ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS                      PORTS                                       NAMES</span><br><span class="line">e57e6d41e443   ubuntu    &quot;/bin/bash&quot;              49 minutes ago   Up 33 seconds                                                           ubuntu2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要想与在后台运行的容器进行交互操作，除了docker <span class="built_in">exec</span> 还可以，通过 docker attach [容器<span class="built_in">id</span>/容器 name] 进入终端交互</span></span><br><span class="line">[root@lsWnMbX2XF ~]# docker attach e57e6d41e443</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台运行一个 ubuntu 容器，可通过 -d 参数选项来指定运行模式</span></span><br><span class="line">[root@lsWnMbX2XF ~]# docker run -itd --name ubuntu2 ubuntu /bin/bash</span><br><span class="line">e57e6d41e4436db3d04a69df813219ab27ded35e0f162d8056a351106b6e842d</span><br><span class="line">[root@lsWnMbX2XF ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED             STATUS             PORTS                                       NAMES</span><br><span class="line">e57e6d41e443   ubuntu    &quot;/bin/bash&quot;              42 seconds ago      Up 41 seconds                                                  ubuntu2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-1-3-2、查看容器"><a href="#3-1-3-2、查看容器" class="headerlink" title="3.1.3.2、查看容器"></a>3.1.3.2、查看容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker ps 不加参数默认只显示当前正在运行的容器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选参数</span></span><br><span class="line">Options:</span><br><span class="line">-a --all: # 查看所有容器</span><br><span class="line">-q --quiet: # 只显示容器id</span><br><span class="line">-n --last: # 显示最近创建的容器</span><br></pre></td></tr></table></figure><h5 id="3-1-3-3、暂停容器、停止容器"><a href="#3-1-3-3、暂停容器、停止容器" class="headerlink" title="3.1.3.3、暂停容器、停止容器"></a>3.1.3.3、暂停容器、停止容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂停容器</span></span><br><span class="line">docker pause 容器id 或 容器name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">继续运行暂停的容器</span></span><br><span class="line">docker unpause 容器id 或 容器name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器，这个命令会先向容器发送 SIGTERM 信号，等一段时间后（默认10s），再发生 SIGKILL 信号来终止容器。</span></span><br><span class="line">docker stop 容器id 或 容器name</span><br></pre></td></tr></table></figure><h5 id="3-1-3-4、启动容器、重启容器"><a href="#3-1-3-4、启动容器、重启容器" class="headerlink" title="3.1.3.4、启动容器、重启容器"></a>3.1.3.4、启动容器、重启容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器</span></span><br><span class="line">docker start 容器id 或 容器name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart 容器id 或 容器name</span><br></pre></td></tr></table></figure><h5 id="3-1-3-5、删除容器"><a href="#3-1-3-5、删除容器" class="headerlink" title="3.1.3.5、删除容器"></a>3.1.3.5、删除容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器在非运行状态下通过下面的命令可以进行删除</span></span><br><span class="line">docker rm 容器id 或 容器name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器在运行状态下通过添加参数 -f 强制删除</span></span><br><span class="line">docker rm -f 容器id 或 容器name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选参数解释</span></span><br><span class="line">Options:</span><br><span class="line">-f,--force:# 强制删除正在运行的容器</span><br><span class="line">-l,--link:     # 删除容器指定的关联</span><br><span class="line">-v,--volumes:# 删除容器关联的数据卷</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果要删除所有的容器，可使用以下命令</span></span><br><span class="line">docker rm `docker ps -aq` 或者 docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><h5 id="3-1-3-6、导出导入容器"><a href="#3-1-3-6、导出导入容器" class="headerlink" title="3.1.3.6、导出导入容器"></a>3.1.3.6、导出导入容器</h5><p>在有些时候，我们需要将容器从一台机器迁移到另外一台机器，这时候就需要用到导入导出功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出容器</span></span><br><span class="line">docker export -o filename 容器name 或者</span><br><span class="line">docker export 容器name &gt; filename</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如</span></span><br><span class="line">docker export -o ex_ubuntu.tar ubuntu</span><br><span class="line">docker export ubuntu &gt; ex_ubuntu.tar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在导出容器包后，再传输到目标机器上再进行导入操作</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入容器</span></span><br><span class="line">docker import filename</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-1-3-7、提交容器"><a href="#3-1-3-7、提交容器" class="headerlink" title="3.1.3..7、提交容器"></a>3.1.3..7、提交容器</h5><p>当我们在使用容器时（如果不挂载卷），那么我们在容器上所做的修改都存储在容器中，docker 为我们提供了 docker commit 命令，可以间容器测存储层保存下来作为一个新的镜像。就是说，在原有镜像的基础上，加上容器的存储层，构成一个新的镜像。那以后运行新的镜像，就会拥有原容器的最后文件变化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用方法</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker commit [选项] &lt;容器ID 或者 容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span></span><br><span class="line"></span><br><span class="line">docker commit \</span><br><span class="line">--author &quot;chen &lt;xxxx@qq.com&gt;&quot; \</span><br><span class="line">--message &quot;修改了什么&quot; \</span><br><span class="line">containername \</span><br><span class="line">image:v2</span><br></pre></td></tr></table></figure><p>–author 指定了修改的作者</p><p>–message 记录修改本次的信息</p><h5 id="3-1-3-8、查看容器相关信息"><a href="#3-1-3-8、查看容器相关信息" class="headerlink" title="3.1.3.8、查看容器相关信息"></a>3.1.3.8、查看容器相关信息</h5><p>通过<code>docker inspect </code>命令可查看容器的具体信息，会以 json 格式返回容器 id、创建时间、路径状态、镜像、配置在内的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id 或者 容器名称</span><br></pre></td></tr></table></figure><p><img src="/../assets/blogImg/docker/docker/docker-assets/image-20220323141254763.png" alt="image-20220323141254763"></p><p>使用以下命令可查看容器中的进程信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器名 或 ID</span><br></pre></td></tr></table></figure><h5 id="3-1-3-9、暴露端口、端口映射"><a href="#3-1-3-9、暴露端口、端口映射" class="headerlink" title="3.1.3.9、暴露端口、端口映射"></a>3.1.3.9、暴露端口、端口映射</h5><p>一般来说外部机器无法直接通过网络来和容器进行通信，但宿主机可以和容器直接进行通信，因此我们可以借助宿主机来和容器进行通信。如在运行nginx 时可以将宿主机的端口和容器的端口进行映射，这样外部机器便可以通过访问宿主机从而访问到容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暴露端口</span></span><br><span class="line">--expose list   # Expose a port or a range of port 暴露端口，指明容器提供服务需要用到的端口</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果使用 docker run ，指定了 -P ，那么会将暴露的端口和宿主机的随机高级端口进行映射</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果使用 docker run , 指定 --net=host 宿主机网络模式，容器 expose 暴露的端口会直接使用宿主机对于的端口，不存在映射关系。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如 docker run --name nginx_net -d --net=host nginx</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果容器 expose 暴露的端口需要和宿主机的某个端口建立映射关系，还需要用到 -p 来指定端口映射</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">映射端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行 nginx 将容器的80 端口和宿主机的8080端口进行映射，这样我们就可以在浏览器中通过8080端口访问到容器中的nginx</span> </span><br><span class="line">docker run -d --name nginx -p 8080:80 nginx</span><br></pre></td></tr></table></figure><h5 id="3-1-3-10、其他命令"><a href="#3-1-3-10、其他命令" class="headerlink" title="3.1.3.10、其他命令"></a>3.1.3.10、其他命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行容器时，设置环境变量</span></span><br><span class="line">-e,--env list   # set enviroment variable  设置环境变量</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如 启动 Ubuntu 时设置环境变量</span></span><br><span class="line">docker run -it --name ubuntu -e MYPATH=/usr/local ubuntu /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定工作目录，指定容器中的工作目录，运行容器后，容器就在指定的工作目录</span></span><br><span class="line">-w,--workdir string # working directory inside the container指定容器中的工作目录</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如:</span></span><br><span class="line">docker run -it --name ubuntu2 -w /usr/local ubuntu /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从容器中拷贝文件到到宿主机</span></span><br><span class="line">docker cp ubuntu2:/home/test.txt /home</span><br><span class="line">[root@lsWnMbX2XF home]# docker cp ubuntu2:/home/test.txt /home</span><br><span class="line">[root@lsWnMbX2XF home]# ls</span><br><span class="line">test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们修改了容器的文件，改动了容器的存储层，可以通过 docker diff 命令可以看到具体的改动</span></span><br><span class="line">docker diff</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行容器：docker run 参数 redis （镜像名称）</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -d -p 6379:6379 --restart=on-failure:10 --name myredis redis</span></span><br></pre></td></tr></table></figure><h3 id="3-2、Dockerfile"><a href="#3-2、Dockerfile" class="headerlink" title="3.2、Dockerfile"></a>3.2、Dockerfile</h3><p>通常地，构建镜像有两种方式：</p><ul><li>基于容器制作</li><li>通过Dockerfile 构建</li></ul><p>Dockerfile 一般用于构建镜像的文本文件，包含了一条条构建镜像所需的指令和说明。网络上的镜像难以满足现实中各式各样的需求，而Dockerfile 能够让用户个性化定制 Docker 镜像。</p><h4 id="3-2-1、Dockerfile-格式"><a href="#3-2-1、Dockerfile-格式" class="headerlink" title="3.2.1、Dockerfile 格式"></a>3.2.1、Dockerfile 格式</h4><blockquote><ol><li>Dockerfile 的整体语句就有两类：<ul><li>#头的注释</li><li>Instruction arguments 指令 参数，一行一个指令。</li></ul></li><li>Dockerfile 的文件名首字母必须大写</li><li>Dockerfile 指令不区分大小写，但是为了和参数区分开来，一般指令都是大写字母</li><li>Dockerfile 指令的执行顺序是由上往下依次执行</li><li>Dokcerfile 的第一个非注释行必须是 FROM 指令，用来指定当前制作的镜像依据的基础镜像</li><li>Dockerfile 需要调用的文件必须跟Dockerfile文件在同一目录下，或者在其子目录下，父目录或其他目录无效</li></ol></blockquote><h4 id="3-2-2、Dockerfile-指令"><a href="#3-2-2、Dockerfile-指令" class="headerlink" title="3.2.2、Dockerfile 指令"></a>3.2.2、Dockerfile 指令</h4><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>指定构建镜像的来源，基础镜像</td></tr><tr><td>MAINTAINER</td><td>Dockerfile 作者信息 MAINTAINER name <a href="mailto:&#x78;&#120;&#120;&#64;&#113;&#113;&#x2e;&#x63;&#x6f;&#109;">xxx@qq.com</a> or MAINTAINER “<a href="mailto:&#x78;&#120;&#x78;&#64;&#113;&#113;&#46;&#x63;&#111;&#109;">xxx@qq.com</a>“</td></tr><tr><td>RUN</td><td>在当前镜像基础上执行指定的命令 RUN <command> or RUN[“execuable”,”params1”,”params2”]<br/>注意：<br><span style="color:red">Dockerfile 的指令每执行一次都会在docker 上新建一层，应该避免过多无意义层导致docker 膨胀过大。</span></td></tr><tr><td>COPY</td><td>复制指令，build 时复制，从上下文目录中复制文件或目录到容器里指定路径 COPY <src> <dest></td></tr><tr><td>ADD</td><td>和 COPY 功能类似，build 时复制。<br>&lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;</td></tr><tr><td>CMD</td><td>类似RUN，用于运行行程序，<br>与RUN不同的是：<br>CMD 在 docker run 时运行；<br>RUN 实在 docker build</td></tr><tr><td>ENTRYPOINT</td><td>类似 CMD，指定容器启动程序和参数<br>指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：<br><ENTRYPOINT> “<CMD>“</td></tr><tr><td>ENV</td><td>设置环境变量以便在后续的指令中可以使用环境变量，构建好的镜像内会存在该环境变量<br>ENV <key> <value> ENV <key1>&#x3D;<value1> <key2>&#x3D;<value2>…</td></tr><tr><td>ARG</td><td>定义 Dockerflie 内的环境变量，仅在 Dockerfile内有效，只有在 docker build 过程中有效，镜像中不存在该环境变量 <br>&lt;参数名&gt;[&#x3D;&lt;默认值&gt;]</td></tr><tr><td>EXPOSE</td><td>声明暴露的端口</td></tr><tr><td>WORKDIR</td><td>用于指定工作目录，WORKDIR 指定的工作目录，必须是提前创建好的</td></tr><tr><td>ONBUILD</td><td>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这时执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</td></tr><tr><td>USER</td><td>指定后续命令的用户和用户组，切换后续命令执行的用户</td></tr><tr><td>HEALTHCHECK</td><td>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</td></tr><tr><td>LABEL</td><td>LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式 LABEL <key>&#x3D;<value></td></tr><tr><td>VOLUME</td><td>指定挂载目录</td></tr></tbody></table><h4 id="3-2-3、Dockerfile-的构建过程"><a href="#3-2-3、Dockerfile-的构建过程" class="headerlink" title="3.2.3、Dockerfile 的构建过程"></a>3.2.3、Dockerfile 的构建过程</h4><p>dockerfile 是用来构建docker镜像的命令参数脚本文件</p><p>通过脚本命令生成镜像，镜像时一层层的，每个命令都是一层</p><p>在编写构建镜像脚本时，我们应该尽可能的简化命令，减少镜像的层数，同时也要压缩镜像的体积。多个命令能合成一行写的就合并为一行。</p><p>docker 构建镜像的步骤：</p><ul><li>编写 dockerfile 脚本文件，指定镜像源、设置命令</li><li>通过 <code>docker build -t name:tag .</code> 命令来构建镜像</li><li>docker run 运行镜像</li><li>docker push 发布推送镜像（DockerHub、阿里云镜像仓库）</li></ul><h3 id="3-3、数据管理"><a href="#3-3、数据管理" class="headerlink" title="3.3、数据管理"></a>3.3、数据管理</h3><p>在docker 的应用中，我们往往需要对数据进行持久化或者多个容器之间需要对数据共享，而在必要涉及到容器数据的管理操作。容器中的数据管理操作分为以下两种方式：</p><ul><li>数据卷（Data Volumes）：容器内数据直接映射到宿主机环境。</li><li>数据卷容器（Data Volumes Containers) ：使用特顶容器维护数据卷。</li></ul><h4 id="3-3-1、挂载数据卷"><a href="#3-3-1、挂载数据卷" class="headerlink" title="3.3.1、挂载数据卷"></a>3.3.1、挂载数据卷</h4><blockquote><p>数据卷是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类型 Linux 中的 mount 行为</p><ul><li>数据卷可以在容器间共享和重用，使得容器间传递数据将变得高效与方便；</li><li>无论是在宿主机操作还是容器内操作，对数据卷的修改操作会立马生效</li><li>对数据卷的更新不会影响镜像，解耦应用和数据</li><li>卷会一直存在，直到没有容器使用，可以安全的卸载它（即使容器被删除，宿主机数据卷还存在）。</li></ul></blockquote><p>通常在启动容器时可通过 <code>-v,--volume</code> 参数指令来设置容器数据卷的挂载。这样容器和宿主机直接就可以通过一个目录来同步数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以启动 ubuntu 容器为例子</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v 宿主机目录:容器目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、使用Ubuntu镜像启动一个容器</span></span><br><span class="line">[root@lsWnMbX2XF home]# docker run -it --name u1 -v /home/docker/data:/home/data ubuntu /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、在容器中切换到挂载卷目录下创建 hello.txt 文件并写入文本内容</span></span><br><span class="line">root@31fd57fdd8d4:/home/data# echo &quot;hello,message from docker of ubuntu system&quot; &gt; hello.txt</span><br><span class="line">root@31fd57fdd8d4:/home/data# ls</span><br><span class="line">hello.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3、回到宿主机切换到挂载目录下，可以看到在容器所创建的hello.txt文本，同时在宿主机也创建 world.txt 文本并写入内容</span></span><br><span class="line">[root@lsWnMbX2XF data]# echo &quot;hello ,message from main machin&quot; &gt; world.txt</span><br><span class="line">[root@lsWnMbX2XF data]# ls</span><br><span class="line">hello.txt  world.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4、进入容器也可以看到宿主机所创建的 world.txt 文本。</span></span><br><span class="line">root@31fd57fdd8d4:/home/data# ls</span><br><span class="line">hello.txt  world.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面的尝试，指定宿主机的<code>/home/docker/data</code> 和容器 <code>/home/data</code> 目录之间建立了映射关系，无论是容器还是宿主机都可以对挂载卷进行修改操作，都可以在另一方得到呈现。</p><blockquote><p>此外，宿主机的同一个目录也支持多个容器进行映射，即多个容器可以挂载在宿主机的同一个目录下，这样就可以实现多个容器之间的数据共享</p></blockquote><h4 id="3-3-2、数据卷容器"><a href="#3-3-2、数据卷容器" class="headerlink" title="3.3.2、数据卷容器"></a>3.3.2、数据卷容器</h4><p>试想一下，如果我们要创建多个容器，并且这些容器之间都需要数据共享，那么如果按挂载数据卷的方式，创建一个容器就映射一次目录来实现数据卷挂载，这样岂不是很麻烦？那么是否有没有更加简便的方法来实现多容器间的数据共享呢？</p><p>答案是有的，就是通过 <strong>数据卷容器</strong> 来实现，首先创建一个数据卷容器并和宿主机建立相应的目录映射，然后在启动其他的容器时，通过命令 <code>-volumes-from</code> 来指定数据卷容器共享数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-volumes-from listMount volumes from the specified container(s) # 从一个特殊容器中挂载数据卷</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">docker run -<span class="built_in">id</span> --name volumes-container -v /home/data:/home/data ubuntu</span></span><br><span class="line">docker run -id --name u1 --volumes-from volumes-container ubuntu</span><br></pre></td></tr></table></figure><p>具体操作如下图所示：</p><p>先创建数据容器，将宿主机的目录对应地和数据卷容器的目录挂载，让后启动另外的容器并指定数据卷容器，这样就可以实现在多个容器之间共享数据。</p><p><img src="/assets/blogImg/docker/docker/docker-assets/image-20220324101505007.png" alt="image-20220324101505007"></p><h3 id="3-4、应用练习"><a href="#3-4、应用练习" class="headerlink" title="3.4、应用练习"></a>3.4、应用练习</h3><h4 id="3-4-1、构建一个带tomcat-的-Ubuntu-镜像"><a href="#3-4-1、构建一个带tomcat-的-Ubuntu-镜像" class="headerlink" title="3.4.1、构建一个带tomcat 的 Ubuntu 镜像"></a>3.4.1、构建一个带tomcat 的 Ubuntu 镜像</h4><blockquote><p>主要实现步骤有：<br>1、先准备好jdk、tomcat 包到指定的目录下</p><p>2、touch Dockerfile 创建文件，编写命令</p><p>3、在 Dockerfile 所在的目录下通过 <code>docker build -t name .</code> 构建镜像</p><p>注意 构建命令中的 <code>.</code> 代表的是 上下文 </p><p>上下文是指 Dockerfile 所在的目录，以及在构建镜像时，需要使用到宿主机文件的目录，dokcer build 知道这个命令后，会将路径下的所有内容打包。</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定镜像源</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置作者信息</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> <span class="string">&quot;chxinxian@163.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制文件到指定目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> Readme.md /usr/local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将软件包拷贝并解压到 /usr/local 目录下</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-8u201-linux-x64.tar.gz /usr/local</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> apache-tomcat-8.5.77.tar.gz /usr/local</span></span><br><span class="line"><span class="comment">#ADD create_tomcat_admin_user.sh /create_tomcat_admin_user.sh</span></span><br><span class="line"><span class="comment">#ADD run.sh /run.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过RUN 指令执行相关命令</span></span><br><span class="line"><span class="comment">#RUN sed -i &#x27;s/archive.ubuntu.com/cn.archive.ubuntu.com/g&#x27; /etc/apt/sources.list</span></span><br><span class="line"><span class="comment">#RUN sed -i &#x27;s/security.ubuntu/cn.archive.ubuntu/g&#x27; /etc/apt/sources.list</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Asia/Shanghai&quot;</span> &gt; /etc/timezone \</span></span><br><span class="line"><span class="language-bash">        &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="language-bash">        &amp;&amp; apt-get install -yq --no-install-recommends wget \</span></span><br><span class="line"><span class="language-bash">        &amp;&amp; apt-get clean \</span></span><br><span class="line"><span class="language-bash">        &amp;&amp; <span class="built_in">chmod</span> +x apache-tomcat-8.5.77/bin/*.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/jdk1.<span class="number">8.0</span>_201</span><br><span class="line"><span class="keyword">ENV</span> JRE_HOME $&#123;JAVA_HOME&#125;/jre</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH .:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line"><span class="keyword">ENV</span> PATH $&#123;JAVA_HOME&#125;/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行tomcat</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /usr/local/apache-tomcat-8.5.77/bin/startup.sh &amp;&amp; <span class="built_in">tail</span> -F /usr/local/apache-tomcat-8.5.77/lobs/catalina.out</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后通过 <code>docker build -t ubuntu-tomcat:v1 .</code> 命令构建镜像</p><h4 id="3-4-2、Dockerfile-构建-tomcat-镜像"><a href="#3-4-2、Dockerfile-构建-tomcat-镜像" class="headerlink" title="3.4.2、Dockerfile 构建 tomcat 镜像"></a>3.4.2、Dockerfile 构建 tomcat 镜像</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定镜像源</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置作者信息</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> <span class="string">&quot;chxinxian@163.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制文件到指定目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> Readme.md /usr/local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将软件包拷贝并解压到 /usr/local 目录下</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-8u201-linux-x64.tar.gz /usr/local</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> apache-tomcat-8.5.77-src.tar.gz /usr/local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过RUN 指令执行相关命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; apt install wget \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; apt-get install vim</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/jdk1.<span class="number">8.0</span>_201</span><br><span class="line"><span class="keyword">ENV</span> JRE_HOME $&#123;JAVA_HOME&#125;/jre</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH .:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line"><span class="keyword">ENV</span> PATH $&#123;JAVA_HOME&#125;/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行tomcat</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /usr/local/apache-tomcat-8.5.77/bin/startup.sh &amp;&amp; <span class="built_in">tail</span> -F /usr/local/apache-tomcat-8.5.77/logs/catalina.out</span></span><br></pre></td></tr></table></figure><h3 id="3-5、发布镜像"><a href="#3-5、发布镜像" class="headerlink" title="3.5、发布镜像"></a>3.5、发布镜像</h3><h4 id="3-5-1、注册-Docker-Hub-用户"><a href="#3-5-1、注册-Docker-Hub-用户" class="headerlink" title="3.5.1、注册 Docker Hub 用户"></a>3.5.1、注册 Docker Hub 用户</h4><p>到官网注册一个账号：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p>然后登录创建一个仓库，用来上传我们的镜像</p><h4 id="3-5-2、本地-Linux-登录-docker"><a href="#3-5-2、本地-Linux-登录-docker" class="headerlink" title="3.5.2、本地 Linux 登录 docker"></a>3.5.2、本地 Linux 登录 docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录</span></span><br><span class="line">docker login</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登出</span></span><br><span class="line">docker logout</span><br></pre></td></tr></table></figure><h4 id="3-5-3、给要上传发布的镜像打tab"><a href="#3-5-3、给要上传发布的镜像打tab" class="headerlink" title="3.5.3、给要上传发布的镜像打tab"></a>3.5.3、给要上传发布的镜像打tab</h4><p>因为推送镜像的规范是：<code>docker push 仓库名/镜像名:镜像版本</code> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tab ubuntu myrespo/ubuntu:v2</span><br></pre></td></tr></table></figure><p><img src="/../assets/blogImg/docker/docker/docker-assets/image-20220421143001304.png" alt="image-20220421143001304"></p><h2 id="四、Docker-网络"><a href="#四、Docker-网络" class="headerlink" title="四、Docker 网络"></a>四、Docker 网络</h2><p>Docker 在启动时会首先在宿主机上自动创建一个 docker0 虚拟网桥，实际上是 linux 网桥，它在内核层连通了其它的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p><p>网桥：可以理解为一个软件交换机，负责挂载在其上的接口之间进行包转发。在 shell 通过 ifconfig 命令可以查看。</p><p>​</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Docker 是基于 &lt;a href=&quot;https://www.runoob.com/go/go-tutorial.html&quot;&gt;go语言&lt;/a&gt; 并遵从 Apacher2.0 协议的开源应用容器引擎。&lt;/p&gt;
&lt;p&gt;Docker 能够让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器，也可以实现虚拟化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Docker" scheme="http://cxinxian.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://cxinxian.github.io/2021/12/07/Data-Structures-and-Algorithms/DS/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://cxinxian.github.io/2021/12/07/Data-Structures-and-Algorithms/DS/%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2021-12-07T13:50:09.000Z</published>
    <updated>2025-02-21T12:49:45.414Z</updated>
    
    <content type="html"><![CDATA[<p><strong>R-B Tree</strong>，全称 Red-Black Tree，又称为红黑树，他是一种<strong>自平衡</strong>的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红（Red）或黑（Black）。除了符合二叉查找树的基本特征外，还具备下来附属特征。</p><span id="more"></span><p><strong>红黑树的特征：</strong></p><ol><li>每个节点或者是黑色，或者是红色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL）是黑色。<span style="color:red"><strong>[注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</strong></span></li><li>如果一个节点是红色的，则它的子节点必须是黑色的。（从每个叶子节点到根的所有路径上不能有两个连续的红色节点）</li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li></ol><blockquote><p>注意：</p><ul><li>特征3 中的叶子节点，是只为空（NIL或 NULL）的节点</li><li>特征5，确保没有一条路径会比其他路径长出两倍。因而，红黑树是相对接近平衡的二叉树。</li></ul></blockquote><p><img src="/../../assets/blogImg/DSA/DataStructures/rbtree-simple.png" alt="rbtree-simple"></p><p>红黑树的应用比较广泛，主要是用来存储有序的数据，它的插入、删除、查找的最坏时间复杂度是 $O(logn)$ ，效率非常高。例如，Java集合中的 TreeSet 和 TreeMap ，C++ STL中的 set、map，以及 Linux 虚拟内存的管理，都是通过红黑树去实现的。</p><h2 id="红黑树的时间复杂度和相关证明"><a href="#红黑树的时间复杂度和相关证明" class="headerlink" title="红黑树的时间复杂度和相关证明"></a>红黑树的时间复杂度和相关证明</h2><p>红黑树的时间复杂度为 $O(logn)$</p><p>下面通过“数学归纳法”对红黑树的时间复杂度进行证明。</p><blockquote><p>定理：一颗含有n个节点的红黑树的高度至多为 $2log(n+1)$</p><p>证明：</p><p>“一棵含有n个节点的红黑树的高度至多为2log(n+1)” 的<strong>逆否命题</strong>是 “高度为h的红黑树，它的包含的内节点个数至少为 $2^{h&#x2F;2}-1$个”。</p><p>我们只需要证明逆否命题，即可证明原命题为真；即只需证明 “高度为h的红黑树，它的包含的内节点个数至少为 2h&#x2F;2-1个”。</p><p>从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x’s black height)，记为<strong>bh(x)</strong>。关于bh(x)有两点需要说明：<br>  第1点：根据红黑树的”<strong>特性(5)</strong> ，即<em>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</em>“可知，从节点x出发到达的所有的叶节点具有相同数目的黑节点。<strong>这也就意味着，bh(x)的值是唯一的</strong>！<br>  第2点：根据红黑色的”特性(4)，即<em>如果一个节点是红色的，则它的子节点必须是黑色的</em>“可知，从节点x出发达到叶节点”所经历的黑节点数目”&gt;&#x3D; “所经历的红节点的数目”。假设x是根节点，则可以得出结论”<strong>bh(x) &gt;&#x3D; h&#x2F;2</strong>“。进而，我们只需证明 “高度为h的红黑树，它的包含的黑节点个数至少为 2bh(x)-1个”即可。</p><p>到这里，我们将需要证明的定理已经由<br><strong>“一棵含有n个节点的红黑树的高度至多为2log(n+1)”</strong><br>  转变成只需要证明<br><strong>“高度为h的红黑树，它的包含的内节点个数至少为 2bh(x)-1个”。</strong></p><p>下面通过”数学归纳法”开始论证高度为h的红黑树，它的包含的内节点个数至少为 2bh(x)-1个”。</p><p>(01) 当树的高度h&#x3D;0时，<br>  内节点个数是0，bh(x) 为0，2bh(x)-1 也为 0。显然，原命题成立。</p><p>(02) 当h&gt;0，且树的高度为 h-1 时，它包含的节点个数至少为 2bh(x)-1-1。这个是根据(01)推断出来的！</p><p>  下面，由树的高度为 h-1 的已知条件推出“树的高度为 h 时，它所包含的节点树为 2bh(x)-1”。</p><p>  当树的高度为 h 时，<br>  对于节点x(x为根节点)，其黑高度为bh(x)。<br>  对于节点x的左右子树，它们黑高度为 bh(x) 或者 bh(x)-1。<br>  根据(02)的已知条件，我们已知 “x的左右子树，即高度为 h-1 的节点，它包含的节点至少为 2bh(x)-1-1 个”；</p><p>  所以，节点x所包含的节点至少为 ( 2bh(x)-1-1 ) + ( 2bh(x)-1-1 ) + 1 &#x3D; 2^bh(x)-1。即节点x所包含的节点至少为 2bh(x)-1。<br>  因此，原命题成立。</p><p>  由(01)、(02)得出，”高度为h的红黑树，它的包含的内节点个数至少为 2^bh(x)-1个”。<br>  因此，“一棵含有n个节点的红黑树的高度至多为2log(n+1)”。</p></blockquote><h2 id="红黑树的基本操作"><a href="#红黑树的基本操作" class="headerlink" title="红黑树的基本操作"></a>红黑树的基本操作</h2><p>红黑树的基本操作是添加、删除。对红黑树进行添加或删除之后，都会用到旋转方法。</p><blockquote><p>红黑树为什么需要旋转呢？</p><p>因为添加或删除节点后，红黑树的规则有可能被打破，可能不满足红黑树的5条性质，也就不再是一棵红黑树。这时候就需要做出一些调整，通过旋转使这棵树重新成为红黑树，从而继续维持红黑树的特性。</p><p>红黑树的调整方法有两种，分别是<strong>变色</strong>和<strong>旋转</strong>，而选择又包含<strong>左旋</strong>和<strong>右旋</strong></p></blockquote><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p><img src="/../../assets/blogImg/DSA/DataStructures/rbtree-rotate-left.png" alt="rbtree-rotate-left"></p><p>对X节点进行左旋，意味着“将X变成一个左节点”。</p><p>结合《算法导论》左旋的伪代码，根据上面的示意图，理解红黑树T节点x进行左旋是如何进行的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LEFT-ROTATE(T, x)</span><br><span class="line">y ← right[x]// 前提：假设x的右孩子为 y。</span><br><span class="line">ritht[x] ← left[y]// 将 “y 的左孩子”设为 “x 的右孩子”，即将β设为 x 的右孩子</span><br><span class="line">p[left[y]] ← x// 将“x” 设为 “y的左孩子的父亲”，即将 β的父亲设为 x</span><br><span class="line">p[y] ← p[x]// 将“x的父亲” 设为 “y的父亲”</span><br><span class="line">if p[x] = nil[T]</span><br><span class="line">then root[T] ← y// 情况1：如果“x的父亲”是空节点，则将 y 设为根节点</span><br><span class="line">else if x = left[p[x]]</span><br><span class="line">then left[p[x]] ← y// 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span><br><span class="line">else right[p[x]] ← y// 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子”</span><br><span class="line">left[y] ← x// 将“x” 设为“y的左孩子”</span><br><span class="line">p[x] ← y// 将“x的父节点”设为 “y”</span><br></pre></td></tr></table></figure><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p><img src="/../../assets/blogImg/DSA/DataStructures/rbtree-rotate-right.png" alt="rbtree-rotate-right"></p><p>如图，对 Y 进行右旋，意味着“将x变成一个右节点”。</p><p>结合《算法导论》的伪代码和上面的示意图来理解红黑树T节点y进行右旋是如何进行的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RIGHT-ROTATE(T, y)</span><br><span class="line">x ← left[y]// 前提：这里假设y的左孩子为x。</span><br><span class="line">left[y] ← right[x]// 将 “x的右孩子”设为“y的左孩子”，即将β设为y的左孩子</span><br><span class="line">p[right[x]] ← y// 将“y” 设为“x的右孩子到的父亲”，即将β的父亲设为y</span><br><span class="line">p[x] ← p[y]</span><br><span class="line">if p[y] = nil[T]</span><br><span class="line">then root[T] ← x// 情况1：如果“y 的父亲” 是空节点，则将x设为根节点</span><br><span class="line">else if y = right[p[y]]</span><br><span class="line">then right[p[y]] ← x// 情况2：如果 y 是它父节点的右孩子，则将x 设为“y的父亲节点的左孩子”</span><br><span class="line">else left[p[y]] ← x// 情况3：（y是它节点的左孩子）将x设为“y的父节点的左孩子”</span><br><span class="line">right[x] ← y// 将“y”设为“x的右孩子”</span><br><span class="line">p[y] ← x// 将“y 的父节点”设为“x”</span><br></pre></td></tr></table></figure><p><strong>旋转总结</strong></p><ol><li><p>左旋 和 右旋 是相对的两个概念，原理类似。理解一个也就理解了另一个。</p></li><li><p>下面谈谈如何区分 左旋 和 右旋。</p></li></ol><p>   在实际应用中，若没有彻底理解 左旋 和 右旋， 可能会将他们混淆。下面谈谈我对如何区分 左旋 和 右旋的理解。</p><h3 id="区分-左旋-和-右旋"><a href="#区分-左旋-和-右旋" class="headerlink" title="区分 左旋 和 右旋"></a>区分 左旋 和 右旋</h3><p>仔细观察上面“左旋” 和 “右旋” 的示意图。我们能够清晰的发现，它们是对称的。无论是左旋还是右旋，被旋转的树，再选择前是二叉查找树，并且旋转之后任然是一棵二叉查找树</p><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-16.jpg" alt="tree-16"></p><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>将一个节点插入到红黑树中，需要哪些步骤呢？首先，将红黑树当作一棵二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一棵红黑树。详细描述如下：</p><ol><li><p><strong>step1：将红黑树当作一棵二叉查找树，将节点插入。</strong></p><p>红黑树本身就是一棵二叉查找树，将节点插入后，该树仍然是一棵二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后，他一定还是二叉查找树。这也就意味着，任何的选择和重新着色操作，都不会改变它仍然是一棵二叉查找树的事实。</p></li><li><p><strong>step2：将插入的节点着色为”红色“</strong> </p><p>为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：</p><blockquote><p>1.每个节点或者是黑色，或者是红色。</p><p>2.根节点是黑色。</p><p>3.每个叶子节点是黑色。</p><p>4.如果一个节点是红色的，则它的子节点必须是黑色的。</p><p>5.从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p></blockquote><p>将插入的节点着色为红色，不会违反 <strong>特性5</strong>！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一棵红黑树了。</p></li><li><p><strong>step3通过一系列的旋转或者变色等操作，使之重新成为一棵红黑树。</strong></p><p>第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？<br><strong>对于”特性(1)”</strong>，显然不会违背了。因为我们已经将它涂成红色了。<br><strong>对于”特性(2)”</strong>，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。<br><strong>对于”特性(3)”</strong>，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。<br><strong>对于”特性(4)”</strong>，是有可能违背的！<br>那接下来，想办法使之”满足特性(4)”，就可以将树重新构造成红黑树了。<br>添加操作的伪代码《算法导论》</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT(T, z)</span><br><span class="line">y ← nil[T]// 新建节点&quot;y&quot;,将y 设为空节点</span><br><span class="line">x ← root[T]// 设“红黑树T”的根节点为“X”</span><br><span class="line">while x ≠ nil[T]// 找出要插入的节点“z”在二叉树T中的位置“y”</span><br><span class="line">do y ← x</span><br><span class="line">if key[z] &lt; key[x]</span><br><span class="line">then x ← left[x]</span><br><span class="line">else x ← right[x]</span><br><span class="line">p[z] ← y// 设置“z的父亲”为“y”</span><br><span class="line">if y = nil[T]</span><br><span class="line">then root[T] ← z// 情况1：若y是空节点，则将z设为根</span><br><span class="line">else if key[z] &lt; key[y]</span><br><span class="line">then left[y] ← z// 情况2：若“z所包含的值” &lt; &quot;y所包含的值&quot;，则将z设为“y的左孩子”</span><br><span class="line">else right[y] ← z// 情况3：（“z所包含的值” &gt;= &quot;y所包含的值&quot;）将z设为“y的右孩子”</span><br><span class="line">left[z] ← nil[T]// z的左孩子设为空</span><br><span class="line">right[z] ← nil[T]// z的右孩子设为空。至此，已经完成将“节点z插入到二叉树”中了</span><br><span class="line">color[z] ← RED// 将z着色为“红色”</span><br><span class="line">RB-INSERT-FIXUP(T, z)// 通过RB-INSERT-FIXUP对红黑树的节点进行颜色修改以及旋转，让树T仍然是一颗红黑树</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>RB-INSERT-FIXUP 修正操作伪代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T,z)</span><br><span class="line">while color[p[z]] == RED// 若“当前节点（z）的父节点是红色”，则进行以下处理</span><br><span class="line">do if p[z] = left[p[p[z]]]// 若“z的父节点”是“z的祖父节点的左孩子”，则进行以下处理。</span><br><span class="line">then y ← right[p[p[z]]]// 将y设置为“z的叔叔节点（z的祖父节点的右孩子）”</span><br><span class="line">if color[y] = RED// Case 1条件：叔叔是红色</span><br><span class="line">then color[p[z]] ← BLACK▹ Case 1   //  (01) 将“父节点”设为黑色。</span><br><span class="line">color[y] ← BLACK▹ Case 1   //  (02) 将“叔叔节点”设为黑色。</span><br><span class="line">color[p[p[z]]] ← RED▹ Case 1   //  (03) 将“祖父节点”设为“红色”。</span><br><span class="line">z ← p[p[z]]▹ Case 1   //  (04) 将“祖父节点”设为“当前节点”(红色节点)</span><br><span class="line">else if z = right[p[z]]   // Case 2条件：叔叔是黑色，且当前节点是右孩子</span><br><span class="line">then z ← p[z]▹ Case 2   //  (01) 将“父节点”作为“新的当前节点”。</span><br><span class="line">LEFT-ROTATE(T,z)▹ Case 2   //  (02) 以“新的当前节点”为支点进行左旋。</span><br><span class="line">color[p[z]] ← BLACK▹ Case 3   // Case 3条件：叔叔是黑色，且当前节点是左孩子。(01) 将“父节点”设为“黑色”。</span><br><span class="line">color[p[p[z]]] ← RED▹ Case 3   //  (02) 将“祖父节点”设为“红色”。</span><br><span class="line">RIGHT-ROTATE(T, p[p[z]])▹ Case 3   //  (03) 以“祖父节点”为支点进行右旋。</span><br><span class="line">else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged)// 若“z的父节点”是“z的祖父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。</span><br><span class="line">color[root[T]] ← BLACK</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据被插入节点的父节点的情况，可以将”当节点z被着色为红色节点，并插入二叉树”划分为三种情况来处理。<br>① 情况说明：被插入的节点是根节点。<br>  处理方法：直接把此节点涂为黑色。<br>② 情况说明：被插入的节点的父节点是黑色。<br>  处理方法：什么也不需要做。节点被插入后，仍然是红黑树。<br>③ 情况说明：被插入的节点的父节点是红色。<br>  处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据”叔叔节点的情况”，将这种情况进一步划分为3种情况(Case)。</p><table><thead><tr><th></th><th><strong>现象说明</strong></th><th><strong>处理策略</strong></th></tr></thead><tbody><tr><td>Case 1</td><td>当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</td><td>(01) 将“父节点”设为黑色。 (02) 将“叔叔节点”设为黑色。 (03) 将“祖父节点”设为“红色”。 (04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</td></tr><tr><td>Case 2</td><td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</td><td>(01) 将“父节点”作为“新的当前节点”。 (02) 以“新的当前节点”为支点进行左旋。</td></tr><tr><td>Case 3</td><td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</td><td>(01) 将“父节点”设为“黑色”。 (02) 将“祖父节点”设为“红色”。 (03) 以“祖父节点”为支点进行右旋。</td></tr></tbody></table><p>上面三种情况(Case)处理问题的核心思路都是：将红色的节点移到根节点；然后，将根节点设为黑色。下面对它们详细进行介绍。</p></li></ol><h4 id="Case-分析"><a href="#Case-分析" class="headerlink" title="Case 分析"></a>Case 分析</h4><h5 id="case1叔叔节点是红色"><a href="#case1叔叔节点是红色" class="headerlink" title="case1叔叔节点是红色"></a>case1叔叔节点是红色</h5><p><strong>现象说明</strong>：当前节点（即，被插入节点）的父节点是红色，且当前节点的祖父节点的另一个节点（叔叔节点）也是红色。</p><p><strong>处理策略</strong></p><ol><li>将“父节点” 设为黑色。</li><li>将”叔叔节点“设为黑色。</li><li>将“祖父节点”设为红色。</li><li>将“祖父节点”设为“当前节点”（红色节点）；即，之后继续对“当前节点”进行操作。</li></ol><p><strong>为什么要这样处理？</strong></p><blockquote><p>“当前节点” 和 “父节点”都是红色，违背“特性4”。所以，将“父节点” 设置 黑色以解决这个问题。</p><p>但是，将“父节点” 由 “红色” 变成 “黑色” 之后，违背了 “特性5”： 因为，包含 “父节点” 的分支的黑色节点的总是增加了1。 解决这个问题的办法是：将“祖父节点” 由 黑色 变成红色，同时，将 ”叔叔节点“  由 红色 变成 黑色。关于这里，说明几点：</p><p>1.为什么“祖父节点” 之前是黑色？ 因为在变换操作之前，该树是红黑树，“父节点”是红色，那么“祖父节点”一定是黑色。</p><p>2.为什么将“祖父节点” 由黑色变成红色，同时，将叔叔节点 由 红色变成黑色；能解决“包含‘父节点’的分支的黑色节点的总是增加了1”的问题。这个道理也很简单。“包含‘父节点’的分支的黑色节点的总数增加了1” 同时也意味着 “包含‘祖父节点’的分支的黑色节点的总数增加了1”，既然这样，我们通过将“祖父节点”由“黑色”变成“红色”以解决“包含‘祖父节点’的分支的黑色节点的总数增加了1”的问题； 但是，这样处理之后又会引起另一个问题“包含‘叔叔’节点的分支的黑色节点的总数减少了1”，现在我们已知“叔叔节点”是“红色”，将“叔叔节点”设为“黑色”就能解决这个问题。 所以，将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；就解决了该问题。</p><p>按照上面的步骤处理之后：当前节点、父节点、叔叔节点之间都不会违背红黑树特性，但祖父节点却不一定。若此时，祖父节点是根节点，直接将祖父节点设为“黑色”，那就完全解决这个问题了；若祖父节点不是根节点，那我们需要将“祖父节点”设为“新的当前节点”，接着对“新的当前节点”进行分析。</p></blockquote><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-17.jpg" alt="tree-17"></p><h5 id="Case-2叔叔是黑色，且当前节点是右孩子"><a href="#Case-2叔叔是黑色，且当前节点是右孩子" class="headerlink" title="Case 2叔叔是黑色，且当前节点是右孩子"></a>Case 2叔叔是黑色，且当前节点是右孩子</h5><p><strong>现象说明：</strong> 当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</p><p><strong>处理策略</strong></p><ol><li>将“父节点”作为“新的当前节点”。</li><li>以“新的当前节点”为支点进行左旋。</li></ol><blockquote><p>首先，将“父节点”作为“新的当前节点”；接着，以“新的当前节点”为支点进行左旋。 为了便于理解，我们先说明第(02)步，再说明第(01)步；为了便于说明，我们设置“父节点”的代号为F(Father)，“当前节点”的代号为S(Son)。<br>为什么要“以F为支点进行左旋”呢？根据已知条件可知：S是F的右孩子。而之前我们说过，我们处理红黑树的核心思想：将红色的节点移到根节点；然后，将根节点设为黑色。既然是“将红色的节点移到根节点”，那就是说要不断的将破坏红黑树特性的红色节点上移(即向根方向移动)。 而S又是一个右孩子，因此，我们可以通过“左旋”来将S上移！<br>   按照上面的步骤(以F为支点进行左旋)处理之后：若S变成了根节点，那么直接将其设为“黑色”，就完全解决问题了；若S不是根节点，那我们需要执行步骤(01)，即“将F设为‘新的当前节点’”。那为什么不继续以S为新的当前节点继续处理，而需要以F为新的当前节点来进行处理呢？这是因为“左旋”之后，F变成了S的“子节点”，即S变成了F的父节点；而我们处理问题的时候，需要从下至上(由叶到根)方向进行处理；也就是说，必须先解决“孩子”的问题，再解决“父亲”的问题；所以，我们执行步骤(01)：将“父节点”作为“新的当前节点”。</p></blockquote><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-18.jpg" alt="tree-18"></p><h5 id="Case-3叔叔是黑色，且当前节点是左孩子"><a href="#Case-3叔叔是黑色，且当前节点是左孩子" class="headerlink" title="Case 3叔叔是黑色，且当前节点是左孩子"></a>Case 3叔叔是黑色，且当前节点是左孩子</h5><p><strong>现象说明：</strong> 当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</p><p><strong>处理策略</strong></p><ol><li>将“父节点”设为“黑色”。</li><li>将“祖父节点”设为“红色”。</li><li>以“祖父节点”为支点进行右旋。</li></ol><blockquote><p>为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“叔叔节点”为U(Uncle)，“父节点”为F(Father)，祖父节点为G(Grand-Father)。<br>   S和F都是红色，违背了红黑树的“特性(4)”，我们可以将F由“红色”变为“黑色”，就解决了“违背‘特性(4)’”的问题；但却引起了其它问题：违背特性(5)，因为将F由红色改为黑色之后，所有经过F的分支的黑色节点的个数增加了1。那我们如何解决“所有经过F的分支的黑色节点的个数增加了1”的问题呢？ 我们可以通过“将G由黑色变成红色”，同时“以G为支点进行右旋”来解决。</p></blockquote><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-19.jpg" alt="tree-19"></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：</p><ol><li><p>将红黑树当作一棵二叉查找树，将节点删除。</p><p>删除分3中情况</p><p> ① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。<br> ② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。<br> ③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了，下面就考虑后继节点。 在”被删除节点”有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然”的后继节点”不可能双子都非空，就意味着”该节点的后继节点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况① “进行处理；若只有一个儿子，则按”情况② “进行处理。</p></li><li><p>通过“旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</p><p>因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p></li></ol><p>删除操作的伪代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE(T, z)</span><br><span class="line">if left[z] = nil[T] or right[z] = nil[T]</span><br><span class="line">then y ← z // 若“z的左孩子” 或 “z的右孩子”为空，则将“z”赋值给“y”</span><br><span class="line">else y ← TREE-SUCCESSOR(z)// 否则，将“z的后继节点”赋值给“y”</span><br><span class="line">if left[y] ≠ nil[T]</span><br><span class="line">then x ← left[y]// 若“y的左孩子”不为空，则将“y的左孩子”赋值给“x&quot;</span><br><span class="line">else x ← right[y]// 否则，将”y的右孩子“赋值给”x&quot;</span><br><span class="line">p[x] ← p[y]// 将“y的父节点”设置为“x的父节点”</span><br><span class="line">if p[y] = nil[T]</span><br><span class="line">then root[T] ← x// 情况1：若“y的父节点”为空，则设置“x&quot;为根节点</span><br><span class="line">else if y = left[p[y]]</span><br><span class="line">then = left[p[y]] ← x// 情况2：若”y是它父节点的左孩子“，则设置x为y的父节点的左孩子</span><br><span class="line">else right[p[y]] ← x// 情况3：若y是它父节点的右孩子，则设置x为y的父节点的右孩子</span><br><span class="line">if y ≠ z</span><br><span class="line">then key[z] ← key[y]// 若y的值，赋值给z。注意：这里只拷贝z的值给y,而没有拷贝z的颜色！</span><br><span class="line">copy y&#x27;s satellite data into z</span><br><span class="line">if color[y] = BLACK</span><br><span class="line">then RB-DELETE-FIXUP(T, x)// 若y为黑色节点，则调用修正树的代码</span><br><span class="line">return y</span><br></pre></td></tr></table></figure><p>RB-DELETE-FIXUP 的伪代码说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE-FIXUP(T, x)</span><br><span class="line"> while x ≠ root[T] and color[x] = BLACK  </span><br><span class="line">     do if x = left[p[x]]      </span><br><span class="line">           then w ← right[p[x]]                                         // 若 “x”是“它父节点的左孩子”，则设置 “w”为“x的兄弟节点”(即x为它父节点的右孩子)                                          </span><br><span class="line">                if color[w] = RED                                       // Case 1: x是“黑+红”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</span><br><span class="line">                   then color[w] ← BLACK                     ▹  Case 1  // (01) 将x的兄弟节点设为“黑色”。</span><br><span class="line">                        color[p[x]] ← RED                    ▹  Case 1  // (02) 将x的父节点设为“红色”。</span><br><span class="line">                        LEFT-ROTATE(T, p[x])                 ▹  Case 1  // (03) 对x的父节点进行左旋。</span><br><span class="line">                        w ← right[p[x]]                      ▹  Case 1  // (04) 左旋后，重新设置x的兄弟节点。</span><br><span class="line">                if color[left[w]] = BLACK and color[right[w]] = BLACK   // Case 2: x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</span><br><span class="line">                   then color[w] ← RED                       ▹  Case 2  // (01) 将x的兄弟节点设为“红色”。</span><br><span class="line">                        x ←  p[x]                            ▹  Case 2  // (02) 设置“x的父节点”为“新的x节点”。</span><br><span class="line">                   else if color[right[w]] = BLACK                     // Case 3: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</span><br><span class="line">                           then color[left[w]] ← BLACK    ▹  Case 3   //(01) 将x兄弟节点的左孩子设为“黑色”。</span><br><span class="line">                                color[w] ← RED              ▹  Case 3   // (02) 将x兄弟节点设为“红色”。</span><br><span class="line">                                RIGHT-ROTATE(T, w)          ▹  Case 3   // (03) 对x的兄弟节点进行右旋。</span><br><span class="line">                                w ← right[p[x]]             ▹  Case 3   //  (04) 右旋后，重新设置x的兄弟节点。</span><br><span class="line">                         color[w] ← color[p[x]]             ▹  Case 4   // Case 4: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的。(01) 将x父节点颜色 赋值给 x的兄弟节点。</span><br><span class="line">                         color[p[x]] ← BLACK                ▹  Case 4   // (02) 将x父节点设为“黑色”。</span><br><span class="line">                         color[right[w]] ← BLACK            ▹  Case 4   //(03) 将x兄弟节点的右子节设为“黑色”。</span><br><span class="line">                         LEFT-ROTATE(T, p[x])               ▹  Case 4   //(04) 对x的父节点进行左旋。</span><br><span class="line">                         x ← root[T]                        ▹  Case 4   //(05) 设置“x”为“根节点”。</span><br><span class="line">        else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged)    // 若 “x”是“它父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。</span><br><span class="line"> color[x] ← BLACK   </span><br></pre></td></tr></table></figure><p>前面我们将”删除红黑树中的节点”大致分为两步，在第一步中”将红黑树当作一颗二叉查找树，将节点删除”后，可能违反”特性(2)、(4)、(5)”三个特性。第二步需要解决上面的三个问题，进而保持红黑树的全部特性。<br>   为了便于分析，我们假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。为什么呢？<br>   通过RB-DELETE算法，我们知道：删除节点y之后，x占据了原来节点y的位置。 既然删除y(y是黑色)，意味着减少一个黑色节点；那么，再在该位置上增加一个黑色即可。这样，当我们假设”x包含一个额外的黑色”，就正好弥补了”删除y所丢失的黑色节点”，也就不会违反”特性(5)”。 因此，假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。<br>   现在，x不仅包含它原本的颜色属性，x还包含一个额外的黑色。即x的颜色属性是”红+黑”或”黑+黑”，它违反了”特性(1)”。</p><p>   现在，我们面临的问题，由解决”违反了特性(2)、(4)、(5)三个特性”转换成了”解决违反特性(1)、(2)、(4)三个特性”。RB-DELETE-FIXUP需要做的就是通过算法恢复红黑树的特性(1)、(2)、(4)。RB-DELETE-FIXUP的思想是：将x所包含的额外的黑色不断沿树上移(向根方向移动)，直到出现下面的姿态：<br>a) x指向一个”红+黑”节点。此时，将x设为一个”黑”节点即可。<br>b) x指向根。此时，将x设为一个”黑”节点即可。<br>c) 非前面两种姿态。</p><p>将上面的姿态，可以概括为3种情况。<br>① 情况说明：x是“红+黑”节点。<br>  处理方法：直接把x设为黑色，结束。此时红黑树性质全部恢复。<br>② 情况说明：x是“黑+黑”节点，且x是根。<br>  处理方法：什么都不做，结束。此时红黑树性质全部恢复。<br>③ 情况说明：x是“黑+黑”节点，且x不是根。<br>  处理方法：这种情况又可以划分为4种子情况。这4种子情况如下表所示：</p><table><thead><tr><th></th><th><strong>现象说明</strong></th><th><strong>处理策略</strong></th></tr></thead><tbody><tr><td><strong>Case 1</strong></td><td>x是”黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</td><td>(01) 将x的兄弟节点设为“黑色”。 (02) 将x的父节点设为“红色”。 (03) 对x的父节点进行左旋。 (04) 左旋后，重新设置x的兄弟节点。</td></tr><tr><td><strong>Case 2</strong></td><td>x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</td><td>(01) 将x的兄弟节点设为“红色”。 (02) 设置“x的父节点”为“新的x节点”。</td></tr><tr><td><strong>Case 3</strong></td><td>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</td><td>(01) 将x兄弟节点的左孩子设为“黑色”。 (02) 将x兄弟节点设为“红色”。 (03) 对x的兄弟节点进行右旋。 (04) 右旋后，重新设置x的兄弟节点。</td></tr><tr><td><strong>Case 4</strong></td><td>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</td><td>(01) 将x父节点颜色 赋值给 x的兄弟节点。 (02) 将x父节点设为“黑色”。 (03) 将x兄弟节点的右子节设为“黑色”。 (04) 对x的父节点进行左旋。 (05) 设置“x”为“根节点”。</td></tr></tbody></table><h4 id="Case-分析-1"><a href="#Case-分析-1" class="headerlink" title="Case 分析"></a>Case 分析</h4><h5 id="Case1-是”黑-黑”节点，x的兄弟节点是红色"><a href="#Case1-是”黑-黑”节点，x的兄弟节点是红色" class="headerlink" title="Case1 是”黑+黑”节点，x的兄弟节点是红色"></a>Case1 是”黑+黑”节点，x的兄弟节点是红色</h5><p><strong>现象说明</strong></p><p>x是”黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</p><p><strong>处理策略</strong></p><ol><li>将x的兄弟节点设为“黑色”。</li><li>将x的父节点设为“红色”。</li><li>对x的父节点进行左旋。</li><li>左旋后，重新设置x的兄弟节点。</li></ol><p>这样做的目的是将“Case 1”转换为“Case 2”、“Case 3”或“Case 4”，从而进行进一步的处理。对x的父节点进行左旋；左旋后，为了保持红黑树特性，就需要在左旋前“将x的兄弟节点设为黑色”，同时“将x的父节点设为红色”；左旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p><p><img src="/../../assets/blogImg/DSA/DataStructures/rbtree-delete-case1.jpg" alt="rbtree-delete-case1"></p><h5 id="Case2-x是”黑-黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色"><a href="#Case2-x是”黑-黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色" class="headerlink" title="Case2 x是”黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色"></a>Case2 x是”黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色</h5><p><strong>现象说明</strong></p><p>x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</p><p><strong>处理策略</strong></p><ol><li>将x的兄弟节点设为“红色”。</li><li>设置“x的父节点”为“新的x节点”。</li></ol><p>这个情况的处理思想：是将“x中多余的一个黑色属性上移(往根方向移动)”。 x是“黑+黑”节点，我们将x由“黑+黑”节点 变成 “黑”节点，多余的一个“黑”属性移到x的父节点中，即x的父节点多出了一个黑属性(若x的父节点原先是“黑”，则此时变成了“黑+黑”；若x的父节点原先时“红”，则此时变成了“红+黑”)。 此时，需要注意的是：所有经过x的分支中黑节点个数没变化；但是，所有经过x的兄弟节点的分支中黑色节点的个数增加了1(因为x的父节点多了一个黑色属性)！为了解决这个问题，我们需要将“所有经过x的兄弟节点的分支中黑色节点的个数减1”即可，那么就可以通过“将x的兄弟节点由黑色变成红色”来实现。<br>   经过上面的步骤(将x的兄弟节点设为红色)，多余的一个颜色属性(黑色)已经跑到x的父节点中。我们需要将x的父节点设为“新的x节点”进行处理。若“新的x节点”是“黑+红”，直接将“新的x节点”设为黑色，即可完全解决该问题；若“新的x节点”是“黑+黑”，则需要对“新的x节点”进行进一步处理。</p><p><img src="/../../assets/blogImg/DSA/DataStructures/rbtree-delete-case2.jpg" alt="rbtree-delete-case2"></p><h5 id="Case3-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的"><a href="#Case3-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的" class="headerlink" title="Case3 x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的"></a>Case3 x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的</h5><p><strong>现象说明</strong></p><p>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</p><p><strong>处理策略</strong></p><ol><li>将x兄弟节点的左孩子设为“黑色”。</li><li>将x兄弟节点设为“红色”。</li><li>对x的兄弟节点进行右旋。</li><li>右旋后，重新设置x的兄弟节点。</li></ol><p>我们处理“Case 3”的目的是为了将“Case 3”进行转换，转换成“Case 4”,从而进行进一步的处理。转换的方式是对x的兄弟节点进行右旋；为了保证右旋后，它仍然是红黑树，就需要在右旋前“将x的兄弟节点的左孩子设为黑色”，同时“将x的兄弟节点设为红色”；右旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p><p><img src="/../../assets/blogImg/DSA/DataStructures/rbtree-delete-case3.jpg" alt="rbtree-delete-case3"></p><h5 id="Case4-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色"><a href="#Case4-x是“黑-黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色" class="headerlink" title="Case4 x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色"></a>Case4 x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色</h5><p><strong>现象说明</strong></p><p>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</p><p><strong>处理策略</strong></p><ol><li>将x父节点颜色 赋值给 x的兄弟节点。</li><li>将x父节点设为“黑色”。</li><li>将x兄弟节点的右子节设为“黑色”。</li><li>对x的父节点进行左旋。</li><li>设置“x”为“根节点”。</li></ol><p>我们处理“Case 4”的目的是：去掉x中额外的黑色，将x变成单独的黑色。处理的方式是“：进行颜色修改，然后对x的父节点进行左旋。下面，我们来分析是如何实现的。<br>   为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“兄弟节点的左孩子”为BLS(Brother’s Left Son)，“兄弟节点的右孩子”为BRS(Brother’s Right Son)，“父节点”为F(Father)。<br>   我们要对F进行左旋。但在左旋前，我们需要调换F和B的颜色，并设置BRS为黑色。为什么需要这里处理呢？因为左旋后，F和BLS是父子关系，而我们已知BL是红色，如果F是红色，则违背了“特性(4)”；为了解决这一问题，我们将“F设置为黑色”。 但是，F设置为黑色之后，为了保证满足“特性(5)”，即为了保证左旋之后：<br>   第一，“同时经过根节点和S的分支的黑色节点个数不变”。<br>       若满足“第一”，只需要S丢弃它多余的颜色即可。因为S的颜色是“黑+黑”，而左旋后“同时经过根节点和S的分支的黑色节点个数”增加了1；现在，只需将S由“黑+黑”变成单独的“黑”节点，即可满足“第一”。<br>   第二，“同时经过根节点和BLS的分支的黑色节点数不变”。<br>       若满足“第二”，只需要将“F的原始颜色”赋值给B即可。之前，我们已经将“F设置为黑色”(即，将B的颜色”黑色”，赋值给了F)。至此，我们算是调换了F和B的颜色。<br>   第三，“同时经过根节点和BRS的分支的黑色节点数不变”。<br>       在“第二”已经满足的情况下，若要满足“第三”，只需要将BRS设置为“黑色”即可。<br>经过，上面的处理之后。红黑树的特性全部得到的满足！接着，我们将x设为根节点，就可以跳出while循环(参考伪代码)；即完成了全部处理。</p><p>至此，我们就完成了Case 4的处理。理解Case 4的核心，是了解如何“去掉当前节点额外的黑色”。</p><p><img src="/../../assets/blogImg/DSA/DataStructures/rbtree-delete-case4.jpg" alt="rbtree-delete-case4"></p><p>资料来源：</p><p><a href="https://zhuanlan.zhihu.com/p/139907457?utm_source=com.tencent.tim">https://zhuanlan.zhihu.com/p/139907457?utm_source=com.tencent.tim</a></p><p><a href="https://www.cnblogs.com/skywang12345/p/3245399.html">https://www.cnblogs.com/skywang12345/p/3245399.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;R-B Tree&lt;/strong&gt;，全称 Red-Black Tree，又称为红黑树，他是一种&lt;strong&gt;自平衡&lt;/strong&gt;的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红（Red）或黑（Black）。除了符合二叉查找树的基本特征外，还具备下来附属特征。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Data Structures and Algorithms" scheme="http://cxinxian.github.io/tags/Data-Structures-and-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://cxinxian.github.io/2021/12/04/Data-Structures-and-Algorithms/DS/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://cxinxian.github.io/2021/12/04/Data-Structures-and-Algorithms/DS/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-12-04T14:37:12.000Z</published>
    <updated>2025-02-21T12:43:32.462Z</updated>
    
    <content type="html"><![CDATA[<p><strong>树的定义</strong></p><p>树是一种数据结构，它是由 n（$n\geq 0$）个有限节点组成一个具有层次关系的集合。当n&#x3D;0时，称为空树。之所以叫做树是因为他看起来像一棵倒挂的树，根朝上，叶朝下的树。在任意非空树中具有以下特点：</p><span id="more"></span><ul><li>每个节点有零个或多个子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树。</li></ul><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-01.png" alt="tree-01"></p><hr><p><strong>树的基本术语</strong></p><p>若一个节点有子树，那么该节点称为子树根的“双亲”，子树的根是该节点的“孩子”。有相同双亲的节点互为“兄弟”。一个节点的所有子树上的任何节点都是该节点的后裔。从根节点到某个节点的路径上的所有节点都是该节点的祖先</p><p><strong>节点的度</strong>：节点拥有的子树的数目，图中节点C的度为2。</p><p><strong>叶子</strong>：度为零的节点，图中D、E、F都是叶子几点。</p><p><strong>树的度</strong>：树中节点的最大的度，图中节点C 的度最大为2，因此树的度为2。</p><p><strong>层次</strong>：根节点的层次为1，其余节点的层次等于该节点的双亲节点的层次加1。</p><p><strong>树的高度</strong>：树中节点的最大层次，图中树的高度为3。</p><p><strong>无序树</strong>：如果树中节点的各子树之间的次序是不重要的，可以交换位置。</p><p><strong>有序树</strong>：如果树中节点的各子树之间的次序是重要的，不可以交换位置。</p><p><strong>森林</strong>：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。</p><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树是每个节点最多有两个子树的树结构。他有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。</p><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-02.png" alt="tree-02"></p><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p><strong>性质1</strong>：二叉树第i层上的节点数目最多为 2<sup>{$i-1$}</sup>($i \geq 1$)</p><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-03.png" alt="tree-03"></p><p><strong>性质2</strong>：深度为K 的二叉树至多有 $2^{k}-1$ 个节点（$k\geq1$）</p><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-04.png" alt="tree-04"></p><p><strong>性质3</strong>：包含n个节点的二叉树的高度至少为 $\log_2(n+1)$。</p><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-05.png" alt="image-20211202174622040"></p><p><strong>性质4</strong>：二叉树中，设叶子节点数为 <strong>n<sub>0</sub></strong>，度为2 的节点数为 <strong>n<sub>2</sub></strong>，则 $n_0&#x3D;n_2+1$。</p><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-06.png" alt="tree-06"></p><hr><h2 id="不同形态二叉树"><a href="#不同形态二叉树" class="headerlink" title="不同形态二叉树"></a>不同形态二叉树</h2><p><strong>满二叉树</strong></p><p>定义：高度为 h， 并且由 <strong>$2^h-1$</strong> 个节点的二叉树，被称为满二叉树，满二叉树的结点要么为0（叶子节点），要么为2（非叶子节点）</p><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-07.png" alt="tree-07"></p><p><strong>完全二叉树</strong></p><p>定义：一棵二叉树中，只有最下面两层节点的度可以小于2，并且最下一层的叶子节点集中靠左的若干位置上。这样的二叉树成为完全二叉树</p><p>特点：叶子节点只能出现在最下层和次下层，且最下层的叶子节点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。</p><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-08.png" alt="tree-08"></p><h2 id="二叉树的物理存储结构"><a href="#二叉树的物理存储结构" class="headerlink" title="二叉树的物理存储结构"></a>二叉树的物理存储结构</h2><p>二叉树可以用以下两种物理存储结构来表达：</p><ol><li><strong>链式存储结构</strong></li><li><strong>数组</strong></li></ol><hr><p><strong>链式存储结构</strong></p><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-11.png" alt="tree-11"></p><p>二叉树每个节点得组成分为三个部分，：</p><ul><li>存储数据得data变量</li><li>指向左孩子得 left 指针</li><li>指向右孩子得 right 指针</li></ul><hr><p><strong>数组</strong></p><p>使用数组存储时，按照层级顺序把二叉树得节点放到数组中对应得位置上。如果某一节点得左孩子或右孩子空缺，则数组的相应位置也空出来。</p><blockquote><p>为什么这样设计呢？</p><p>因为这样设计可以更方便地在数组中定位二叉树的孩子节点和父节点。</p></blockquote><p>假设一个父节点的下标是parent，那么它的左孩子节点下标就是 $2\times parent+1$; 右孩子节点下标就是 $2 \times parent+2$。</p><p>假如节点4在数组中的下标是3，节点4是节点2的左孩子，节点2的下标可以直接通过计算得出。</p><p>节点2的下标 &#x3D; $(3-1)&#x2F;2 &#x3D; 1$</p><p>注意：对于一个稀疏的二叉树来说，用数组来表示是非常浪费空间的。</p><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-10.png" alt="tree-10"></p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>在计算机程序中，遍历本就是一个线性的操作。所以遍历同样具有线性结构的数组或链表，是一件轻而易举的事情。</p><p>二叉树是典型的非线性数据结构，遍历时需要把非线性关联的节点转化成一个线性队列，以不同的方式来遍历，遍历出的序列顺序也不同。</p><p>二叉树的遍历方式：</p><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li><li>层序遍历</li></ul><p>从宏观的角度来分，二叉树的遍历又可以分为两大类：</p><ol><li>深度优先遍历（前序遍历、中序遍历、后序遍历）</li><li>广度优先遍历（层序遍历）</li></ol><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p><strong>前序遍历</strong></p><p>二叉树的前序遍历，输出顺序的是根节点、左子树、右子树。</p><p><strong>中序遍历</strong></p><p>二叉树的中序遍历，输出顺序的是左子树、根节点、右子树。</p><p><strong>后序遍历</strong></p><p>二叉树的后序遍历，输出顺序的是左子树、右子树、根节点。</p><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p><strong>层序遍历</strong></p><p>二叉树的层序遍历就是按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在二叉树中：</p><ul><li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点。</li></ul><hr><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>定义：二叉查找树(Binary Search Tree)，又被成为二叉搜索树。其特点如下：设 x 为二叉查找树中的一个节点， x 节点包含关键字key，一句话就是左孩子比父节点小，右孩子比父节点大，还有一个特性就是中序遍历可以让节点有序。</p><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-09.png" alt="tree-09"></p><p>二叉搜索树可以方便的实现搜索算法。在搜索元素x的时候，我们可以将x和根节点比较:</p><ol><li><p>如果x等于根节点，那么找到x，停止搜索 (终止条件)</p></li><li><p>如果x小于根节点，那么搜索左子树</p></li><li><p>如果x大于根节点，那么搜索右子树</p></li></ol><p>二叉搜索树所需要进行的操作次数最多与树的深度相等。n个节点的二叉搜索树的深度最多为n，最少为log(n)。</p><p>二叉查找树的查询复杂度为：$Olog_2(n)$~$O(n)$</p><p><strong>二叉查找树的特性：</strong></p><ol><li>左子树上所有的节点的值均小于等于它的根节点的值。</li><li>右子树上所有节点的值均大于或等于它的根节点的值。</li><li>左右子树也分为二叉排序树</li></ol><p><strong>缺点</strong>：</p><ol><li>因为其特性，当依次插入降序或者升序的数据时，此时的二叉树出现不平衡的状况（如下图）。如果每一层只有一个节点，则树的状态更倾向于线性结构。节点的查询类似于数组的遍历，因此查询复杂度为 $O(n)$</li></ol><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-12.png" alt="tree-12"></p><h2 id="构造的复杂度"><a href="#构造的复杂度" class="headerlink" title="构造的复杂度"></a>构造的复杂度</h2><p>二叉搜索树的构造过程，就是将节点不断插入到树中适当位置的过程。该操作过程，与查询节点元素的操作基本相同，不同在于：</p><ul><li>查询节点过程：比较元素值是否相等，如果相等则返回，不相等则判断大小情况，迭代查询左、右子树，直到找到相等的元素，或子节点为空，返回节点不存在。</li><li>插入节点的过程是，比较元素值是否相等，相等则返回，表示已存在，不相等则判断大小，迭代查询左、右子树，直到找到相等的元素，或子节点为空，则将节点插入该空节点位置。</li></ul><p>由此可知，单个节点的构造复杂度和查询复杂度相同。</p><h2 id="删除复杂度"><a href="#删除复杂度" class="headerlink" title="删除复杂度"></a>删除复杂度</h2><p>二叉搜索树的节点删除包括两个过程，查找和删除。</p><p><strong>节点删除有以下三种情况</strong>：</p><ol><li>待删除节点为叶子节点；</li><li>待删除节点度为一；（即待删除节点有一个子节点）</li><li>待删除节点度为二；（待删除节点有两个子节点，待删除节点有子树）</li></ol><p>在第一种情况下，如下图，删除节点5时，会向下查找，此时节点5并没有子节点或者子树。删除后不影响树的结构特性，可以直接删除</p><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-13.png" alt="tree-13"></p><p>在第二种情况下，要删除节点4，而节点4存在一个子节点。因为需要维护二叉查找树的结构特征，需要将节点4的子节点8上移到删除的位置上。如下图</p><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-14.png" alt="tree-14"></p><p>情况三稍微复杂，删除的节点 2 既有左子树也有右子树，通常做法是，从待删除节点的右子树中查找最小的节点来补充删除节点的位置。</p><p><img src="/../../assets/blogImg/DSA/DataStructures/tree-15.png" alt="tree-15"></p><p>由以上三种情况可知：</p><ul><li>前两种情况下，删除节点后，“稳定结构”操作的复杂度都是常数级别，即整个的节点删除操作复杂度为 $Olog_2(n)$~$O(n)$</li><li>第三种情况下，设删除的节点为 <img src="https://math.jianshu.com/math?formula=p" alt="p">，“稳定结构”操作需要查找 <img src="https://math.jianshu.com/math?formula=p" alt="p"> 节点左子树中的最大值，也就是左子树中最“右”的叶子结点，即“稳定结构”操作其实也是一种内部的查询操作，所以整个的节点删除操作其实就是两个层次的查询操作，复杂度同为 $Olog_2(n)$~$O(n)$</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;树的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;树是一种数据结构，它是由 n（$n&#92;geq 0$）个有限节点组成一个具有层次关系的集合。当n&amp;#x3D;0时，称为空树。之所以叫做树是因为他看起来像一棵倒挂的树，根朝上，叶朝下的树。在任意非空树中具有以下特点：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Data Structures and Algorithms" scheme="http://cxinxian.github.io/tags/Data-Structures-and-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Glide 知识拓展</title>
    <link href="http://cxinxian.github.io/2021/12/03/code-analysis/Glide/Glide%20%E6%8B%93%E5%B1%95/"/>
    <id>http://cxinxian.github.io/2021/12/03/code-analysis/Glide/Glide%20%E6%8B%93%E5%B1%95/</id>
    <published>2021-12-03T13:09:17.000Z</published>
    <updated>2025-02-21T15:12:15.499Z</updated>
    
    <content type="html"><![CDATA[<p>知识拓展主要分为以下几个部分：</p><ul><li><strong>深入理解LinkedHashMap</strong></li><li><strong>LinkedHashMap 与 Lru(Least recently used，最近最少使用)算法</strong> </li><li><strong>Android LruCache</strong></li><li><strong>Glide LruCache</strong></li></ul><span id="more"></span><h2 id="一、深入理解LinkedHashMap"><a href="#一、深入理解LinkedHashMap" class="headerlink" title="一、深入理解LinkedHashMap"></a>一、深入理解LinkedHashMap</h2><p>在本章节理解LinkedHashMap 将分别按以下几点展开：</p><ul><li><strong>1.1、LinkedHashMap 概述</strong></li><li><strong>1.2、LinkedHashMap 在 JDK 中的定义</strong></li><li><strong>1.3、LinkedHashMap 的构造函数</strong></li><li><strong>1.4、LinkedHashMap 的数据解构</strong></li><li><strong>1.5、put和 get 操作</strong></li></ul><hr><h3 id="1-1、LinkedHashMap-概述"><a href="#1-1、LinkedHashMap-概述" class="headerlink" title="1.1、LinkedHashMap 概述"></a>1.1、LinkedHashMap 概述</h3><blockquote><p>HashMap 是 Java Collection Framework 的重要成员，也是Map 族（如下图）中我们最常用的一种。HashMap 是无序的，也就是说，迭代HashMap 所得到的元素顺序并不是它们最初放置到HashMap 的顺序。</p><p>HashMap 的这个缺点往往早晨诸多不便，因为在一些场景中，我们确实需要用到一个可以保持插入顺序的Map。庆幸的是，JDK 为我们解决了这一问题，提供了一个HashMap 的子类——LinkedHashMap。虽然 LinkedHashMap 增加了时间和空间上的开销，但是它通过维护一个额外的双向链表保证了迭代顺序。</p><p>​该迭代顺序可以是插入顺序，也可以是访问顺序。因此，根据链表中元素的顺序可以将 LinkedHashMap 分为： <strong>保持插入顺序LinkedHashMap</strong> 和 <strong>保持访问顺序的 LinkedHashMap</strong>，其中LinkedHashMap 的默认实现是按插入顺序排序的。</p></blockquote><p><img src="/../../assets/blogImg/code-analysis/Glide/glide-extend-01.png" alt="glide-extend-01"></p><p>Entry 的继承图如下</p><p><img src="/../../assets/blogImg/code-analysis/Glide/LinkedHashMap_Entry.png" alt="LinkedHashMap_Entry"></p><blockquote><p>本质上，HashMap 和双向两边合二为一即是LinkedHashMap。所谓LinkedHashMap，其落脚点在HashMap，因此更准确地说，它是一个将所有Entry节点链入一个双向链表的HashMap。</p><p>在LinkedHashMap 中，所有put进来的Entry 都保存在如下图所示的哈希表中，但由于它有额外定义了一个以 head 为头节点的双向链表（如下图所示），因此对于每次put进来Entry，除了将其保存到哈希表中对应得位置之上外，还会将其插入到双向链表得尾部。</p></blockquote><p><img src="/../../assets/blogImg/code-analysis/Glide/glide-extend-02.png"></p><p>更直观地，下图很好的还原了 LinkedHashMap 的原貌：HashMap 和双向链表的密切配合和分工合作早就了 LinkedHashMap。特别需要注意：next 用于维护 HashMap 各个桶中的Entry 链，before、after 用于维护 LinkedHashMap 的双向链表，虽然它们的作用对象都是 Entry，但是各自分离，是两码事。</p><p><img src="/../../assets/blogImg/code-analysis/Glide/glide-extend-03.png" alt="glide-extend-03"></p><p><img src="/../../assets/blogImg/code-analysis/Glide/LinkedHashMap_05.png" alt="LinkedHashMap_05"></p><p>HashMap 与 LinkedHashMap 的 Entry 结构示意图如下：</p><p><img src="/../../assets/blogImg/code-analysis/Glide/glide-extend-04.png" alt="glide-extend-04"></p><p>由于 LinkedHashMap 是 HashMap 的子类，所以 LinkedHashMap 自然会拥有 HashMap 的所有特性。比如：<span style="background-color:yellow">LinkedHahsMap 也最多只允许一条Entry的键为Null（多条会覆盖），但允许托条Entry的值为Null</span></p><p>LinkedHashMap 也是Map 的一个非同步的实现，此外，LinkedHashMap 还可以用来实现 **LRU（Least recently used, 最近最少使用）**算法。</p><hr><h3 id="1-2、LinkedHashMap-在-JDK-中的定义"><a href="#1-2、LinkedHashMap-在-JDK-中的定义" class="headerlink" title="1.2、LinkedHashMap 在 JDK 中的定义"></a>1.2、LinkedHashMap 在 JDK 中的定义</h3><h4 id="1-2-1、类结构定义"><a href="#1-2-1、类结构定义" class="headerlink" title="1.2.1、类结构定义"></a>1.2.1、类结构定义</h4><p>LinkedHashMap 继承于HashMap，其在JDK中的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2、成员变量定义"><a href="#1-2-2、成员变量定义" class="headerlink" title="1.2.2、成员变量定义"></a>1.2.2、成员变量定义</h4><p>与HashMap 相比，LinkedHashMap 增加了两个属性用于保证迭代顺序，分别是双向链表头结点header 和 标志位 accessOrder（值为true 时，表示按照访问顺序迭代；值为 false 时，表示按照插入顺序迭代）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head; <span class="comment">//双向链表表头元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail; <span class="comment">// 双向链表尾部元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> accessOrder;<span class="comment">//true表示按照访问顺序迭代；false表示按照插入顺序迭代</span></span><br></pre></td></tr></table></figure><h4 id="1-2-3、成员方法定义"><a href="#1-2-3、成员方法定义" class="headerlink" title="1.2.3、成员方法定义"></a>1.2.3、成员方法定义</h4><p>从下图可以看出，LinkedHashMap 中并没有增加额外的方法。也就是说，LinkedHashMap 与 HashMap 在操作上大致相同，只是在实现细节上略有不同。</p><p><img src="/../../assets/blogImg/code-analysis/Glide/LinkedHashMap_Outline.png" alt="LinkedHashMap_Outline"></p><h4 id="1-2-4、基本元素Entry"><a href="#1-2-4、基本元素Entry" class="headerlink" title="1.2.4、基本元素Entry"></a>1.2.4、基本元素Entry</h4><p>LinkedHashMap 采用的hash 算法和 HashMap相同，但是它重新定义了Entry。LinkedHashMap 中的Entry 增加了两个指针 before 和 after，它们分别用于维护双向链表。需要特别注意的是：next 用于维护HashMap 各个桶中Entry 的连接顺序，before、after 用于维护Entry 插入的先后顺序。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap与 LinkedHashMap 的Entry 结构示意图如下：</p><p><img src="/../../assets/blogImg/code-analysis/Glide/glide-extend-04.png" alt="glide-extend-04"></p><h3 id="1-3、LinkedHashMap-的构造函数"><a href="#1-3、LinkedHashMap-的构造函数" class="headerlink" title="1.3、LinkedHashMap 的构造函数"></a>1.3、LinkedHashMap 的构造函数</h3><h4 id="1-3-1、LinkedHashMap-int-initialCapacity-float-loadFactor-boolean-accessOrder"><a href="#1-3-1、LinkedHashMap-int-initialCapacity-float-loadFactor-boolean-accessOrder" class="headerlink" title="1.3.1、LinkedHashMap(int initialCapacity,float loadFactor, boolean accessOrder)"></a>1.3.1、LinkedHashMap(int initialCapacity,float loadFactor, boolean accessOrder)</h4><p>LinkedHashMap 一共提供了五个构造函数，它们都是在HashMap 的构造函数的基础上实现的，处理默认空参构造方法。如下这个构造函数包含了大部分其他构造方法使用的参数，就不一一列举了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                         <span class="type">float</span> loadFactor,</span></span><br><span class="line"><span class="params">                         <span class="type">boolean</span> accessOrder)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);<span class="comment">// 调用 HashMap 对应的构造函数</span></span><br><span class="line">    <span class="built_in">this</span>.accessOrder = accessOrder;<span class="comment">// 迭代顺序的默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该构造函数意在构造一个指定<code>初始容量</code> 和 <code>负载因子</code> 的<code>具有指定迭代顺序</code>的LinkedHashMap</p><p><strong>初始容量</strong> 和 <strong>负载因子</strong>是影响HashMap 性能的两个重要参数。同样地，它们也是影响LinkedHashMap 性能的两个重要参数。此外，LinkedHashMap 增加了双向链表头结点，和标志位 accessOrder 两个属性用于保证迭代顺序。</p><h4 id="1-3-2、LinkedHahsMap-Map-m"><a href="#1-3-2、LinkedHahsMap-Map-m" class="headerlink" title="1.3.2、LinkedHahsMap(Map&lt;? extends K,? extends V&gt; m)"></a>1.3.2、LinkedHahsMap(Map&lt;? extends K,? extends V&gt; m)</h4><p>该构造函数意在构造一个与指定 Map 具有相同映射的 LinkedHashMap，其初始容量不小于 16（具体依赖于指定 Map 的大小），负载因子是 0.75，是 Java Collection Framework 规范推荐提供</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4、LinkedHashMap-的数据解构"><a href="#1-4、LinkedHashMap-的数据解构" class="headerlink" title="1.4、LinkedHashMap 的数据解构"></a>1.4、LinkedHashMap 的数据解构</h3><blockquote><p>本质上，LinkedHashMap &#x3D; HashMap + 双向链表，也就是说，HashMap 和双向 链表合二为一即是 LinkedHashMap。也可以这样理解，LinkedHashMap 在不对 HashMap 做任何改变的基础上，给 HashMap 的任意两个节点加了两条连线（<strong>before指针</strong> 和 <strong>after指针</strong>），使这些节点形成一个双向链表。</p><p>在LinkedHashMap 中， 所有put 进来的Entry 都保存在 HashMap 中， 但由于它有额外定义了一个以head 为头结点的空的双向链表，因此对于每次put进来的Entry 还会将其插入到双向链表的尾部。</p></blockquote><h3 id="1-5、put-和-get-操作"><a href="#1-5、put-和-get-操作" class="headerlink" title="1.5、put 和 get 操作"></a>1.5、put 和 get 操作</h3><h4 id="1-5-1、put-操作"><a href="#1-5-1、put-操作" class="headerlink" title="1.5.1、put 操作"></a>1.5.1、put 操作</h4><p>LinkedHashMap 没有 put 方法，插入操作交给了HashMap，通过重写 <code>newNode、newTreeNode</code>方法来创建自己的节点，并对 before 与 after 进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写 newNode 方法</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写 newTreeNode 方法</span></span><br><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">newTreeNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// link at the end of list</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在LinkedHashMap 中，添加节点是通过 HashMap 的put 方法来添加，当创建新的节点时，调用的方法为 LinkedHashMap的 <code>newNode、newTreeNode</code> 。从 <code>linkNodeLast</code> 可以看出，无论是插入顺序还是LRU 顺序，新插入的节点都讲被放在末尾。在 HashMap 的 putVal 方法末尾有这两个判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">       <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">       <span class="keyword">if</span>(!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">       e.value = value;</span><br><span class="line">       afterNodeAccess(e);</span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;<span class="comment">//原尾节点</span></span><br><span class="line">    <span class="comment">// 如果 accessOrder 是 true，且原尾节点不等于 e</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        <span class="comment">// 节点 e 强转成双向链表节点 p</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        <span class="comment">// p 现在是尾节点，后置节点一定是 null</span></span><br><span class="line">        p.after = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 如果 p 的前置节点是null，则 p 以前是头结点，所以更新现在的头结点是 p 的后置节点a</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">// 否则 更新 p 的前置节点 b 的后置节点为 a</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="comment">// 如果 p 的后置节点不是null，则更新后置节点a 的前置节点为 b</span></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//如果原本p的后置节点是nul,则 p 就是为节点。此时更新 last 的应用为p 的前置节点b</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)<span class="comment">//原本尾节点是null  则，链表中就一个节点</span></span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//否则 更新 当前节点p的前置节点为 原尾节点last， last的后置节点是p</span></span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尾节点的引用赋值成p</span></span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="comment">//修改modCount。</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行代码：如果e 不为 null，代表 key 重复，新的value 值替换旧值，afterNodeAccess(e)被调用，该方法在 HashMap 中为空，在 LinkedHashMap 实现，作用就是对 asccessOrder 为 true 情况（LRU顺序）下将该节点调到末尾，因为它被改动了。</p><p>在<code>afterNodeAccess</code> 方法中，将 e 节点的前一个节点 b 与后一个节点 a 连在一起，将 e 调到末尾。LRU 顺序下，末尾节点代表着最新的节点，意思是要么是：新插的，被更改的、被 get 访问到的。</p><p>第二段代码：插入新节点后，对于 LinkedHashMap 来说要进行 afterNodeInsertion 操作，作用是判断是否是要删除 head 节点，这是一个拓展点，可以重写 removeEldestEntry 方法，执行自己的逻辑，比如数量超过某值后插入新值会删除最久未被操作的值，即头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 evict ，默认是 true。在 HashMap 的put 方法中，调用 putVal 传的是 true，那么决定是否删除 head 节点的操作就取决于 removeEldestEntry 方法。</p><hr><h4 id="1-5-2、get-操作"><a href="#1-5-2、get-操作" class="headerlink" title="1.5.2、get 操作"></a>1.5.2、get 操作</h4><p>LinkedHashMap 的 get 操作是调用自身的 get 方法，重写了 HashMap 的 get 方法。而其中的具体实现调用了 HashMap 的 getNode 方法。getNode 后，可以看到如果是 LRU 顺序，则被访问的节点会被移到末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-3、remove操作"><a href="#1-5-3、remove操作" class="headerlink" title="1.5.3、remove操作"></a>1.5.3、remove操作</h4><p>remove 具体操作仍然是在 HashMap 里实现，同 putVal 一样，留下一个钩子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">................</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">................</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-3、迭代器"><a href="#1-5-3、迭代器" class="headerlink" title="1.5.3、迭代器"></a>1.5.3、迭代器</h4><p>afterNodeRemoval 方法就是将该节点的前后连在一起，链表的删除操作。</p><p><img src="/../../assets/blogImg/code-analysis/Glide/LinkedHashMap_iterator.png" alt="LinkedHashMap_iterator"></p><h2 id="二、LinkedHashMap-与-Lru"><a href="#二、LinkedHashMap-与-Lru" class="headerlink" title="二、LinkedHashMap 与 Lru"></a>二、LinkedHashMap 与 Lru</h2><p>heade 是LinkedHashMap 所维护的双向链表的头结点，而 accessOrder 用于决定具体的迭代顺序。实际上，accessOrder 标志位的作用不像我们描述这样简单。</p><blockquote><p>当 accessOrder 标志位位 true 时， 表示双向链表中的元素按照访问的先后顺序排列，可以看到，虽然Entry 插入链表的顺序依然是按照其 put 到 LinkedHashMap 中的顺序，但 put 和 get 方法均有调用 afterNodeAccess 方法。</p><p>afterNodeAccess 方法判断 accessOrder 是否为 true，如果是，则将当前访问的 Entry 移到双向链表的尾部；</p><p>当标志位 accessOrder 的值为 false 时， 表示双向链表中的元素按照 Entry 插入 LinkedHashMap 中的先后顺序排序，即每次 put 到 LinkedHashMap 中的 Entry 都放在双向链表的尾部，这样遍历双向链表时， Entry 的输出顺序和插入的顺序一致，这也是默认的双向链表的存储顺序。</p></blockquote><h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p><strong>LinkedHashMap 将具体操作都交给了 HashMap，二者直接究竟是如何配合的？</strong></p><blockquote><p>这涉及到 LinkedHashMap 如何利用 HashMap 来实现直接的功能，是这样的，在 HashMap 的插入删除等操后会调用钩子方法（afterNodeAccess，afterNodeInsertion，afterNodeRemoval），而这些方法的实现就在 LinkedHashMap 中，这些方法的目的就是操作 before 和 after 指针。LinkedHashMap 重写 newNode，newTreeNode 方法，这两个方法是在插入时 HashMap 构建新节点时调用的，对于重写后 newNode 先是创建 HashMap 的 TreeNode 节点，因为其继承自 LinkedHashMap#Entry，所以含有 before&#x2F;after 指针，之后同样加入到链尾。</p></blockquote><p><strong>在分析HashMap源码时，发现<code>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt;</code>，为什么不直接继承Node，而且在相关方法中也没有用到Entry的before与after指针？</strong></p><blockquote><p>若是TreeNode 直接继承自 Node，那么对于 LinkedHashMap#Entry 就要继承自 TreeNode，那么对于 LinkedHashMap 来说它的每个节点都将含有 left、right、parent、prev 四个指针，就是没必要的，浪费空间。所以采用 TreeNode 继承 LinkedHashMap.Entry 的方式，当然对于 HashMap，它没有任何关于 before&#x2F;after 的操作，对于它来说这是种浪费，但相比较而言采用这种方式更好。而且，对于 HashMap 来说若 key 的 hashCode 方法实现的够好的话，指的是分布均匀，那么树将很少出现。</p></blockquote><h2 id="四、Android-的-LruCache"><a href="#四、Android-的-LruCache" class="headerlink" title="四、Android 的 LruCache"></a>四、Android 的 LruCache</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;key == null || value == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V previous;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        putCount++;</span><br><span class="line">        size += safeSizeOf(key, value);</span><br><span class="line">        previous = map.put(key, value);</span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="literal">null</span>) &#123;</span><br><span class="line">            size -= safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="literal">null</span>) &#123;</span><br><span class="line">        entryRemoved(<span class="literal">false</span>, key, previous, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">    <span class="keyword">return</span> previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Android  的 LruCache 源码中 put 方法负责将 key 和 value 添加到 LinkedHashMap 中，同时更新 size 记录缓数据的大小。最后调用 trimToSize 让已缓存大小小于等于最大缓存大小，会移除最近最少使用的缓存数据。每次put 的时候，都去检查。当 LruCache 达到最大缓存值时，以后put 都有有可能执行删除操作。</p><h2 id="五、Glide-LruCache"><a href="#五、Glide-LruCache" class="headerlink" title="五、Glide LruCache"></a>五、Glide LruCache</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Y <span class="title function_">put</span><span class="params">(<span class="meta">@NonNull</span> T key, <span class="meta">@Nullable</span> Y item)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">itemSize</span> <span class="operator">=</span> getSize(item);</span><br><span class="line">    <span class="keyword">if</span> (itemSize &gt;= maxSize) &#123;</span><br><span class="line">        onItemEvicted(key, item);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (item != <span class="literal">null</span>) &#123;</span><br><span class="line">        currentSize += itemSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Nullable</span> <span class="keyword">final</span> <span class="type">Y</span> <span class="variable">old</span> <span class="operator">=</span> cache.put(key, item);</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">        currentSize -= getSize(old);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!old.equals(item)) &#123;</span><br><span class="line">            onItemEvicted(key, old);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    evict();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Glide 的 LruCache 中，put 方法的作用就是把 key 和 value 放到 LinkedHashMap 中，同时要更新 LruCache 维护的已缓存大小（Android LruCache 是 size 字段， Glide LruCache 是 currenSize 字段），具体而言就是加上value 的大小减去 previous 的大小。最后，通过 trimToSize 去检查缓存有没有超限。</p><p>资料来源：</p><p><a href="https://blog.csdn.net/zhongyili_sohu/article/details/105969763">https://blog.csdn.net/zhongyili_sohu/article/details/105969763</a></p><p><a href="https://www.cnblogs.com/AliCoder/p/11815353.html">https://www.cnblogs.com/AliCoder/p/11815353.html</a></p><p><a href="https://blog.csdn.net/sinat_34976604/article/details/80971616">https://blog.csdn.net/sinat_34976604/article/details/80971616</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;知识拓展主要分为以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;深入理解LinkedHashMap&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LinkedHashMap 与 Lru(Least recently used，最近最少使用)算法&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Android LruCache&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Glide LruCache&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://cxinxian.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Glide 流程分析总结</title>
    <link href="http://cxinxian.github.io/2021/12/01/code-analysis/Glide/Glide%20%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://cxinxian.github.io/2021/12/01/code-analysis/Glide/Glide%20%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-01T13:50:13.000Z</published>
    <updated>2025-02-21T14:29:30.530Z</updated>
    
    <content type="html"><![CDATA[<p>本文是在查看源码后然后根据前辈的总结，然后做出关于 Glide 加载图片流程的总结整理。</p><span id="more"></span><h2 id="一、整体的加载流程"><a href="#一、整体的加载流程" class="headerlink" title="一、整体的加载流程"></a>一、整体的加载流程</h2><p>但我们加载图片调用<code>Glide.with().load()</code>时，整体来看Glide 加载图片分为如下几个步骤，当然首次加载图片是有初始化的必要，产生一个单例的Glide 后，后续的加载图片过程就剩下三个步骤了。</p><p><img src="/../../assets/blogImg/code-analysis/Glide/glide-summary-01.jpg" alt="glide-summary-01"></p><ol><li><p><strong>初始化Glide</strong></p><p>当调用 Glide.with() 时，如果是首次加载图片，会初始化一个 Glide 单例。与此同时，一些相关的部件也会初始化，比如RequestManagerRetriever、Engine、LruResourceCache、BitmapPool、ArrayPool、加载选项、编解码器、转码器等等都会被初始化。此外在实例化 RequestManager 的同时，与无界面的 Fragment 绑定生命周期。</p></li><li><p><strong>请求构建器RequestBuilder</strong></p><p>调用 into() 构建RequestBuilder 时，会根据 ImageView 构建一个ViewTarget 目标，并且与 request实例绑定。默认情况下使用的是 SingleRequest 实例。在ViewTarget 中通过实现 <code>ViewTreeObserver.OnPreDrawListener</code> 接口，监听当 onPreDraw 得到执行时，就会触发 SingleRequest的 onSizeReady 方法，进而触发 Engine 的 load 方法执行加载图片任务</p></li><li><p><strong>解码任务 DecodeJob</strong></p><p>Engine 加载图片任务得到执行后，通过 EngineJob中的GlideExecutor来调度执行调用 DecodeJob 加载图片。而DecodeJod 的主要任务则是先后通过内存缓存、磁盘缓存、或者资源地址加载图片。在加载磁盘缓存或者资源地址加载图片时，会根据入参 Model 匹配对应的ModelLoader，获取相应LoaData 加载对应的图片。</p></li><li><p><strong>目标 Target</strong></p><p>在DecodeJob 完成图片的加载后，通过回调方法 onResourceReady() 通知 EngineJob以及 SingleRequest，在SingleRequest 的onResourceReady方法中再通知  ViewTarget 加载图片资源。其中在 EngineJob 中通调用 Engine 的 onEngineJobComplete回调方法，实现对图片资源的 ActiveResources 内存缓存。</p></li></ol><h2 id="二、从-into-到-DecodeJob-run"><a href="#二、从-into-到-DecodeJob-run" class="headerlink" title="二、从 into() 到 DecodeJob.run()"></a>二、从 into() 到 DecodeJob.run()</h2><p><img src="/../../assets/blogImg/code-analysis/Glide/glide-summary-02.png" alt="glide-summary-02"></p><p>由源码中得知，从构建 Request 请求 into 加载图片到图片显示可分为上图中的10个步骤。其中主要涉及到 5个对象</p><ul><li>加载请求 Request</li><li>图片加载目标 Target</li><li>图片加载引擎 Engine</li><li>图片加载引擎任务管理 EngineJob</li><li>解码任务 DecodeJob</li></ul><hr><h3 id="2-1、Requet"><a href="#2-1、Requet" class="headerlink" title="2.1、Requet"></a>2.1、Requet</h3><h3 id="2-1-1、RequestManager-的创建"><a href="#2-1-1、RequestManager-的创建" class="headerlink" title="2.1.1、RequestManager 的创建"></a>2.1.1、RequestManager 的创建</h3><p>通过Glide 调用 with(context)时，实际上会通过RequestManagerRetriver 创建 RequestManager，并且将 RequestManager 与一个无界面的 Fragment 的生命周期进行绑定和监听，方便 RequestManger 管理 Request，实现图片的加载、停止、销毁能够与页面的生命周期相关联。同时也添加了网络状态的监听，让图片的加载、停止也能够更加网络状态的变化做出相应的动作。</p><ol><li><p><strong>创建 RequestManagerRetriver</strong></p><p>Glide 首次调用会在Glide初始化时创建 RequestManagerRetriver 实例。</p></li><li><p><strong>绑定生命周期</strong></p><p>在 Glide 中，一个 Context 对应一个 RequestManager。当调用 with(context) 时，通过 <code>RequestManagerRetriver.get(context)</code> 方法获取或者创建一个对应的 RequestManager， 与此同时也会使用context创建一个相对应的无UI界面的Fragment</p><p>RequestManager 实现了 LifecycleListener接口，意味着能够监听Fragment的生命周期。</p><p>Fragment 主要是用了做生命周期的关联，当感知到宿主 Activity&#x2F;Fragment 的生命周期发生变化时，就会通知 RequestManager， 让它去做暂停请求、继续请求和取消请求等操作。</p><p>如果我们用的是 ApplicationContext 加载某张图片，那就意味着这次图片加载操作的生命周期是与应用的生命周期绑定的。<strong>（一般使用上不建议图片的加载与应用的生命周期绑定）</strong></p></li><li><p><strong>监听网络状态</strong></p><p>RequestManager 有一个 RequestManagerConnectivityListener 网络监听器，它实现了<code>ConnectivityMonitor.ConnectivityListener</code> 接口，当网络状态切换时，RequestManager 就会重启所有的图片加载请求。</p></li><li><p><strong>创建请求构造器 RequestBuilder</strong></p><p>加载图片调用 load() 设置图片资源来源是 RequestManager的方法，在调用这个方法实际上是创建了 RequestBuilder 构造器，RequestManager 中有很多创建 RequestBuilder 的方法，比如 asDrawable()、asBitmap() 、asFile() 等，这些方法对应着不同泛型参数的 RequestBuilder 。</p><p>load() 方法对应的参数有：</p><ul><li>Bitmap</li><li>Drawable</li><li>String</li><li>Uri</li><li>URL</li><li>File</li><li>Integer（resourceId）</li><li>byte[]</li><li>Object</li></ul></li><li><p><strong>启动请求</strong></p><p>RequestManager 的 track() 方法调用了  TargetTracker 的 track() 方法，还调用了请求跟踪器 RequestTracker 的 runRequest() 方法 。</p><blockquote><p><em>TargetTracker</em><br>TargetTracker 实现了 LifecycleListener ，当RequestManager 收到页面生命周期变动时，则通过TargetTracker实例调用相应的方法，使它会根据页面生命周期播放和暂停动画，比如暂停 Gif 动画。</p><p>RequestTracker<br>RequestTracker 的 runRequest() 方法调用了 Request.begin() 方法。<br>在 Request 的 begin() 方法中会获取 View 的尺寸，获取到了尺寸后就会调用 Engine 的 load() 方法启动图片加载请求。</p></blockquote></li></ol><h4 id="2-1-2、Request-请求构建"><a href="#2-1-2、Request-请求构建" class="headerlink" title="2.1.2、Request 请求构建"></a>2.1.2、Request 请求构建</h4><p>调用into() 方法时，会通过 RequestBuilder 构建请求</p><ol><li><p><strong>into()</strong></p><p>当发起图片加载请求时，Glide 会吧请求封装为Request，而构建Request 的任务则是由 RequestBuilder 请求建造器完成。</p><p>调用into() 方法，实则是调用 RequestBuilder  的into() 方法，</p></li><li><p><strong>Model</strong></p><p>Glide 会把我们在  load()  方法传入的图片数据来源封装为 Model ，对应为 RequestBuilder 中的Object类型的model对象。</p></li></ol><h4 id="2-1-3、Request-的6种状态"><a href="#2-1-3、Request-的6种状态" class="headerlink" title="2.1.3、Request 的6种状态"></a>2.1.3、Request 的6种状态</h4><ol><li><p><strong>待运行 PENDING</strong></p><p>创建 SingleRequest 后，该 Request 就进入待运行状态</p></li><li><p><strong>已清除 CLEARED</strong></p><p>每次我们用 into() 方法加载图片时，RequestManager 都会先看下我们传入的 Target 是否有对应的 Request ，如果有的话就会调用该 Request 的 clear() 方法释放资源，这时 Request 就进入了已清除状态。</p></li><li><p><strong>待测量 WAITING_FOR_SIZE</strong></p><p>当 RequestManager 调用 RequestTracker 的 runRequest() 方法后，RequestTracker 就会调用 Request 的 begin() 方法，这时请求就进入了待测量状态。</p></li><li><p><strong>运行中 RUNNING</strong></p><p>在 SingleRequest 的 begin() 方法中，调用了 Target 的 getSize() 方法获取 ImageView 的尺寸，获取到尺寸后，SingleRequst 会调用 Engine 的 load() 方法启动图片加载请求，这时 Request 就进入了运行中状态。</p></li><li><p><strong>已完成 COMPLETE</strong></p><p>当 Engine 从内存中加载到资源，或者通过解码任务加载到资源后，就会调用 SingleRequest 的 onResourceReady() 方法，这时 Request 就进入了已完成状态。</p></li><li><p><strong>失败 FAILED</strong></p></li></ol><p>   当解码任务 DecodeJob 在处理图片的过程中遇到异常时，就会调用 EngineJob 的 onLoadFailed() 方法，然后 EngineJob 会调用 SingleRequest 的 onLoadFailed() 方法，这时 SingleRequest 就进入了失败状态。</p><p>   <img src="/../../assets/blogImg/code-analysis/Glide/glide-summary-03.png" alt="glide-summary-03"></p><h4 id="2-1-4、三种占位图"><a href="#2-1-4、三种占位图" class="headerlink" title="2.1.4、三种占位图"></a>2.1.4、三种占位图</h4><p>使用Glide 加载图片是，我们可以设置 placeholder、error 和 fallback 三种占位图</p><ul><li><p><strong>placeholder</strong> </p><p>图片加载完成前显示的占位图；</p></li><li><p><strong>error</strong></p><p>图片加载失败时显示的占位图；</p></li><li><p><strong>fallback</strong></p><p>图片来源为空时显示的占位图；</p></li></ul><blockquote><p>使用占位图时，要注意占位图是不会使用 Transformation 进行变换的，如果你想弄个圆角或圆形的占位图，可以用 submit().get() 获取对应变换后的占位图的 Drawable 对象，然后传到对应的占位图设置方法中。</p></blockquote><h4 id="2-1-5、Request-的相关问题"><a href="#2-1-5、Request-的相关问题" class="headerlink" title="2.1.5、Request 的相关问题"></a>2.1.5、Request 的相关问题</h4><blockquote><p>我们平时用 Glide 加载图片调用的 into() 方法是哪个类的方法？<br>当设备的网络状态发生变化时，是谁负责重启图片加载请求？<br>Request 有哪几种状态？这些状态是如何流转的？<br>Glide 有几种占位图？分别在什么时候显示？</p></blockquote><hr><h3 id="2-2、Target"><a href="#2-2、Target" class="headerlink" title="2.2、Target"></a>2.2、Target</h3><p>当调用 RequestBuilder 的 into() 方法将 ImageView 作为参数传进去后，Glide 将 ImageView 转换包装为Target，下面将会根据源码总结分析不同 Target 的作用。</p><h4 id="2-2-1、ImageViewTarget"><a href="#2-2-1、ImageViewTarget" class="headerlink" title="2.2.1、ImageViewTarget"></a>2.2.1、ImageViewTarget</h4><ol><li><p><strong>SizeDeterminer</strong></p><p>ImageViewTarget 继承自 ViewTarget，ViewTarget 中有一个用来获取View尺寸的 SizeDeterminer，其中通过 getSize(SizeReadyCallback) 设置回调拿到尺寸，是把 ImageView 的内边距 padding() 去掉后的尺寸。<br>在 Glide 中，宽高分为请求宽高和原始宽高 ，而 SizeDeterminer 拿到的尺寸就是请求宽高，Glide 会根据请求宽高对图片进行缩放操作，以减少不必要的内存消耗。</p></li><li><p><strong>OnPreDrawListener</strong></p><p>当 Request 获取 View 的尺寸失败时，ViewTarget 会通过 ViewTreeObserver 的 OnPreDrawListener 的回调来获取 View 的尺寸，然后再传给 Request。</p></li><li><p><strong>setResource()</strong></p><p>ImageViewTarget 主要有 BitmapImageViewTarget 和 DrawableImageViewTarget 两个子类，它们两个的区别就在于它们的 setResource() 方法。</p><blockquote><p>BitmapImageViewTarget<br>setResource() 用的是 ImageView 的 setImageBitmap() 方法；</p><p>DrawableImageViewTarget<br>setResource() 用的是 ImageView 的 setImageDrawable() 方法;</p></blockquote></li></ol><h4 id="2-2-2、RequestFutureTarget"><a href="#2-2-2、RequestFutureTarget" class="headerlink" title="2.2.2、RequestFutureTarget"></a>2.2.2、RequestFutureTarget</h4><ol><li><p><strong>submit()</strong><br>FutureTarget 是一个实现了 Future 和 Target 接口的接口，它只有一个 RequestFutureTarget 子类 ，当我们用 submit() 方法获取 Glide 加载好的图片资源时，就是创建了一个 RequestFutureTarget 。</p></li><li><p>Waiter<br>   RequestFutureTarget 是用 wait&#x2F;notify 的方式来实现等待和通知的，这两个是 Object 的方法，Request 中有一个 Waiter ，当 DecodeJob 加载到图片后，RequestFutureTarget 就会让 Waiter 发出通知，这时我们的 get() 方法就能获取到返回值了。<br>   这就是为什么我们用 RequestFutureTarget 的 get() 方法获取图片时，要把这个操作放在子线程运行。</p></li></ol><h4 id="2-2-3、-CustomTarget"><a href="#2-2-3、-CustomTarget" class="headerlink" title="2.2.3、 CustomTarget"></a>2.2.3、 CustomTarget</h4><p>给不是 View 的 Target 加载图片时，Glide 都把它作为 CustomTarget 。</p><ol><li><strong>PreloadTarget</strong><br>预加载 Target 。<br>当我们调用 preload() 选项预加载图片时，Glide 会把图片交给 PreloadTarget 处理，当 PreloadTarget 接收到图片资源后，就会让 RequestManager 把该请求的资源释放掉。<br>因为不需要等待资源加载完成，所以我们在用 preload() 预加载图片时，不用像 submit() 一样在子线程中执行。</li><li><strong>AppWidgetTarget</strong><br>桌面组件 Target 。<br>当 AppWidgetTarget 接收到处理好的图片资源后，会把它设置给 RemoteView ，然后通过桌面组件管理器 AppWidgetManager 更新桌面组件。</li><li><strong>DelayTarget</strong><br>GifTarget。<br>这是加载 Gif 图片时要用到的 Target ，关于 Glide 加载 Gif 图片的流程在后面会讲到。</li><li><strong>NotificationTarget</strong><br>通知栏 Target 。<br>这个 Target 有一个 setBitmap 方法，会把图片设置给通知栏的 RemoteView ，然后通过 NotificationManager 更新通知栏中的通知。</li></ol><h4 id="2-2-4、Target-的相关问题"><a href="#2-2-4、Target-的相关问题" class="headerlink" title="2.2.4、Target 的相关问题"></a>2.2.4、Target 的相关问题</h4><blockquote><p>ImageViewTarget 是用什么来获取请求宽高的？<br>为什么在用 submit() 获取图片时，要放在子线程中执行？<br>使用 preload() 预加载图片时，用的是哪个 Target ？该 Target 获取到资源会后做什么？</p></blockquote><hr><h3 id="2-3、Engine"><a href="#2-3、Engine" class="headerlink" title="2.3、Engine"></a>2.3、Engine</h3><p>下面一起看看关于 Engine 的相关实现</p><p>Engine 的作用</p><p>Key 的作用</p><p>Resource 的作用</p><p>BitmapPool</p><h4 id="2-3-1、Engine-的作用"><a href="#2-3-1、Engine-的作用" class="headerlink" title="2.3.1、Engine 的作用"></a>2.3.1、Engine 的作用</h4><p>Engine 是 Glide 的图片加载引擎，是 Glide 中非常重要的一个类，其大致流程如下图所示</p><p><img src="/../../assets/blogImg/code-analysis/Glide/glide-summary-04.png" alt="glide-summary-04"></p><ol><li><p><strong>Engine.load()</strong></p><p>由前面的分析可知，当调用 into() 后，会构建一个 Request，进而触发 <code>Request.begin()</code> 方法，在获取到 Target 的尺寸后，回调 onSizeReady，然后触发调用 <code>Engin.load()</code> 方法。</p><p>在 load() 方法中，Engine 会先调用 EngineKeyFactory 创建资源标识符 Key，然后用这个 Key 去内存缓存中加载资源。</p><p>如果从内存中找到了资源，Engine 就会直接把资源回传给 Resource，如果没有加载到资源，Engine 就会创建并启动新的 EngineJob 和解码任务 DecodeJob。</p></li><li><p>**EngineKeyFactory **</p><p>EngineKeyFactory 是 Engine 中负责生产 EngineKey 的工厂，EngineKey 是引擎任务资源标识符，关于什么是 Key 后面进一步讲。</p><p>在 Engine 启动新的任务加载图片前，会先通过 EngineKeyFactory 创建一个 EngineKey，然后让 DecodeJob 把资源与 EngineKey 进行绑定，这里说的绑定，其实就是把 model 放到 EngineKey 中。</p></li><li><p><strong>回收资源</strong></p><p>Engine 中有一个资源回收器 ResourceRecycler ，Resource 接口中有一个 recycle() 方法，关于 Resource 我们后面再讲。<br>这里只要知道，当 SingleRequest 被清除，比如在 into() 方法中发现 Target 已经有对应的 Request 时，Request 就会让 Engine 释放资源，具体做释放资源操作的就是 ResourceRecycler。</p></li><li><p><strong>磁盘缓存提供器</strong></p><p>LazyDiskCacheProvider 是 Engine 中的一个静态内部类，是磁盘缓存 DiskCache 的提供器，DiskCache 是一个接口，关于 DiskCache 的实现我们后面再讲。</p></li><li><p><strong>启动新的解码任务</strong></p></li></ol><p>   当 Engine 从内存中找不到对应的 Key 的资源时，就会启动新的解码任务。<br>   Engine 会用加载任务工厂 EngineJobFactory 构建一个加载任务 EngineJob，然后再构建一个解码任务 DecodeJob。<br>   EngineJob 这个名字看起来很霸气，但是实际上它并没有做什么事情，它只是 Engine 与 DecodeJob 之间沟通的桥梁。<br>   当构建了 EngineJob 和 DecodeJob 后，Engine 就会把 DecodeJob 提交到线程池 GlideExecutor 中。</p><hr><h4 id="2-3-2、Key"><a href="#2-3-2、Key" class="headerlink" title="2.3.2、Key"></a>2.3.2、Key</h4><p>前面讲到了 Engine 会通过 EngineKeyFactory 创建资源标识符 Key ，那什么是 Key ？</p><p>Key 是 Glide 中的一个接口，是图片资源的标识符。</p><ol><li><p><strong>避免比较有误</strong></p><p>Glide 的内存缓存和磁盘缓存用的都是 Glide 自己实现的 LruCache，LruCache 也就是最近最少使用缓存算法（Least Recently Used），LruCache 中有一个 LinkedHashMap ，这个 HashMap 的 Key 就是 Key 接口，而 Value 则是 Resource 接口。<br>在用对象作为 HashMap 的 Key 时，要重写 equals() 和 hashCode() 方法。<br>如果不重写这两个方法，那么当两个 Key 的内存地址不同，但是实际代表的资源相同时，使用父类 Object的 hasCode() 直接用内存地址做比较，那么结果会是不相等。<br>此外 Object 的 equals() 方法也是拿内存地址作比较，所以也要重写。<br>比如下面就是 ResourceCacheKey 的 equals() 判断逻辑。</p></li><li><p><strong>Key 的实现类</strong></p><p><img src="/../../assets/blogImg/code-analysis/Glide/glide-summary-05.png" alt="glide-summary-05"></p></li></ol><blockquote><p>DataCacheKey<br>原始图片数据标识符。</p><p>ResourceCacheKey<br>处理后的图片资源标识符。</p><p>AndroidResourceSignature<br>Android 资源标识符。当我们传入 into() 方法的图片是 R.drawable.xxx 时，Glide 就会把它封装为 AndroidResourceSignature 。</p><p>ObjectKey<br>通用资源标识符。<br>可以说除了 App 自带的 Android 资源以外的图片资源都会用 ObjectKey 作为标识符，比如本地图片文件。</p><p>EngineKey<br>引擎资源标识符。<br>这个 Key 是 Engine 对其他 Key 的封装，这时传进来的 Key 是以签名（Signature）的身份存在 EngineKey 中的。</p></blockquote><hr><h4 id="2-3-3、Resource"><a href="#2-3-3、Resource" class="headerlink" title="2.3.3、Resource"></a>2.3.3、Resource</h4><p>前面讲到了 Engine 会通过 ResourceRecycler 来回收资源，而 ResourceRecycler 调用了 Resource 的 recycle() 方法。</p><p>可能你想起来 Bitmap 就有一个可以回收图片内存的 recycle() 方法，没错，Glide 回收 Bitmap 的方式就是用的 Bitmap 自带的 recycle() 方法，但是这个过程又比这复杂一些。</p><p>Resource 是一个接口，其中一个实现类是 BitmapResource ，也就是位图资源，比如网络图片就会转化为 BitmapResource。<br>在 BitmapResource 中有一个位图池 BitmapPool，这是 Glide 用来复用 Bitmap 的一个接口，具体的实现类是 LruBitmapPool 。<br>在 BitmapResource 的 recycle() 方法中，会把对应的 Bitmap 通过 put() 方法放到 BitmapPool 中，关于 BitmapPool 在讲 Glide 缓存原理时会进一步讲。</p><hr><h4 id="2-3-4、Engine-相关问题"><a href="#2-3-4、Engine-相关问题" class="headerlink" title="2.3.4、Engine 相关问题"></a>2.3.4、Engine 相关问题</h4><blockquote><p>Engine 的 load() 方法首先会做什么？<br>为什么 Key 要重写 hashCode() 和 equals() 方法？<br>负责回收 Resource 的是哪个类？<br>加载 Drawable 资源时，会转化为哪种 Key？</p></blockquote><hr><h3 id="2-4、EngineJob"><a href="#2-4、EngineJob" class="headerlink" title="2.4、EngineJob"></a>2.4、EngineJob</h3><p>EngineJob 可以看做 Engine 的一个附属工具类，主要用于启动 DecodeJob， 同时也充当着回调分发的任务，当DecodeJob 加载图片成功后回调给 EngineJob。EngineJob 则把接接结果同时分发会 Engine 和 SingleRequest</p><p>通过调用 onEngineJobComplete() 可以把图片资源返回给 Engine</p><p>通过调用 onResourceReady()  可以把加载成功的图片返回给 SingleRequest</p><hr><h3 id="2-5、DecodeJob"><a href="#2-5、DecodeJob" class="headerlink" title="2.5、DecodeJob"></a>2.5、DecodeJob</h3><p>在前面的分析总结中，当从内存缓存中获取不到图片资源是，则启动解码任务。在DecodeJob 解码任务中，如果在磁盘缓存中获取不到图片，那么就从图片源地址中获取图片。</p><p>DecodeJob 实现了 Runnable 接口，EngineJob 启动 DecodeJob 的方式就是把它提交给 GlideExecutor，如果我们没有调整磁盘缓存策略的话，那默认用的就是 diskCacheExecutor ，关于 GlideExecutor 在第 4 大节会讲，下面我们先看下 DecodeJob 的实现。</p><hr><h4 id="2-5-1、runWrapped"><a href="#2-5-1、runWrapped" class="headerlink" title="2.5.1、runWrapped()"></a>2.5.1、runWrapped()</h4><p>从源码中分析，DecoedJob.run() 方法调用了 runWrapped()，并且只对其异常捕获。而 runWrapped() 根据不同的 RunReason 运行不同的 DataFetcherGenerator。</p><p><img src="/../../assets/blogImg/code-analysis/Glide/glide-summary-06.png" alt="glide-summary-06"></p><ol><li><p><strong>三种不同的运行理由 RunReason：</strong></p><blockquote><p>INITAILIZE<br>从缓存中获取数据并解码；</p><p>SWITCH_TO_SOURCE_SERVICE<br>从来源获取数据后再进行解码；</p><p>DECODE_DATA<br>当获取数据的线程与 DecodeJob 的线程不同时，比如使用了 OkHttp-Integration 时，DecodeJob 会直接对数据进行解码；</p></blockquote></li><li><p><strong>初始化</strong></p><p>Decode 初始化 init() 为默认状态，会通过 ResourceCacheGenerator  实例化DataFetcherGenerator，获取磁盘中经过变换后的图片资源。如果获取不到变换后的图片资源则再通过 DataCacheGenerator 获取原始图片数据缓存。</p></li><li><p><strong>从数据来源获取数据</strong></p><p>当从磁盘缓存中获取不到图片资源后，则runReason 变更为 SWITCH_TO_SOURCE_SERVICE，从来源获取数据，然后运行来源数据生成器 SourceGenerator </p></li><li><p><strong>对检索到的数据进行解密</strong></p><p>DecodeJob 通过数据生成器获取到数据后，就会调用 decodeFromRetrievedData() 方法来对检索到的数据进行解码。此时runReason 变更为 DECODE_DATA</p></li></ol><hr><h4 id="2-5-2、DecodeJob-的数据获取流程"><a href="#2-5-2、DecodeJob-的数据获取流程" class="headerlink" title="2.5.2、DecodeJob 的数据获取流程"></a>2.5.2、DecodeJob 的数据获取流程</h4><p>在 getNextState() 方法中，根据当前的解码步骤来判断下一步应该执行的步骤，总共分为 6 个阶段，这两个阶段是 State 枚举类中的值，分别如下：</p><ol><li><p><strong>INITIALIZE</strong> :</p><p>初始化，默认状态。</p><p>最开始解码处于这个状态，然后 DecodeJob 会根据缓存策略，<u>判断是否要从磁盘中获取处理过图片数据缓存资源</u>，如果是，则 生成 <code>ResourceCacheGenerator</code> 实例获取图片资源。如果获取到数据，则进行解码。如果获取不到处理过的图片数据资源，那么就切换到下一个解码阶段 RESOURCE_CACHE。</p></li><li><p><strong>RESOURCE_CACHE</strong>：</p><p>从磁盘缓存中获取处理过的图片，其对应的缓存资源Generator 为 <code>ResourceCacheGenera</code>。</p><p>当解码处于当前阶段时， DecodeJob 会根据缓存策略<u>判断是否要从磁盘中获取 未处理过的图片数据</u>，如果是的话就用 DataCacheGenerator获取数据。</p></li><li><p><strong>DATA_CACHE</strong>：</p><p>从缓存中获取原始（未处理过的）数据。</p><p>当处于该阶段时，如果在加载图片时调用了 onlyRetrieveFromCache(true) ，那么就不会切换到 SOURCE 阶段从来源获取数据，而直接切换的 FINISHED 阶段结束解码流程。</p></li><li><p><strong>SOURCE</strong>： </p><p>从图片来源获取原始数据。</p><p>如果 DecodeJob 在 RESOURCE_CACHE 和 DATA_CACHE 阶段都没有拿到图片数据，那就会用 SourceGenerator 从图片来源获取图片数据。</p></li><li><p><strong>ENCODE</strong> ： </p><p>编码</p><p>当磁盘缓存策略设定了要对图片资源进行缓存时，那么在获取到数据后，DecodeJob 就会用 ResourceDecoder 对资源进行编码，也就是把图片放到磁盘缓存中。</p></li><li><p><strong>FINISHED</strong> ： 结束</p></li></ol><hr><h4 id="2-5-3、三种数据生成器"><a href="#2-5-3、三种数据生成器" class="headerlink" title="2.5.3、三种数据生成器"></a>2.5.3、三种数据生成器</h4><p>在DecodeJob 中调用 getNextGenerator() 方法，在不同的阶段，根据缓存策略，分别创建和使用不同的数据生成器：</p><ul><li>ResourceCacheGenerator ： 缓存数据生成器</li><li>DataCacheGenerator ： 原始缓存数据生成器</li><li>SourceGenerator： 来源数据生成器</li></ul><p>这三种数据生成器都实现了 DataFetcherGenerator 接口，同时也实现 DataFetcher.DataCallback 接口</p><p>DecodeJob 依赖于 DataFetcherGenerator接口，通过 DataFetcherGenerator.FetcherReadyCallback 回调接口来获得数据加载。</p><p>DataFetcherGenerator 会通过 ModelLoader 构建数据封装对象 LoadData ，然后通过 LoadData 中的 DataFetcher 来加载数据，此外数据生成器也实现了 DataFetcher.DataCallback 接口，用于接收 DataFetcher 的数据回调。</p><p>LoadData 是 ModelLoader 的内部类，拥有 数据来源标识符 Key 和 数据加载器 DataFetcher 两个成员变量。</p><p><strong>SourceGenerator 逻辑流程图如下</strong></p><p><img src="/../../assets/blogImg/code-analysis/Glide/glide-source-gen.jpg" alt="glide-source-gen"></p><p>步骤分析：</p><ol><li><p><strong>是否获取到了需要缓存的数据</strong></p><p>当 SourceGenerator 加载完数据后，会再次进入 startNext() 方法，这时就获取到了需要缓存的数据。</p></li><li><p><strong>是否保存原始数据</strong></p><p>如果磁盘缓存策略设定了要保存图片的原始数据，就用数据提取器加载数据，否则就直接把图片加载给 Target 。</p></li><li><p><strong>加载数据</strong></p><p>当需要保存原始数据或数据有加载路径时，SourceGenerator 就会根据 Model 的类型，使用对应的 DataFetcher 来提取数据，比如从网络上下载图</p></li><li><p><strong>是否保存原始数据</strong></p><p>当 SourceGenerator 获取到数据后，会再次判断是否要保存原始数据，否则就直接把图片加载给 Target 。</p></li><li><p><strong>编码</strong></p><p>当 SourceGenerator 从 DataFetcher 中拿到数据后，会再走一遍 startNext() 方法，然后用编码器 Encoder 对数据进行编码，也就是把图片放到磁盘缓存中。</p></li><li><p><strong>从磁盘中获取数据</strong></p><p>当 SourceGenerator 把数据保存到磁盘后，不会直接加载图片，而是从磁盘中拿这张图片，然后再进行加载。</p><hr></li></ol><h4 id="2-5-4、onResourceDecoded-变换应用"><a href="#2-5-4、onResourceDecoded-变换应用" class="headerlink" title="2.5.4、onResourceDecoded() 变换应用"></a>2.5.4、onResourceDecoded() 变换应用</h4><p>在获取到图片资源 Resource 后，最终会调用 DecodeJob.onResourceDecoded() 方法，然后应用变换选项和初始化编码管理器。</p><ul><li><p>应用变换选项</p><p>对于已经处理过变换的图片不再进行变换，否则就对图片进行变换操作</p></li><li><p>回收图片资源</p><p>当对资源应用了变换之后，DecodeJob 会把原来的资源回收掉，因为原来的图片资源用不上。</p></li><li><p>缓存变换后的图片资源</p><p>根据磁盘缓存策略判断是否要对资源进行编码，如果要编码，则根据不同的编码策略创建不同的Key。Glide 有 SOURCE 和 TRANSFORMED <strong>两种编码策略</strong>，分别对应 原始资源编码 和 变换后资源编码。</p><p><strong>SOURCE</strong> : GIF 编码器 对应GifDrawableEncoder 中用的编码策略</p><p><strong>TRANSFORMED</strong> ： 位图编码器 BitmapEncoder 中用的编码策略</p></li><li><p>初始化编码管理器</p><p>创建好 Key 后不会直接对图片进行编码，而是会修改编码管理器的 Key ，等到转码完成后再用 ResourceEncoder 进行编码。</p></li></ul><p><img src="/../../assets/blogImg/code-analysis/Glide/glide-summary-07.png" alt="glide-summary-07"></p><hr><h4 id="2-5-5、DecodeJob相关问题"><a href="#2-5-5、DecodeJob相关问题" class="headerlink" title="2.5.5、DecodeJob相关问题"></a>2.5.5、DecodeJob相关问题</h4><p>DecodeJob 会根据哪些理由来执行任务？</p><p>DecodeJob 提取数据的过程分为哪几个阶段？</p><p>DataFetcherGenerator 有哪些实现类？</p><p>Glide 有几种编码策略？</p><h2 id="三、6步图片加载"><a href="#三、6步图片加载" class="headerlink" title="三、6步图片加载"></a>三、6步图片加载</h2><p><img src="/../../assets/blogImg/code-analysis/Glide/glide-summary-08.png" alt="glide-summary-08"></p><p>在总结梳理了DecodeJob 界码流程后，接下来是图片的加载。在获取到图片后，大致经过如上图所示的6个步骤，解码、变换，转码，加载图片到 target，然后编码等。</p><p>图片的解码过程涉及以下几个概念：</p><ul><li><p><strong>数据来源（Model）</strong></p><p>Glide 会以 Model 的形式封装图片来源 ，Model 可以是 URL、本地文件和网络图片等类型。</p></li><li><p><strong>原始数据（Data）</strong></p><p>Glide 把数据源转换为Model 后，会把它加工成原始数据 Data ，一般就是输入流 InputStream ，Glide 会把这些输入流封装为 Data ，而 ModelLoader 则负责从 Data 获取原始数据。</p></li><li><p><strong>资源（Resource）</strong></p><p>获取到原始数据后，Glide 会用资源解码器 ResourceDecoder 对原始数据进行解码，比如把输入流 InputStream 解码为 Bitmap，解码后的资源就是 Resource 。</p></li><li><p><strong>变换后资源（TransformedResource）</strong></p><p>Glide 会根据我们的变换选项处理 Resource ，比如用 centerCrop() 裁剪就是一种变换，变换后的 Resource 就叫 TransformedResource ，负责转换的就是 Transformation 。</p></li><li><p><strong>转码后资源（TranscodedResource）</strong></p><p>Glide 除了能加载静态图片，还能加载 Gif 动态图，解码后的 Bitmap 和 Gif 的类型不是统一的，为了统一处理静态和动态图片，Glide 会把 Bitmap 转换为 GlideBitmapDrawable ，而负责转码的角色则是</p></li><li><p><strong>目标（Target）</strong></p><p>Glide 最终会把图片显示到目标 Target 上，比如 ImageView 对应的就是 ImageViewTarget 。</p></li></ul><h3 id="3-1、ModelLoader"><a href="#3-1、ModelLoader" class="headerlink" title="3.1、ModelLoader"></a>3.1、ModelLoader</h3><p>ModelLoader 是一个负责创建 LoadData 的接口，它有两个泛型参数 Model 和 Data。</p><ul><li><p><strong>Model</strong> 代表图片来源的类型，比如图片的网络地址的 Model 类型为 String ；</p></li><li><p><strong>Data</strong> 代表图片的原始数据的类型，比如网络图片对应的类型为 InputStream ；</p></li></ul><ol><li><p><strong>Factory</strong></p><p>在 DataFetcherGenerator 获取图片数据时，会调用 ModelLoaderRegistry 的 getModelLoaders() 方法，这个方法中会根据 model 的类型用 MultiModelLoaderFactory 生成对应的 ModelLoader，比如能够解析字符串的 ModelLoader 就有 7 个，关于 ModelLoaderRegistry 在后面讲 Glide 配置的时候会讲到。<br>此外每一个 ModelLoader 的实现类中都定义了一个实现了 ModelLoaderFactory 接口的静态内部类 。</p></li><li><p><strong>handles()</strong></p><p>一个 Model 对应这么多 ModelLoader，每个 ModelLoader 加载数据的方式都不同，这时候就要用 handles() 方法了。<br>ModelLoader 接口有 handles() 和 buildLoadData() 两个方法，handles() 用于判断某个 Model 是否能被自己处理，比如 HttpUriLoader 的 handles() 会判断传进来的字符串是否以 http 或 https 开头，是的话则可以处理。</p></li><li><p><strong>builLoadData()</strong></p><p>ModelLoader 之间是存在嵌套关系的，比如 HttpUriLoader 的 buildLoadData() 方法就是调用的 HttpGlideUrlLoader 的 buildLoadData() 方法，HttpGlideUrlLoader 会创建一个 HttpUrlFetcher ，然后把它放到 LoadData() 中。<br>LoadData 是 ModelLoader 中定义的一个类，它只是放置了图片来源的 Key 和要用来提取数据的 DataFetcher ，没有其他方法。</p></li></ol><hr><h3 id="3-2、ResourceDecoder"><a href="#3-2、ResourceDecoder" class="headerlink" title="3.2、ResourceDecoder"></a>3.2、ResourceDecoder</h3><p>DataFetcherGenerator 使用 ModelLoader 构建完数据后，就会用 DataRewinder 对数据进行重绕，也就是重置数据，比如 InputStreamRewinder 就会调用 RecyclableBufferedInputStream 的 reset() 方法重置输入流对应的字节数组的位置。<br>ResourceDecoder 是一个接口，有非常多的实现类，比如网络图片对应的解码器为 StreamBitmapDecoder ，StreamBitmapDecoder 的 decode() 方法调用了降采样器 Downsampler 的 decode() 方法，下图是 Downsampler 的解码逻辑。</p><p><img src="/../../assets/blogImg/code-analysis/Glide/glide-summary-09.png" alt="glide-summary-09"></p><ol><li><p>设置目标宽高<br> 除非我们通过 override() 方法把尺寸改为 Target.SIZE_ROGINAL ，否则 Glide 默认会把 ImageView 的大小作为加载图片的目标宽高。</p></li><li><p>计算缩放后宽高<br> 根据不同的变换选项计算缩放后宽高。</p></li><li><p>创建空 Bitmap<br> 根据计算后的目标宽高创建一个空的 Bitmap 。</p></li><li><p>使用 BitmapFactory 解码</p><p>Downsampler 的解码方式用的是 ImageReader 的 decodeBitmap() 方法，而 ImageReader 又调用了 BitmapFactory 的 decodeStream() 方法，BitmapFactory 最终调用的是 SkImageDecoder 的 decode() 方法。</p></li><li><p>把 Bitmap 放入 BitmapPool 中<br>在前面讲 Resource 的时候讲到了 BitmapResource 中有一个 BitmapPool，这个 BitmapPool 是由 Downsampler 传过去的，而 Downsampler 的 BitmapPool 是由 Glide 创建并传进来的。</p></li></ol><p><img src="/../../assets/blogImg/code-analysis/Glide/glide-summary-10.png" alt="glide-summary-10"></p><hr><h3 id="3-3、Transformation"><a href="#3-3、Transformation" class="headerlink" title="3.3、Transformation"></a>3.3、Transformation</h3><p>Transformation 是一个接口，它有一个 transform() 方法，这个方法是在 DecodeJob 中调用的，当 DecodeJob 发现数据源不是缓存中的 Resource 时，就会调用变换选项的 transform() 方法。<br>Transformation 的其中一个实现类是 BitmapTransformation，我们平时调用的 centerCrop() 就是 BitmapTransformation 的子类，centerCrop() 选项对应的是 CenterCrop 类，它实现了 Transformation 接口，具体的变换实现在 TransformationUtils 中。</p><p><strong>Matrix</strong></p><p>以 centerCrop() 为例，TransformationUtils 的 centerCrop() 方法会先创建一个 Matrix 矩阵，然后根据传进来的 Bitmap 计算 Matrix 的缩放比例和平移坐标。</p><p><strong>drawBitmap()</strong></p><p>配置好 Matrix 后，就会根据目标宽高创建一个空的目标 Bitmap ，然后把原始 Bitmap、目标 Bitmap 和 Matrix 传给 Canvas 的 drawBitmap() 方法，然后返回 Canvas 处理好的图片。</p><hr><h3 id="3-4、ResouceTranscoder"><a href="#3-4、ResouceTranscoder" class="headerlink" title="3.4、ResouceTranscoder"></a>3.4、ResouceTranscoder</h3><p>ResourceTranscoder 是一个接口，是 Glide 中的资源转码器，它有两个泛型参数 Z 和 R ，分别代表需要进行原始类型和转码目标类型。</p><p>比如 BitmapDrawableTranscoder 的原始类型是 Bitmap，转码目标类型是 BitmapDrawable，在BitmapDrawableTranscoder 的 transcode() 方法中，会把 Bitmap 转换为 BitmapDrawable ，以便 Target 进行处理。</p><hr><h3 id="2-5、ResourceEncoder"><a href="#2-5、ResourceEncoder" class="headerlink" title="2.5、ResourceEncoder"></a>2.5、ResourceEncoder</h3><p>ResourceEncoder 是一个接口，是 Glide 中的资源编码器，ResourceEncoder 有好几个实现类，比如网络图片对应的编码器为 StreamEncoder。</p><p>在转码完成后，DecodeJob 会先把图片加载到 Target 中，然后用 ResourceEncoder 对图片进行编码，比如 StreamEncoder 的编码操作就是把输入流 InputStream 转化为图片文件，然后保存到本地。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是在查看源码后然后根据前辈的总结，然后做出关于 Glide 加载图片流程的总结整理。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://cxinxian.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Glide 源码分析</title>
    <link href="http://cxinxian.github.io/2021/11/29/code-analysis/Glide/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://cxinxian.github.io/2021/11/29/code-analysis/Glide/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2021-11-29T11:47:01.000Z</published>
    <updated>2025-02-21T14:38:42.384Z</updated>
    
    <content type="html"><![CDATA[<p>Glide 是google 开源的 Android 端图片加载库，能够帮助我们下载、缓存、展示多种格式图片，使用简单，在 Gradle 添加依赖后，只需简单的几行代码便可实现图片的加载显示 ，使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context).load(url).into(imageview)</span><br></pre></td></tr></table></figure><p>本次源码分析基于 <strong>Glide 4.8</strong> 版本  </p><span id="more"></span><h2 id="一、with-xxx"><a href="#一、with-xxx" class="headerlink" title="一、with(xxx)"></a>一、with(xxx)</h2><p>顺着代码往下看，在<code>Glide.java </code>类中，<code>with </code> 方法有多个重载，分别接收的入参有：<code>Context、Activity、FragmentActivity、Fragment、View</code>分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title function_">with</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(context).get(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title function_">with</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title function_">with</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity activity)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title function_">with</span><span class="params">(<span class="meta">@NonNull</span> Fragment fragment)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title function_">with</span><span class="params">(<span class="meta">@NonNull</span> android.app.Fragment fragment)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title function_">with</span><span class="params">(<span class="meta">@NonNull</span> View view)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(view.getContext()).get(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>with(xxx)</code>方法中，调用 <code>getRetriever()</code>，获取 <code>RequestManager</code> 实例之前，会通过 <code>Glide.java</code> 的 <code>get(context)</code> 方法获取 <code>Glide</code> 实例 ，其中 Glide 实例化时，是通过 <code>initializeGlide</code> 函数实例化，并且会读取 <code>AppGlideModule</code> 和 <code>AndroidMainfest.xml</code> 的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> RequestManagerRetriever <span class="title function_">getRetriever</span><span class="params">(<span class="meta">@Nullable</span> Context context)</span> &#123;</span><br><span class="line">    <span class="comment">// Context could be null for other reasons (ie the user passes in null), but in practice it will</span></span><br><span class="line">    <span class="comment">// only occur due to errors with the Fragment lifecycle.</span></span><br><span class="line">    Preconditions.checkNotNull(</span><br><span class="line">        context,</span><br><span class="line">        <span class="string">&quot;You cannot start a load on a not yet attached View or a Fragment where getActivity() &quot;</span></span><br><span class="line">            + <span class="string">&quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot;</span></span><br><span class="line">            + <span class="string">&quot;is attached or after the Fragment is destroyed).&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="1-1、RequestManagerRetriever"><a href="#1-1、RequestManagerRetriever" class="headerlink" title="1.1、RequestManagerRetriever"></a>1.1、RequestManagerRetriever</h3><p><strong>RequestManagerRetriever</strong> 是创建 <code>RequestManager</code> 实例的静态方法集合，或者从现有的 Activity&#x2F;Fragment 取出已经关联的 <code>RequestManager</code> 实例。</p><p><code>getRetriever(context)</code>  方法获取的是 <code>RequestManagerRetriever</code> 实例，<code>RequestManagerRetriever</code> 实例是在<code>initializeGlide</code> 中通过 <code>GlideBuilder.build</code>  实例化，调用 <code>getRetriever</code> 方法返回的是已经实例化好了的对象。</p><p>RequestManagerRetriever 有好几个 get 方法，可以根据 Context、Fragment、Activity、view 等不同生命周期创建 <code>RequestManagerFragment</code> ,RequestManagerFragment 实现对各个组件生命周期的自动感知。接着创建 <code>RequestManager</code>,并与 RequestManagerFragment  绑定。</p><p>其中<code>getRetriever(context).get(context)</code> 返回的是一个<code>RequestManager</code> 实例 ，它是在 <code>RequestManagerRetriever</code> 的<code>get(context)</code> 方法实例化。通过代码可以看出，Glide 的和Activity&#x2F;Fragment 的生命周期监听是通过我们看不见的 <code>SupportRequestManagerFragment</code> 或者 <code>RequestManagerFragment</code>进行监听的。然后通过一个 <code>Lifecycle</code> 来进行生命周期状态的改变通知，其实就是很关键的 <code>ActivityFragmentLifecycle</code> 或者 <code>ApplicationLifecycle</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> RequestManager <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;You cannot start a load on a null Context&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((Activity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以很明显的发现，如果传入的 <code>context</code>是<code>ApplicationContext</code>, 使用的为<code>ApplicationLifecycle</code>, 如果是 view &#x2F; Activity &#x2F; Fragment 使用的是 <code>ActivityFragmentLifecycle</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> RequestManager <span class="title function_">getApplicationManager</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">  <span class="comment">// Either an application context or we&#x27;re on a background thread.</span></span><br><span class="line">  <span class="keyword">if</span> (applicationManager == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (applicationManager == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Normally pause/resume is taken care of by the fragment we add to the fragment or</span></span><br><span class="line">        <span class="comment">// activity. However, in this case since the manager attached to the application will not</span></span><br><span class="line">        <span class="comment">// receive lifecycle events, we must force the manager to start resumed using</span></span><br><span class="line">        <span class="comment">// ApplicationLifecycle.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class="line">        <span class="type">Glide</span> <span class="variable">glide</span> <span class="operator">=</span> Glide.get(context.getApplicationContext());</span><br><span class="line">        applicationManager =</span><br><span class="line">            factory.build(</span><br><span class="line">                glide,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ApplicationLifecycle</span>(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">EmptyRequestManagerTreeNode</span>(),</span><br><span class="line">                context.getApplicationContext());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> applicationManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;deprecation&quot;, &quot;DeprecatedIsStillUsed&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> RequestManager <span class="title function_">fragmentGet</span><span class="params">(<span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> android.app.FragmentManager fm,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> android.app.Fragment parentHint,</span></span><br><span class="line"><span class="params">    <span class="type">boolean</span> isParentVisible)</span> &#123;</span><br><span class="line">  <span class="type">RequestManagerFragment</span> <span class="variable">current</span> <span class="operator">=</span> getRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">  <span class="type">RequestManager</span> <span class="variable">requestManager</span> <span class="operator">=</span> current.getRequestManager();</span><br><span class="line">  <span class="keyword">if</span> (requestManager == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class="line">    <span class="type">Glide</span> <span class="variable">glide</span> <span class="operator">=</span> Glide.get(context);</span><br><span class="line">    requestManager =</span><br><span class="line">        factory.build(</span><br><span class="line">            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">    current.setRequestManager(requestManager);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> RequestManagerFragment <span class="title function_">getRequestManagerFragment</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> <span class="keyword">final</span> android.app.FragmentManager fm,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> android.app.Fragment parentHint,</span></span><br><span class="line"><span class="params">    <span class="type">boolean</span> isParentVisible)</span> &#123;</span><br><span class="line">    <span class="type">RequestManagerFragment</span> <span class="variable">current</span> <span class="operator">=</span> (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">        current = pendingRequestManagerFragments.get(fm);</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">            current = <span class="keyword">new</span> <span class="title class_">RequestManagerFragment</span>();</span><br><span class="line">            current.setParentFragmentHint(parentHint);</span><br><span class="line">            <span class="keyword">if</span> (isParentVisible) &#123;</span><br><span class="line">                current.getGlideLifecycle().onStart();</span><br><span class="line">            &#125;</span><br><span class="line">            pendingRequestManagerFragments.put(fm, current);</span><br><span class="line">            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">            handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有代码可知，<strong>RequestManagerRetriever</strong> 创建 <strong>RequestManager</strong> 的流程大致如下：</p><ul><li><p>如果在子线程中，则创建一个生命周期与Application 一样的 RequestManager</p></li><li><p>根据 Context 或者 View 拿到其所属的 fragment 或者 Activity</p></li><li><p>从当前 Fragment、Activity 取出 RequestManagerManagerFragment，如果 RequestManagerFragment 不为空则取出关联的 RequestManager；如果为空，则创建一个新的 RequestManagerFragment ，顺便创建一个新的 RequestManager 并将二者关联起来。</p><ul><li><p>问题1：为什么要使用 **pendingRequestManagerFragments ** 来添加 RequestManagerFragment？在 fm 添加后又通过 handler 发送消息将 RequestManagerFragment 重 pendingRequestManagerFragments 中移除？</p><blockquote><p>回答：因为 fm 添加 RequestManagerFragment 不是 add 方法调用就之后就完成了，它有相关生命周期是异步进行的，如果在 add 之后又在相同的 activity 或 fragment 环境中调用get 方法，那么就很有可能有创建一个新的 RequestManagerFragment，而 pendingRequestManagerFragments  就是为了防止重新创建 RequestManagerFragment 而准备的。</p></blockquote></li><li><p>问题2：Glide 的get 使用有什么优化的地方？</p><p>尽量不在子线程中调用，如果在子线程中调用，意味着生命周期是全局的，不能跟activity 或 fragment 声明周期同步。get的时候最好使用 activity 或 fragment ，这样可以减少查找具体 fragment 的或者 activity  的步骤。</p></li></ul></li></ul><h3 id="1-2、RequestManagerFragment、SupportRequestManagerFragment"><a href="#1-2、RequestManagerFragment、SupportRequestManagerFragment" class="headerlink" title="1.2、RequestManagerFragment、SupportRequestManagerFragment"></a>1.2、RequestManagerFragment、SupportRequestManagerFragment</h3><p>这两个类都是没有界面的 Fragment，用于安全地保存所属Activity&#x2F;Fragment的 RequstManager，RequestManager可以用于启动、暂停和管理Glide。</p><p>当我们在使用 Glide.with(xxx)时，传入的 context 时，通过<code>RequestManagerRetriever</code>这个桥梁与Activity&#x2F;Fragment进行绑定，其中会判断是否是Activity、Fragment、View、或者 Application类型的 Context，然后把 RequestManagerFragment、SupportRequestManagerFragment 实例化并附加到相应的Activity&#x2F;Fragment。</p><p>在 RequestManagerFragment 内部，实例化了 ActivityFragmentLifecycle ，通过它，可以把生命周期事件传递给 <code>RequestManager</code>或者<code>ConnectivityMonitor</code>。</p><h3 id="1-3、Lifecycle、LifecycleListener"><a href="#1-3、Lifecycle、LifecycleListener" class="headerlink" title="1.3、Lifecycle、LifecycleListener"></a>1.3、Lifecycle、LifecycleListener</h3><p>Lifecycle 和 LifecycleListener 作为一个监听 <strong>Activity&#x2F;Fragment</strong> Lifecycle 的接口，其中 Lifecycle 的实现类有 <strong>ApplicationLifecycle、ActivityFragmentLifecycle</strong> </p><p>Lifecycle 有两个接口方法，分别负责把入参中给定的 LifecycleListener 添加到一个 listener 集合中或者从集合中移除。</p><p>从 <code>ActivityFragmentLifecycle</code> 的源码可以看到，其内部有<code>onStart()、onStop、onDestroy()</code> 等几个成员方法，与上面提到的 <code>RequestManagerFragment、SupportRequestManagerFragment</code> 对应的方法关联，当Fragment 的生命周期方法被调用时，<code>ActivityFragmentLifecycle</code> 相应的方法也就会被调用，从而遍历其内部的 <code>LifecycleListener</code> 集合通知到具体的实例，最后实现Glide图片的加载、停止或者销毁与Activity&#x2F;Fragment 的生命周期同步。</p><p>ActivityFragmentLifecycle 内部维持了一个监听者列表，当 RequestManagerFragment 生命周期变化时，通过遍历列表，通知监听者对应的方法。</p><blockquote><p>监听者在什么时候被添加到 ActivityFragmentLifecycle 的监听者列表呢？</p><p>答：是在创建 RequestManager 的时候</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">RequestManager(</span><br><span class="line">    Glide glide,</span><br><span class="line">    Lifecycle lifecycle,</span><br><span class="line">    RequestManagerTreeNode treeNode,</span><br><span class="line">    RequestTracker requestTracker,</span><br><span class="line">    ConnectivityMonitorFactory factory,</span><br><span class="line">    Context context) &#123;</span><br><span class="line">  <span class="built_in">this</span>.glide = glide;</span><br><span class="line">  <span class="built_in">this</span>.lifecycle = lifecycle;</span><br><span class="line">  <span class="built_in">this</span>.treeNode = treeNode;</span><br><span class="line">  <span class="built_in">this</span>.requestTracker = requestTracker;</span><br><span class="line">  <span class="built_in">this</span>.context = context;</span><br><span class="line"></span><br><span class="line">  connectivityMonitor =</span><br><span class="line">      factory.build(</span><br><span class="line">          context.getApplicationContext(),</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">RequestManagerConnectivityListener</span>(requestTracker));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we&#x27;re the application level request manager, we may be created on a background thread.</span></span><br><span class="line">  <span class="comment">// In that case we cannot risk synchronously pausing or resuming requests, so we hack around the</span></span><br><span class="line">  <span class="comment">// issue by delaying adding ourselves as a lifecycle listener by posting to the main thread.</span></span><br><span class="line">  <span class="comment">// This should be entirely safe.</span></span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">    mainHandler.post(addSelfToLifecycle);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lifecycle.addListener(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  lifecycle.addListener(connectivityMonitor);</span><br><span class="line"></span><br><span class="line">  setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());</span><br><span class="line"></span><br><span class="line">  glide.registerRequestManager(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、load-xxx-into-imageview"><a href="#二、load-xxx-into-imageview" class="headerlink" title="二、load(xxx).into(imageview)"></a>二、load(xxx).into(imageview)</h2><h3 id="2-1、RequestManager"><a href="#2-1、RequestManager" class="headerlink" title="2.1、RequestManager"></a>2.1、RequestManager</h3><p>这是一个负责管理和启动 Glide 请求的类，可以使用 Acitivity&#x2F;Fragment 和 connectivity 生命周期事件去智能的开始、停止和重启请求。</p><p>我们常用的 load 方法就是在这个类中，load() 有多个重载方法。入参可以是<code>Bitmap、Drawable、url、本地uri、File、assert资源id </code> 等等。这些方法中都调用了<code>asDrawable()</code> 方法，返回<code>RequestBuilder</code> 对象，然后调用 <code>RequestBuilder</code> 的<code>load(xx)</code> 方法。</p><p>接下来将重点关注 <code>asDrawable()、as()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to always load the resource using any registered &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * com.bumptech.glide.load.ResourceDecoder&#125;s that can decode any subclass of &#123;<span class="doctag">@link</span> Drawable&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; By default, may return either a &#123;<span class="doctag">@link</span> android.graphics.drawable.BitmapDrawable&#125; or &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * GifDrawable&#125;, but if additional decoders are registered for other &#123;<span class="doctag">@link</span> Drawable&#125; subclasses,</span></span><br><span class="line"><span class="comment"> * any of those subclasses may also be returned. &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A new request builder for loading a &#123;<span class="doctag">@link</span> Drawable&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@CheckResult</span></span><br><span class="line"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title function_">asDrawable</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Attempts to load the resource using any registered</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> com.bumptech.glide.load.ResourceDecoder&#125;s</span></span><br><span class="line"><span class="comment">   * that can decode the given resource class or any subclass of the given resource class.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> resourceClass The resource to decode.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> A new request builder for loading the given resource class.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@CheckResult</span></span><br><span class="line">  <span class="keyword">public</span> &lt;ResourceType&gt; RequestBuilder&lt;ResourceType&gt; <span class="title function_">as</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="meta">@NonNull</span> Class&lt;ResourceType&gt; resourceClass)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestBuilder</span>&lt;&gt;(glide, <span class="built_in">this</span>, resourceClass, context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过代码可知，在 <code>as(resourceClass)</code> 方法中，实例化 <code>RequestBuilder</code></p><h3 id="2-2、RequestBuilder"><a href="#2-2、RequestBuilder" class="headerlink" title="2.2、RequestBuilder"></a>2.2、RequestBuilder</h3><p>RequestBuilder 作为一个泛型类，可以处理泛型资源类型的设置选项和启动加载。</p><p>在RequestBuilder 的一系列 <code>load()</code> 重载方法中，最终调用的方法为 <code>loadGeneric</code>、<code>apply</code> </p><p>下面选取 <code>load(String string)</code> 来看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CheckResult</span></span><br><span class="line"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title function_">load</span><span class="params">(<span class="meta">@Nullable</span> String string)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> loadGeneric(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title function_">loadGeneric</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.model = model;</span><br><span class="line">   isModelSet = <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码看，<code>loadGeneric</code> 方法是作为加载图片前的准备, 把 <code>load</code> 入参赋值给一个成员变量 model, 并设置 isModelSet &#x3D; true, 表示入参源数据已经赋值给 model </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title function_">into</span><span class="params">(<span class="meta">@NonNull</span> ImageView view)</span> &#123;</span><br><span class="line">  <span class="comment">// 判断如果不是在主线程，则抛出异常</span></span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  Preconditions.checkNotNull(view);</span><br><span class="line"></span><br><span class="line">  <span class="type">RequestOptions</span> <span class="variable">requestOptions</span> <span class="operator">=</span> <span class="built_in">this</span>.requestOptions;</span><br><span class="line">  <span class="keyword">if</span> (!requestOptions.isTransformationSet()</span><br><span class="line">      &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">      &amp;&amp; view.getScaleType() != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// requestOptions.clone() 克隆这个方法，以便在使用 RequestBuilder 加载到一个视图中，然后加载到其他目标中，</span></span><br><span class="line">    <span class="comment">//  不会保留基于上一个视图的转换缩放类型信息，根据view 的缩放转换类型实时设置对应的选项参数。</span></span><br><span class="line">    <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CENTER_INSIDE:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">      <span class="keyword">case</span> FIT_START:</span><br><span class="line">      <span class="keyword">case</span> FIT_END:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_XY:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CENTER:</span><br><span class="line">      <span class="keyword">case</span> MATRIX:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用另一个重载方法,通过 GlideContext 的buildImageViewTarget 方法将 ImageView 包装并且返回ViewTarget实例，</span></span><br><span class="line">  <span class="comment">// ViewTarget 属于 Target 的子类。</span></span><br><span class="line">  <span class="keyword">return</span> into(</span><br><span class="line">      glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">      <span class="comment">/*targetListener=*/</span> <span class="literal">null</span>,</span><br><span class="line">      requestOptions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;Y <span class="keyword">extends</span> <span class="title class_">Target</span>&lt;TranscodeType&gt;&gt; Y <span class="title function_">into</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="meta">@NonNull</span> Y target,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span><br><span class="line"><span class="params">      <span class="meta">@NonNull</span> RequestOptions options)</span> &#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    Preconditions.checkNotNull(target);</span><br><span class="line">    <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;You must call #load() before calling #into()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自动克隆选项信息</span></span><br><span class="line">    options = options.autoClone();</span><br><span class="line">    <span class="comment">// 构建 Request 请求</span></span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> buildRequest(target, targetListener, options);</span><br><span class="line"></span><br><span class="line">    <span class="type">Request</span> <span class="variable">previous</span> <span class="operator">=</span> target.getRequest();</span><br><span class="line">    <span class="keyword">if</span> (request.isEquivalentTo(previous)</span><br><span class="line">        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">      request.recycle();</span><br><span class="line">      <span class="comment">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class="line">      <span class="comment">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class="line">      <span class="comment">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class="line">      <span class="comment">// running, we can let it continue running without interruption.</span></span><br><span class="line">      <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">        <span class="comment">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class="line">        <span class="comment">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span></span><br><span class="line">        <span class="comment">// that are done in the individual Request.</span></span><br><span class="line">          <span class="comment">// 存在是同样的请求，则复用上一个请求</span></span><br><span class="line">        previous.begin();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除资源</span></span><br><span class="line">    requestManager.clear(target);</span><br><span class="line">    <span class="comment">// 把 request 绑定到 target上</span></span><br><span class="line">    target.setRequest(request);</span><br><span class="line">    <span class="comment">// 执行 request</span></span><br><span class="line">    requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">track</span><span class="params">(<span class="meta">@NonNull</span> Target&lt;?&gt; target, <span class="meta">@NonNull</span> Request request)</span> &#123;</span><br><span class="line">    targetTracker.track(target);</span><br><span class="line">    requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>into(xxx)</code> 有三个重载方法，上面只贴出关键的两个重载方法。在<code>RequestOptions</code> 设置选项上首先是先拷贝一个备份，然后在备份的 RequestOptions 上设置新的设置选项。</p><p><code>GlideContext.buildImageViewTarget</code> 调用 <code>ImageViewTargetFactory.buildTarget</code>可以根据不同图片类型，分别对应的实现 <code>DrawableImageViewTarget</code> 、<code>BitmapImageViewTarget</code>实例,它们都继承于泛型类<code>ImageViewTarget&lt;Z&gt;</code>，间接继承于 <code>ViewTarget&lt;T extends View, Z&gt;</code>，实现了<code>Target&lt;R&gt;、LifecycleListener</code>接口， 用于在 Request 加载完成图片后接受并且把图片展示到 ImageView。</p><blockquote><p>在 ViewTarget 中比较重要的地方是，其内部类SizeDeterminerLayoutListener实现了 ViewTreeObserver.OnPreDrawListener 接口，用于监听 ImageView 在屏幕上绘制之前执行一下操作，调用的方法有：</p><p>SizeDeterminer.checkCurrentDimens() -&gt; notifyCbs() -&gt; SingleRequest.onSizeReady()</p><p>最后 在onSizeReady 方法中会触发engin.load 去加载图片。</p><p>关于 onSizeReady 方法，在后面会说到。</p></blockquote><p>在构建完 Request 后，会先取消之前的任务资源，然后在把request 绑定到 target 上。最后调用 <code>request.tartk</code> 方法， 把 target、request 添加到追踪队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TargetTracker</span> <span class="keyword">implements</span> <span class="title class_">LifecycleListener</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Target&lt;?&gt;&gt; targets =</span><br><span class="line">      Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;Target&lt;?&gt;, Boolean&gt;());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">track</span><span class="params">(<span class="meta">@NonNull</span> Target&lt;?&gt; target)</span> &#123;</span><br><span class="line">    targets.add(target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">untrack</span><span class="params">(<span class="meta">@NonNull</span> Target&lt;?&gt; target)</span> &#123;</span><br><span class="line">    targets.remove(target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Target&lt;?&gt; target : Util.getSnapshot(targets)) &#123;</span><br><span class="line">      target.onStart();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Target&lt;?&gt; target : Util.getSnapshot(targets)) &#123;</span><br><span class="line">      target.onStop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Target&lt;?&gt; target : Util.getSnapshot(targets)) &#123;</span><br><span class="line">      target.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;Target&lt;?&gt;&gt; getAll() &#123;</span><br><span class="line">    <span class="keyword">return</span> Util.getSnapshot(targets);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    targets.clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>targets 保存了当前 activity&#x2F;fragment 的所有 target， 同时和相应的生命周期做了绑定。</p><p>在<code>RequestTracker</code> 中，<code>runRequest</code> 方法调用了 <code>SingleRequest.begin</code>执行了最终的图片资源加载操作。</p><h3 id="2-3、SingleRequest"><a href="#2-3、SingleRequest" class="headerlink" title="2.3、SingleRequest"></a>2.3、SingleRequest<R></h3><p>SingleRequest 一个加载图片资源到给定 target 的请求，起到图片资源加载 engin  和 target 的桥梁作用。</p><h4 id="2-3-1、begin"><a href="#2-3-1、begin" class="headerlink" title="2.3.1、begin"></a>2.3.1、begin</h4><p>在 <code>begin</code> 方法中，会先判断 model ，然后判断 status 状态。如果model 为空或者 status 为 RUNNING 状态都会抛出异常信息，提示错误。</p><h4 id="2-3-2、onSizeReady"><a href="#2-3-2、onSizeReady" class="headerlink" title="2.3.2、onSizeReady"></a>2.3.2、onSizeReady</h4><p>onSizeReady 的调用是在 ImageView 绘制到屏幕之前执行。具体在 <code>ViewTarget.notifyCbs()</code> 方法中执行。</p><p>在获取到view 的宽高后，调用 <code>Engine.load</code> 方法执行图片资源加载。</p><h3 id="2-4、Engine-图片加载引擎"><a href="#2-4、Engine-图片加载引擎" class="headerlink" title="2.4、Engine 图片加载引擎"></a>2.4、Engine 图片加载引擎</h3><p>Engine 在 GlideBuilder 的build 方法中实例化，然后在 GlideContext 实例化时，保存在 GlideContext 的内部私有成员变量中，而Glide 单例持有 GlideContext 引用。</p><p>Engin 是Glide 的图片加载引擎，主要承担图片的加载工作，是 Glide 中非常重要的一个类</p><p>Engine 类实现了一下几个接口</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EngineJobListener&#123;</span><br><span class="line">    <span class="comment">// 加载任务回调</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onEngineJobComplete</span><span class="params">(EngineJob&lt;?&gt; engineJob, Key key, EngineResource&lt;?&gt; resource)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onEngineJobCancelled</span><span class="params">(EngineJob&lt;?&gt; engineJob, Key key)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MemoryCache</span>.ResourceRemovedListener&#123;</span><br><span class="line"><span class="comment">// bitmap 位图从缓存中移除回调</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onResourceRemoved</span><span class="params">(<span class="meta">@NonNull</span> Resource&lt;?&gt; removed)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">EngineResource</span>.ResourceListener&#123;</span><br><span class="line"><span class="comment">// 资源释放回调方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onResourceReleased</span><span class="params">(Key key, EngineResource&lt;?&gt; resource)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>Engine 执行图片加载主要是<code> load</code> 方法，在 load 方法中，会通过<code> EngineKeyFactory.build</code> 方法创建一个图片资源标识符 <code>EngineKey</code> 实例 key，然后通过这个key 去活跃的内存缓存 <code>ActiveResources</code> 中查找，如果查找到则返回 Resouce，否则继续从 <code>LruResourceCache</code> 最近最少使用内存缓存中查找。如果查找不到则再创建并启用新的  EnginJob 和解码任务 DecodeJob。</p><p>在Glide 中，缓存分为内存缓存和磁盘缓存</p><p><strong>内存缓存</strong> 又分为以下两级：</p><ul><li>活跃的内存缓存对应 ActiveResources</li><li>最近最少使用缓存 LruResourceCache</li></ul><p><strong>磁盘缓存</strong> 分为以下两级：</p><ul><li>处理过的图片数据缓存，对应缓存处理类为 ResourceCacheGenerator</li><li>未处理过的源图片数据缓存，对应的处理类为： DataCacheGenerator</li></ul><h4 id="2-4-1、DecodeJob"><a href="#2-4-1、DecodeJob" class="headerlink" title="2.4.1、DecodeJob"></a>2.4.1、DecodeJob</h4><p>DecodeJob 主要负责从缓存数据或者原始源数据资源解码，并且应用转换和转码。</p><p>在 DecodeJob 中，其主要方法为 <code>runWrapped()</code> ，runWrapped 会根据以下三个理由来执行解码任务。</p><ul><li><strong>INITIALIZE</strong> ：首次执行初始状态，将会尝试依次从内存缓存-&gt;磁盘缓存-&gt;原始数据源来获取要加载的图片数据</li><li><strong>SWITCH_TO_SOURCE_SERVICE</strong>：当从缓存或磁盘中获取不到数据时，从缓存服务中切换到原始数据源中执行获取数据</li><li><strong>DECODE_DATA</strong>：获取图片数据和 DecodeJob 不在同一个线程时，切换回 DecodeJob 线程码数据。调用 decodeFromRetrievedData() 方法来对检索到的数据进行解码</li></ul><p>在 getNextState() 方法中，根据当前的解码步骤来判断下一步应该执行的步骤，总共分为 6 个阶段，这两个阶段是 State 枚举类中的值，分别如下：</p><ol><li><p><strong>INITIALIZE</strong> :</p><p> 初始化，默认状态。</p><p>最开始解码处于这个状态，然后 DecodeJob 会根据缓存策略，<u>判断是否要从磁盘中获取处理过图片数据缓存资源</u>，如果是，则 生成 <code>ResourceCacheGenerator</code> 实例获取图片资源。如果获取到数据，则进行解码。如果获取不到处理过的图片数据资源，那么就切换到下一个解码阶段 RESOURCE_CACHE。</p></li><li><p><strong>RESOURCE_CACHE</strong>：</p><p>从磁盘缓存中获取处理过的图片，其对应的缓存资源Generator 为 <code>ResourceCacheGenera</code>。</p><p>当解码处于当前阶段时， DecodeJob 会根据缓存策略<u>判断是否要从磁盘中获取 未处理过的图片数据</u>，如果是的话就用 DataCacheGenerator获取数据。</p></li><li><p><strong>DATA_CACHE</strong>：</p><p>从缓存中获取原始（未处理过的）数据。</p><p>当处于该阶段时，如果在加载图片时调用了 onlyRetrieveFromCache(true) ，那么就不会切换到 SOURCE 阶段从来源获取数据，而直接切换的 FINISHED 阶段结束解码流程。</p></li><li><p><strong>SOURCE</strong>： </p><p>从图片来源获取原始数据。</p><p>如果 DecodeJob 在 RESOURCE_CACHE 和 DATA_CACHE 阶段都没有拿到图片数据，那就会用 SourceGenerator 从图片来源获取图片数据。</p></li><li><p><strong>ENCODE</strong> ： </p><p>编码</p><p>当磁盘缓存策略设定了要对图片资源进行缓存时，那么在获取到数据后，DecodeJob 就会用 ResourceDecoder 对资源进行编码，也就是把图片放到磁盘缓存中。</p></li><li><p><strong>FINISHED</strong> ： 结束</p></li></ol><p>在DecodeJob 中调用 getNextGenerator() 方法，在不同的阶段，根据缓存策略，分别创建和使用不同的数据生成器：</p><ul><li>ResourceCacheGenerator ： 缓存数据生成器</li><li>DataCacheGenerator ： 原始缓存数据生成器</li><li>SourceGenerator： 来源数据生成器</li></ul><p>这三种数据生成器都实现了 DataFetcherGenerator 接口，同时也实现 DataFetcher.DataCallback 接口</p><p>DecodeJob 依赖于 DataFetcherGenerator接口，通过 DataFetcherGenerator.FetcherReadyCallback 回调接口来获得数据加载。</p><p>DataFetcherGenerator 会通过 ModelLoader 构建数据封装对象 LoadData ，然后通过 LoadData 中的 DataFetcher 来加载数据，此外数据生成器也实现了 DataFetcher.DataCallback 接口，用于接收 DataFetcher 的数据回调。</p><p>LoadData 是 ModelLoader 的内部类，拥有 数据来源标识符 Key 和 数据加载器 DataFetcher 两个成员变量。</p><p><strong>SourceGenerator 逻辑流程图如下</strong></p><p><img src="/../../assets/blogImg/code-analysis/Glide/glide-source-gen.jpg" alt="glide-source-gen"></p><p>步骤分析：</p><ol><li><p><strong>是否获取到了需要缓存的数据</strong></p><p>当 SourceGenerator 加载完数据后，会再次进入 startNext() 方法，这时就获取到了需要缓存的数据。</p></li><li><p><strong>是否保存原始数据</strong></p><p>如果磁盘缓存策略设定了要保存图片的原始数据，就用数据提取器加载数据，否则就直接把图片加载给 Target 。</p></li><li><p><strong>加载数据</strong></p><p>当需要保存原始数据或数据有加载路径时，SourceGenerator 就会根据 Model 的类型，使用对应的 DataFetcher 来提取数据，比如从网络上下载图</p></li><li><p><strong>是否保存原始数据</strong></p><p>当 SourceGenerator 获取到数据后，会再次判断是否要保存原始数据，否则就直接把图片加载给 Target 。</p></li><li><p><strong>编码</strong></p><p>当 SourceGenerator 从 DataFetcher 中拿到数据后，会再走一遍 startNext() 方法，然后用编码器 Encoder 对数据进行编码，也就是把图片放到磁盘缓存中。</p></li><li><p><strong>从磁盘中获取数据</strong></p><p>当 SourceGenerator 把数据保存到磁盘后，不会直接加载图片，而是从磁盘中拿这张图片，然后再进行加载。</p></li></ol><h4 id="2-4-2、DecodeJob-onResourceDecoded"><a href="#2-4-2、DecodeJob-onResourceDecoded" class="headerlink" title="2.4.2、DecodeJob.onResourceDecoded()"></a>2.4.2、DecodeJob.onResourceDecoded()</h4><p>在获取到图片资源 Resource 后，最终会调用 DecodeJob.onResourceDecoded() 方法，然后应用变换选项和初始化编码管理器。</p><ul><li><p>应用变换选项</p><p>对于已经处理过变换的图片不再进行变换，否则就对图片进行变换操作</p></li><li><p>回收图片资源</p><p>当对资源应用了变换之后，DecodeJob 会把原来的资源回收掉，因为原来的图片资源用不上。</p></li><li><p>缓存变换后的图片资源</p><p>根据磁盘缓存策略判断是否要对资源进行编码，如果要编码，则根据不同的编码策略创建不同的Key。Glide 有 SOURCE 和 TRANSFORMED 两种编码策略，分别对应 原始资源编码 和 变换后资源编码。</p><p><strong>SOURCE</strong> : GIF 编码器 对应GifDrawableEncoder 中用的编码策略</p><p><strong>TRANSFORMED</strong> ： 位图编码器 BitmapEncoder 中用的编码策略</p></li><li><p>初始化编码管理器</p><p>创建好 Key 后不会直接对图片进行编码，而是会修改编码管理器的 Key ，等到转码完成后再用 ResourceEncoder 进行编码。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Glide 是google 开源的 Android 端图片加载库，能够帮助我们下载、缓存、展示多种格式图片，使用简单，在 Gradle 添加依赖后，只需简单的几行代码便可实现图片的加载显示 ，使用如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Glide.with(context).load(url).into(imageview)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;本次源码分析基于 &lt;strong&gt;Glide 4.8&lt;/strong&gt; 版本  &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://cxinxian.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 源码解析</title>
    <link href="http://cxinxian.github.io/2021/11/17/code-analysis/Glide/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://cxinxian.github.io/2021/11/17/code-analysis/Glide/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2021-11-17T07:32:11.000Z</published>
    <updated>2025-02-21T14:40:40.342Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap 的底层数据结构：散列表 + 红黑树。关于散列表，采用拉链法处理hash冲突，其中通过引入红黑树来提升效率。</p><span id="more"></span><p><img src="/../../assets/blogImg/code-analysis/Glide/hashmap-01.png" alt="hashmap-01"></p><p>数组+链表+红黑树</p><p>图中是一个 Node数组 <code>transient Node&lt;K,V&gt;[] table</code> ; 每个黑点就是一个 Node</p><p><strong>Node.hash 是 key 的 hash</strong></p><p>1.8 的 HashMap 增加了红黑树来加强存取效率，红黑树的节点</p><p>TreeNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,N&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;</span><br><span class="line"><span class="comment">// 下面LinkedHashMap 的 Entry</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt;</span><br></pre></td></tr></table></figure><p>这样是方便了红黑树与链表之间的转换。</p><h2 id="关于-Hash，数组容量"><a href="#关于-Hash，数组容量" class="headerlink" title="关于 Hash，数组容量"></a>关于 Hash，数组容量</h2><p>HashMap 有四个构造器，下面只挑取其中的两个来分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组初始大小16，阀值12</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数中并没有初始化数组大小，而是先设置阀值 <code>threshold</code>， tableSzieFor 方法会返回大于等于传入值的最小2的指数。如传入 5 ，返回 $2^3$。那么什么时候会初始化数组 table 的大小？在第一次调用 put 时，在 putVal 中调用 <code>resize</code> 方法，在该方法中绘制阀值不为零而数组未初始化的情况下将数组大小设为阀值大小。</p><p>HasnMap 的hash 算法本质上是三步：<strong>取key 的hashCode 值、高位运算、取模运算。</strong></p><h3 id="key-的-hash-计算"><a href="#key-的-hash-计算" class="headerlink" title="key 的 hash 计算"></a>key 的 hash 计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么 hashcode 还要异或运算？</p><p>^ 异或运算：相同置0，不同置1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>^<span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span>^<span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">1</span>^<span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span>^<span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span>和<span class="number">1</span> 的概率都为 <span class="number">1</span>/<span class="number">2</span></span><br></pre></td></tr></table></figure><p>在 jdk1.7 中有 <code>indexFor(int h, int length)</code> 方法，jdk1.8 里没有，但原理一样，与jdk1.8中用tab[(n - 1) &amp; hash]代替但原理一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法返回值就是数组下标。我们平时用map大多数情况下map里面的数据不是很多。这里与（length-1）相&amp;,</p><p>但由于绝大多数情况下length一般都小于2^16即小于65536。所以return h &amp; (length-1);结果始终是h的低16位与（length-1）进行&amp;运算。如下例子（hashcode为四字节）</p><p>例如1：为了方便验证，假设length为8。HashMap的默认初始容量为16</p><p>length &#x3D; 8;  （length-1） &#x3D; 7；转换二进制为111；</p><p>假设一个key的 hashcode &#x3D; 78897121 转换二进制：100101100111101111111100001，与（length-1）&amp; 运算如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0000</span> <span class="number">0100</span> <span class="number">1011</span> <span class="number">0011</span> <span class="number">1101</span> <span class="number">1111</span> <span class="number">1110</span> <span class="number">0001</span></span><br><span class="line"> </span><br><span class="line">&amp;运算</span><br><span class="line"> </span><br><span class="line">    <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span></span><br><span class="line"> </span><br><span class="line">=   <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> （就是十进制<span class="number">1</span>，所以下标为<span class="number">1</span>）</span><br></pre></td></tr></table></figure><p><strong>上述运算实质是：001 与 111 &amp; 运算。也就是哈希值的低三位与length与运算。如果让哈希值的低三位更加随机，那么&amp;结果就更加随机，如何让哈希值的低三位更加随机，那么就是让其与高位异或。</strong></p><p>补充知识：</p><p><strong>当length&#x3D;8时  下标运算结果取决于哈希值的低三位</strong></p><p><strong>当length&#x3D;16时 下标运算结果取决于哈希值的低四位</strong></p><p><strong>当length&#x3D;32时 下标运算结果取决于哈希值的低五位</strong></p><p><strong>当length&#x3D;2的N次方， 下标运算结果取决于哈希值的低N位。</strong></p><p>原因总结：</p><p>由于和（length-1）运算，length 绝大多数情况小于2的16次方。所以始终是hashcode 的低16位（甚至更低）参与运算。要是高16位也参与运算，会让得到的下标更加散列。</p><p>所以这样高16位是用不到的，如何让高16也参与运算呢。所以才有hash(Object key)方法。让他的hashCode()和自己的高16位^运算。所以(h &gt;&gt;&gt; 16)得到他的高16位与hashCode()进行^运算。</p><p>因为大部分情况下，都是低16位参与运算，高16位可以减少hash冲突</p></blockquote><p><strong>key 在 table[]中位置计算</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><blockquote><p>为什么 数组大小一定是2的指数？</p><p>让大小是 2^n，是为了对取模运算进行优化，&amp; 比 % 具有更高的效率，当length 总是 2^n 时，h&amp;(length-1) 运算等价于对 length 取模，也就是 h%length。</p></blockquote><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>在 <code>resize()</code> 方法中，当数组超过阀值 threshold 时，会重新计算阀值 <code>threshold = capacity * loadFactor</code> 扩容。</p><p>从代码中可以看出，resize 方法不仅承担了扩容功能，还有初始化数组大小的功能。</p><ol><li>如果<code>oldCap&gt;0</code>，将数组大小扩大两倍，阀值同样扩大两倍</li><li>如果<code>oldCap == 0 &amp;&amp; oldThr &gt; 0</code> ，比如调用了规定容量大小的构造函数。将容量设为阀值大小。</li><li>如果<code>oldCap == 0</code>，代表初始化操作，数组大小为16，阀值为12。</li></ol><p>接下来如果 <code>oldTab!=null</code> 代表是扩容操作，对节点重新定位，一个节点 Node 的 hash 字段指的是 key 的hash，在确定它在数组中的位置是在putVal 方法中，采用的是 <code>hash &amp; (capacity-1)</code>，capacity 能取什么值？2的指数倍数。在重新安排新位置时先遍历数组，针对每个 node，将里面的节点按照 <code>hash &amp; capacity</code> 分为两拨，一拨<code>(hash &amp; capacity==0)</code> 放在旧位置处，另一拨放在 oldCap+ 旧位置 &#x3D; 新位置处。</p><p>如下图：是jdk1.7 的 HashMap 的扩容操作，与1.8 不同的是重新定位后节点在链表中原先的先后顺序会倒过来，即如图中 3与7 在新位置处的顺序倒了，而这<strong>会导致在并发下出现死循环问题，1.8对此做了更改，维持原有顺序不动，即一条链上的节点重新hash 后保持原链中的前后顺序</strong></p><p><img src="/../../assets/blogImg/code-analysis/Glide/hashmap-02.png" alt="hashmap-02"></p><p>扩容后数组变为原来的两倍，那么一个节点的 <code>hash &amp; (capacity-1)</code> 的值要么等于原来，要么移动2的幂次方。其中对上面这两种情况的判断语句：<code>(e.hash &amp; oldCap)==0</code></p><p><img src="/../../assets/blogImg/code-analysis/Glide/hashmap-03.png" alt="hashmap-03"></p><p>这个设计确实非常巧妙，既省去了重新计算hash值的时间，同时，由于新增的 1bit 是0还是1可以认为是随机的，因此resize 的过程，均匀的把之前的冲突的节点分散到新的 butcket </p><p>其中 TreeNode 的 <strong>split</strong> 方法，同链表处理相同，仍分为两拨，分法也一样，这里当其中一方节点数 &lt;&#x3D; 6，则恢复成链表；否则重新树化 treeify。</p><h2 id="HashMap-的put"><a href="#HashMap-的put" class="headerlink" title="HashMap 的put"></a>HashMap 的put</h2><p>putVal 的逻辑很清晰，如果key 存在onlyIfAbsent 为 false 表示更新 value 值，至于 afterNodeAccess 与 afterNodeInsertion 与这两个钩子方法是留给 LinkedHahsMap 的。put 的流程图如下：</p><p><img src="/../../assets/blogImg/code-analysis/Glide/hashmap-04.png" alt="hashmap-04"></p><p>树化调用的方法是 <strong>treeifyBin</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数组大小 &lt;64 时，执行扩容操作。即当某个 node 的节点个数大于8， 但数组大小 &lt; 64，进行扩容而不是树化。</p><h2 id="关于-HashMap-的死循环"><a href="#关于-HashMap-的死循环" class="headerlink" title="关于 HashMap 的死循环"></a>关于 HashMap 的死循环</h2><p>1.7 的HashMap 在多线程下 resize 是会出现死循环，导致 cpu100%，原因是1.7的 resize 会将原先节点的顺序倒过来。死循环问题的定位一般都是通过 jps + jstack 查看堆栈信息来定位的。</p><p>1.8 扩容时保持了原来链表中的顺序，避免了这个问题。</p><blockquote><p>HashMap 的 table 为什么是 <strong>transient</strong> 的？</p><p><code>transient Entry[] table</code> ；也就是说 table 里面的内容不会被序列化，为什么？</p><p>对 HashMap 来说 hashcode 至关重要，而 Object 里的hashcode 是native 方法 <code>public native int hashCode()</code>。这意味着：HashCode 和底层实现相关，不同的虚拟机有可能有不同的 HashCode 算法。</p><p>Java 的优势跨平台性，如果不用 transient 修饰 table，那么便会失去这一特性。</p></blockquote><h2 id="JDK1-8HashMap-数据覆盖问题"><a href="#JDK1-8HashMap-数据覆盖问题" class="headerlink" title="JDK1.8HashMap 数据覆盖问题"></a>JDK1.8HashMap 数据覆盖问题</h2><p>jdk1.8 HashMap 操作源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 jdk1.8 中 HashMap 中的put 操作函数，在代码第6,7行，如果hash 碰撞则会直接插入元素。这样就会有一个问题。</p><p>如果在线程 A 和线程 B 同时进行 put 操作，刚好这两条不同的数据 hash 值一样，并且该位置数据为null，所以线程 A 、B 都会进入第6行代码中。假设，线程 A 进入后还没有进行数据插入时挂起，而线程B 正常执行，从而线程A获取CPU 时间片，此时线程A 不用再进行hash判断，问题出现：线程A 会把线程B插入的数据给覆盖，发生线程不安全。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HashMap 是线程不安全的，主要体现在：</p><ol><li>在jdk1.7中，在多线程环境下，扩容是会造成环形链或数据丢失</li><li>在 jdk 1.8 中，在多线程环境下，会发生数据覆盖的情况。</li></ol><p>资料来源：</p><p><a href="https://mp.weixin.qq.com/s/VtIpj-uuxFj5Bf6TmTJMTw">https://mp.weixin.qq.com/s/VtIpj-uuxFj5Bf6TmTJMTw</a></p><p><a href="https://blog.csdn.net/sinat_34976604/article/details/80970981">https://blog.csdn.net/sinat_34976604/article/details/80970981</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;HashMap 的底层数据结构：散列表 + 红黑树。关于散列表，采用拉链法处理hash冲突，其中通过引入红黑树来提升效率。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://cxinxian.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Netty 笔记2</title>
    <link href="http://cxinxian.github.io/2021/09/14/Netty/Netty2/"/>
    <id>http://cxinxian.github.io/2021/09/14/Netty/Netty2/</id>
    <published>2021-09-14T12:42:05.000Z</published>
    <updated>2025-02-21T13:55:58.394Z</updated>
    
    <content type="html"><![CDATA[<h3 id="十一、WebSocket-协议开发应用"><a href="#十一、WebSocket-协议开发应用" class="headerlink" title="十一、WebSocket 协议开发应用"></a>十一、WebSocket 协议开发应用</h3><p>WebSocket 是 HTML5 开始提供的一种浏览器与服务端进行全双工通信的网络技术，WebSocket 于2011年被 IETF 定为标准 RFC6455，WebSocket API 被W3C定为标准。</p><span id="more"></span><p>WebSocket 的特点：</p><ul><li>单一的TCP连接，采用全双工模式通信；</li><li>对代理，防火墙和路由器透明；</li><li>无头部信息、Cookie 和身份验证；</li><li>无安全开销；</li><li>通过 <code>ping/pong</code> 帧保持链路激活；</li><li>服务器可以主动传消息给客户端，不再客户端需要轮询。</li></ul><h4 id="11-2、-WebSocket入门"><a href="#11-2、-WebSocket入门" class="headerlink" title="11.2、 WebSocket入门"></a>11.2、 WebSocket入门</h4><p>WebSocket 设计出来的目的就是要取代轮询和Comet技术，使客户端浏览器具备像C&#x2F;S 架构下的桌面系统一样实时通信的能力。</p><p>WebSocket 本质是就是一个TCP 连接，在数据传输的稳定性和数据量大小方面，和轮询以及Comet技术相比，具体很大的性能优势。</p><h5 id="11-2-1、WebSocket-连接建立"><a href="#11-2-1、WebSocket-连接建立" class="headerlink" title="11.2.1、WebSocket 连接建立"></a>11.2.1、WebSocket 连接建立</h5><p>建立WebSocket 连接时，需要通过客户端或浏览器向服务端发出握手请求。为建立一个 WebSocket 连接，客户端首先需要向服务器发起一个HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息<code>Upgrade:WebSocket</code> 表明这是一个申请协议升级的 HTTP 请求。如下图</p><p><img src="/../assets/blogImg/Netty/11-1.png" alt="11-1"></p><p>请求消息中的 <code>Sec-WebSocket-Key</code>  是随机的，服务器会用这些数据来构造出一个 SHA-1的信息摘要，把 <code>Sec-WebSocket-Key</code> 加上一个魔幻字符串 <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>，使用 SHA-1 加密，然后进行 BASE-64 编码，将结果作为 <code>Sec-WebSocket-Accept</code>  头的值，返回给客户端。服务端应答如下：</p><p><img src="/../assets/blogImg/Netty/11-2.png" alt="11-2"></p><h5 id="11-2-2、WebSocket-生命周期"><a href="#11-2-2、WebSocket-生命周期" class="headerlink" title="11.2.2、WebSocket 生命周期"></a>11.2.2、WebSocket 生命周期</h5><p>握手成功后，客户端和服务端就可以通过<code>message</code> 的方式进行通信了，一个消息可以有一个或多个帧组成，WebSocket 的消息不一定对应一个特定网络层的帧，它可以被分割成多个帧或被合并。</p><p><img src="/../assets/blogImg/Netty/11-3.png" alt="11-3"></p><h5 id="11-2-3、WebSocket-连接关闭"><a href="#11-2-3、WebSocket-连接关闭" class="headerlink" title="11.2.3、WebSocket 连接关闭"></a>11.2.3、WebSocket 连接关闭</h5><p>为关闭 WebSocket 连接，客户端和服务端需要一个安全的方法关闭底层TCP 连接和 TLS回话。如果合适，丢弃任何可能已经接收的字节，必要时（受到攻击）可以通过任何手段关闭连接。</p><p>底层 TCP 连接，在正常情况下，应首先由服务器关闭。异常情况下，可由客户端发起 TCP Close，因此，当服务器被指示关闭 WebSocket 连接时，它应立即发起一个TCP Close 操作，客户端应该等待服务器的 TCP Close 。</p><h4 id="11-3、Netty-WebSocket-协议开发"><a href="#11-3、Netty-WebSocket-协议开发" class="headerlink" title="11.3、Netty WebSocket 协议开发"></a>11.3、Netty WebSocket 协议开发</h4><p>Netty 基于 HTTP 协议栈开发了 WebSocket 协议栈，利用 Netty 的 WebSocket 的协议栈可以非常方便的开发出 WebSocket 的服务端和客户端。</p><p>下面将通过一个小例程来实现 Netty WebSocket 的客户端和服务端的开发，其主要功能为：客户端发送消息到服务端，服务端对请求消息进行判断，如果是合法的 WebSocket 消息，则响应返回 Netty WebSocket 服务端消息以及时间。</p><h5 id="11-3-1、WebSocket-服务端开发"><a href="#11-3-1、WebSocket-服务端开发" class="headerlink" title="11.3.1、WebSocket 服务端开发"></a>11.3.1、WebSocket 服务端开发</h5><p>利用Netty 开发WebSocket 服务端的关键是网络 I&#x2F;O 事件处理器handler，其中在 handler 处理的事件有:</p><ul><li>判断区分 HTTP请求和 WebSocke 请求，因为第一次请求握手消息是由HTTP 协议承载；</li><li>如果是 HTTP 握手请求，则根据通过握手工厂类<code>WebSocketServerHandshakerFactory</code> 创建握手处理类<code>WebSocketServerHandshaker</code> 实例；其中握手处理了中的<code>handshake</code> 方法会将 websocket的编辑码类动态的添加到 ChannelPipeline</li><li>链路建立成功后，客户端提交文本到服务端，服务端分别判断，是否是关闭连接、是否为 ping 指令消息，是否是支持的文本消息，然后做出响应，返回给客户端。</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">WebSocketServer</span> <span class="variable">webSocketServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocketServer</span>();</span><br><span class="line">        webSocketServer.bind(<span class="number">8082</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-codec&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-aggregator&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">65535</span>));</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-chuncked&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;websocket-handler&quot;</span>,<span class="keyword">new</span> <span class="title class_">WebSocketHandler</span>(port));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> serverBootstrap.bind(port).sync().channel();</span><br><span class="line">            System.out.println(<span class="string">&quot;websocket sart at prot:&quot;</span>+port);</span><br><span class="line">            System.out.println(<span class="string">&quot;please open your web browser and navigate to : http://localhost:&quot;</span>+port+<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;Object&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">        <span class="comment">// 处理 websocket 握手请求</span></span><br><span class="line">        <span class="keyword">private</span> WebSocketServerHandshaker handshaker;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WebSocketHandler</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.port = port;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;server receive msg:&quot;</span>+msg);</span><br><span class="line">            <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FullHttpRequest)&#123;</span><br><span class="line">                <span class="comment">// 传统 Http 请求接入</span></span><br><span class="line">                handlerHttpRequest(ctx,(FullHttpRequest)msg);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> WebSocketFrame)&#123;</span><br><span class="line">                <span class="comment">// websocket 接入</span></span><br><span class="line">                handlerWebSocketFrame(ctx,(WebSocketFrame)msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlerHttpRequest</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest msg)</span> &#123;</span><br><span class="line">            <span class="comment">// Http 解码失败或者不是请求建立 websocket 连接的http 请求，返回请求失败</span></span><br><span class="line">            <span class="keyword">if</span> (!msg.decoderResult().isSuccess() || !<span class="string">&quot;websocket&quot;</span>.equals(msg.headers().get(<span class="string">&quot;Upgrade&quot;</span>)))&#123;</span><br><span class="line">                sendHttpResponse(ctx,msg,<span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1,HttpResponseStatus.BAD_REQUEST));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 构造握手请求响应</span></span><br><span class="line">            <span class="type">WebSocketServerHandshakerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocketServerHandshakerFactory</span>(<span class="string">&quot;ws://localhost:&quot;</span>+port+<span class="string">&quot;/websocket&quot;</span>,</span><br><span class="line">                    <span class="literal">null</span>,<span class="literal">false</span>);</span><br><span class="line">            handshaker = factory.newHandshaker(msg);</span><br><span class="line">            <span class="keyword">if</span> (handshaker==<span class="literal">null</span>)&#123;</span><br><span class="line">                WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                handshaker.handshake(ctx.channel(),msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 websocket 帧</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlerWebSocketFrame</span><span class="params">(ChannelHandlerContext ctx, WebSocketFrame msg)</span> &#123;</span><br><span class="line">            <span class="comment">// 判断是否为关闭 websocket 链路指令</span></span><br><span class="line">            <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> CloseWebSocketFrame)&#123;</span><br><span class="line">                handshaker.close(ctx.channel(),((CloseWebSocketFrame) msg).retain());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否为 ping 指令消息</span></span><br><span class="line">            <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> PingWebSocketFrame)&#123;</span><br><span class="line">                ctx.channel().write(<span class="keyword">new</span> <span class="title class_">PongWebSocketFrame</span>(msg.content().retain()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 本例程仅支持文本消息，不支持二进制消息</span></span><br><span class="line">            <span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> TextWebSocketFrame))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(String.format(<span class="string">&quot;%s frame types ne supported.&quot;</span>,msg.getClass().getName()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回应答消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> ((TextWebSocketFrame) msg).text();</span><br><span class="line">            System.out.println(ctx.channel()+<span class="string">&quot; recived client message: \r\n&quot;</span>+text);</span><br><span class="line">            ctx.channel().writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(text+<span class="string">&quot;,欢迎使用 Netty WebSocket 服务，现在时间：&quot;</span></span><br><span class="line">                    + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>))));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendHttpResponse</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest req, FullHttpResponse resp)</span>&#123;</span><br><span class="line">            <span class="comment">// 返回应答给客户端</span></span><br><span class="line">            <span class="keyword">if</span> (resp.status().code()==<span class="number">200</span>)&#123;</span><br><span class="line">                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.copiedBuffer(resp.status().code()+<span class="string">&quot;&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">                resp.content().writeBytes(buf);</span><br><span class="line">                buf.release();</span><br><span class="line">                HttpUtil.setContentLength(resp,resp.content().readableBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> ctx.writeAndFlush(resp);</span><br><span class="line">            <span class="comment">// 如果非 keep-alive, 关闭连接</span></span><br><span class="line">            <span class="keyword">if</span> (!HttpUtil.isKeepAlive(req) || resp.status().code()!=<span class="number">200</span>)&#123;</span><br><span class="line">                f.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive())&#123;</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下</p><p><img src="/../assets/blogImg/Netty/11-4.png" alt="11-4"></p><p><img src="/../assets/blogImg/Netty/11-5.png" alt="11-5"></p><h4 id="11-4、Netty-UDP-协议开发"><a href="#11-4、Netty-UDP-协议开发" class="headerlink" title="11.4、Netty UDP 协议开发"></a>11.4、Netty UDP 协议开发</h4><p>用户数据报协议（User Datagram Protocol，UDP）是一种传输层协议。在 TCP&#x2F;IP 网络中，它与 TCP 协议一样用于处理数据包，是一种无连接的协议。</p><p>TCP 协议在进行数据传输时，需要建立连接，并且每次传输的数据都需要进行确认。当不再进行传输数据时，还需要断开连接。这样做虽然安全，但是效率较低。而 UDP 协议正好避免了这些过程，它是一种没有复杂控制，提供面向无连接的通信服务协议。</p><p>UDP 协议具备以下特点：</p><ul><li>没有各种连接：在传输数据前不需要建立连接，也避免了后续的断开连接。</li><li>不重新排序：对到达顺序混乱的数据包不进行重新排序。</li><li>没有确认：发送数据包无须等待对方确认。因此，使用 UDP 协议可以随时发送数据，但无法保证数据能否成功被目标主机接收。</li></ul><h5 id="11-4-1、UDP-服务端开发"><a href="#11-4-1、UDP-服务端开发" class="headerlink" title="11.4.1、UDP 服务端开发"></a>11.4.1、UDP 服务端开发</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyUdpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">NettyUdpServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyUdpServer</span>();</span><br><span class="line">        server.bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup)</span><br><span class="line">                    <span class="comment">// 指定通道类型为 NioDatagramChannel</span></span><br><span class="line">                    .channel(NioDatagramChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BROADCAST,<span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">//UDP相对于TCP不需要在客户端和服务端建立实际的连接，因此不需要为连接（ChannelPipeline）设置handler</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">NettyUdpServerHandler</span>());</span><br><span class="line">            serverBootstrap.bind(port).sync().channel().closeFuture().await();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyUdpServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;DatagramPacket&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, DatagramPacket msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> msg.content().toString(CharsetUtil.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">&quot;收到客户端消息为：&quot;</span>+content);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;udp-req&quot;</span>.equals(content))&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">respStr</span> <span class="operator">=</span> <span class="string">&quot;欢迎使用UDP服务，盲盒开奖成功！&quot;</span>;</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">respPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(Unpooled.copiedBuffer(respStr,CharsetUtil.UTF_8),msg.sender());</span><br><span class="line">                ctx.writeAndFlush(respPacket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            ctx.close();</span><br><span class="line">            cause.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="11-4-2、UDP-客户端开发"><a href="#11-4-2、UDP-客户端开发" class="headerlink" title="11.4.2、UDP 客户端开发"></a>11.4.2、UDP 客户端开发</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyUdpClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">NettyUdpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyUdpClient</span>();</span><br><span class="line">        client.connect(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">loopGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(loopGroup)</span><br><span class="line">                    .option(ChannelOption.SO_BROADCAST,<span class="literal">true</span>)</span><br><span class="line">                    .channel(NioDatagramChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ClientUdpHandler</span>());</span><br><span class="line"></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8081</span>).sync().channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向网段内的所有机器广播</span></span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(Unpooled.copiedBuffer(<span class="string">&quot;udp-req&quot;</span>,CharsetUtil.UTF_8),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;255.255.255.255&quot;</span>,port)));</span><br><span class="line">            <span class="comment">//客户端等待15s用于接收服务端的应答消息，然后退出并释放资源</span></span><br><span class="line">            <span class="keyword">if</span>(!channel.closeFuture().await(<span class="number">15000</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请求超时！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            loopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ClientUdpHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;DatagramPacket&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, DatagramPacket msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> msg.content().toString(CharsetUtil.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">&quot;client receive msg is : &quot;</span>+content);</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            ctx.close();</span><br><span class="line">            cause.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十二、私有协议栈开发"><a href="#十二、私有协议栈开发" class="headerlink" title="十二、私有协议栈开发"></a>十二、私有协议栈开发</h3><p>广义上区分，通信协议可以分为共有协议和私有协议。由于私有协议的灵活性，和时候在公司或者组织内部使用，按需定制，升级方便，灵活性好。</p><p>绝大多数私有协议传输层基于TCP&#x2F;IP，利用 Netty 的 NIO TCP 协议栈可以非常方便地进行私有协议的定制和开发。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;十一、WebSocket-协议开发应用&quot;&gt;&lt;a href=&quot;#十一、WebSocket-协议开发应用&quot; class=&quot;headerlink&quot; title=&quot;十一、WebSocket 协议开发应用&quot;&gt;&lt;/a&gt;十一、WebSocket 协议开发应用&lt;/h3&gt;&lt;p&gt;WebSocket 是 HTML5 开始提供的一种浏览器与服务端进行全双工通信的网络技术，WebSocket 于2011年被 IETF 定为标准 RFC6455，WebSocket API 被W3C定为标准。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://cxinxian.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Netty 笔记1</title>
    <link href="http://cxinxian.github.io/2021/09/06/Netty/Netty%20%E7%AC%94%E8%AE%B0/"/>
    <id>http://cxinxian.github.io/2021/09/06/Netty/Netty%20%E7%AC%94%E8%AE%B0/</id>
    <published>2021-09-06T13:53:21.000Z</published>
    <updated>2025-02-21T13:55:48.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Java-的I-O演进之路"><a href="#一、Java-的I-O演进之路" class="headerlink" title="一、Java 的I&#x2F;O演进之路"></a>一、Java 的I&#x2F;O演进之路</h3><p>Java1.4之前的早期版本，对I&#x2F;O的支持并不完善，使得开发人员在开发高性能I&#x2F;O程序时，面了巨大的挑战和困难，其主要问题如下：</p><ul><li>没有数据缓冲区，I&#x2F;O 性能存在问题；</li><li>没有C或者C++中的Channel概念，只有输入和输出流；</li><li>同步阻塞式 I&#x2F;O 通信（BIO)，通常会导致通信线程被长时间阻塞；</li><li>支持的字符集有限，硬件可移植不好。</li></ul><span id="more"></span><h4 id="I-O-基础入门"><a href="#I-O-基础入门" class="headerlink" title="I&#x2F;O 基础入门"></a>I&#x2F;O 基础入门</h4><h5 id="Linux-网络-I-O-模型简介："><a href="#Linux-网络-I-O-模型简介：" class="headerlink" title="Linux 网络 I&#x2F;O 模型简介："></a>Linux 网络 I&#x2F;O 模型简介：</h5><p>Unix 网络编程对I&#x2F;O 模型的分类，提供了5种I&#x2F;O模型，分别如下：</p><ul><li>阻塞I&#x2F;O模型</li><li>非阻塞I&#x2F;O模型</li><li>I&#x2F;O 复用模型</li><li>信号驱动 I&#x2F;O 模型</li><li>异步 I&#x2F;O</li></ul><p><img src="/../assets/blogImg/Netty/1-1.png" alt="1-1"><img src="/../assets/blogImg/Netty/1-2.png" alt="image-20210826165211834"><img src="/../assets/blogImg/Netty/1-3.png" alt="image-20210826165241853"></p><h5 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h5><p>I&#x2F;O多路复用技术通过把多个 I&#x2F;O 的阻塞复用到同一个select 的阻塞上，使得系统在单线程的情况下可以同时处理多个客户端请求。与多线程或多进程模型比，I&#x2F;O 多路复用降低了系统开销，节省系统资源。应用场景如下：</p><ul><li>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字；</li><li>服务器需要同时处理多种网络协议套接字。</li></ul><p>目前之前的 I&#x2F;O 多路复用的系统调用有：select、pselect、poll、epoll</p><h4 id="Java-的-I-O-演进"><a href="#Java-的-I-O-演进" class="headerlink" title="Java 的 I&#x2F;O 演进"></a>Java 的 I&#x2F;O 演进</h4><p>在 Java 1.4 推出 Java NIO 之前，基于Java 的所有Socket 通信都采用了同步阻塞模式(BIO)，这种一请求一应答的同学模型简化了上层的应用开发，但性能和可靠性却存在巨大的瓶颈。</p><ul><li><p>从 JDK1.0 到 JDK1.3 ，只有 BIO</p></li><li><p>JDK1.4 新增 java.nio 包，提供很多进行异步 I&#x2F;O 开发的类库和 API，主要类和接口：</p><ul><li><p>进行异步I&#x2F;O操作的缓冲区 ByteBuffer 等；</p></li><li><p>进行异步I&#x2F;O操作的管道 Pipe；</p></li><li><p>进行各种 I&#x2F;O 操作（异步or同步）的Channel，包括 ServerSocketChannel 和 SocketChannel；</p></li><li><p>多种字符集的编解码能力；</p></li><li><p>实现非阻塞 I&#x2F;O 操作的多路复用器 selector；</p></li><li><p>基于流行的 Perl 实现的正则表达式类库；</p></li><li><p>文件通道 FileChannel。<br>它的不足有：</p></li><li><p>没有统一的文件属性（例如读写权限）</p></li><li><p>API 能力比较弱，如目录的级联创建何递归遍历，往往需要自己实现</p></li><li><p>底层存储系统的一个些高级API无法使用</p></li><li><p>所有文件操作都是同步阻塞调用，不支持异步文件读写</p></li></ul></li><li><p>JDK1.7 对原有的 NIO库进行了升级，被称为 NIO2.0，主要改进有：</p><ul><li>提供能够批量获取文件属性的API，这些API具有与平台无关性，不与特性文件系统相耦合</li><li>提供 AIO 功能，支持基于文件的异步 I&#x2F;O 操作和针对网络套接字的异步操作</li><li>完成 JSR-51定义的通道功能，包括对配置和多播数据包的支持等。</li></ul></li></ul><h3 id="二、NIO入门"><a href="#二、NIO入门" class="headerlink" title="二、NIO入门"></a>二、NIO入门</h3><h4 id="传统的BIO编程"><a href="#传统的BIO编程" class="headerlink" title="传统的BIO编程"></a>传统的BIO编程</h4><p>网络编程的基本模型是 Client&#x2F;Server 模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（IP地址和监听端口），客户端通过连接操作服务端监听地址发起连接请求，通过三次握手建立连接，如果连接成功，双方就可以通过套接字（Socket）进行通信。</p><p>在传统的 BIO 编程中，ServerSocket 负责绑定 IP地址，启动监听端口；Socket 负责发起连接操作，连接成功后，双方通过输入流和输出流进行同步阻塞式通信。</p><h5 id="BIO-通信模型图"><a href="#BIO-通信模型图" class="headerlink" title="BIO 通信模型图"></a>BIO 通信模型图</h5><p>采用 BIO 通信模型的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接，收到客户端的连接请求后为每个客户端创建一个新的线程进行链路处理，处理完成后，通过输出流返回应答给客户端，线程销毁。</p><p><img src="/../assets/blogImg/Netty/2-1.png" alt="image-20210830104806593"></p><p>  该模型最大的问题是缺乏弹性伸缩能力，当客户端的访问数量增加时，服务端的线程数和客户端并发访问数呈现1:1的正比例关系，由于线程是虚拟机非常宝贵的系统资源，当线程数量膨胀后，系统性能将会急剧下降，随着并发访问量的继续增大，系统会发生线程堆栈溢出，创建新线程失败等问题，导致进程宕机僵死，无法提供对外服务。</p><h5 id="同步阻塞式-I-O-创建的TimeServer-源码分析"><a href="#同步阻塞式-I-O-创建的TimeServer-源码分析" class="headerlink" title="同步阻塞式 I&#x2F;O 创建的TimeServer 源码分析"></a>同步阻塞式 I&#x2F;O 创建的TimeServer 源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8082</span>;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">            System.out.println(<span class="string">&quot;the time server is start in port:&quot;</span>+port);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="comment">// 阻塞主线程，直到有新的 socket 客户端连接进来</span></span><br><span class="line">                socket = server.accept();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TimeServerHandler</span>(socket)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (server!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The time server close&quot;</span>);</span><br><span class="line">                server.close();</span><br><span class="line">                server = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TimeServerHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TimeServerHandler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">readerIn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 输入流、输出流</span></span><br><span class="line">                readerIn = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="built_in">this</span>.socket.getInputStream()));</span><br><span class="line">                printWriter = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="built_in">this</span>.socket.getOutputStream(),<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">currentTime</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="comment">// 获取输入流中的内容</span></span><br><span class="line">                    body = readerIn.readLine();</span><br><span class="line">                    <span class="keyword">if</span> (body==<span class="literal">null</span>)<span class="keyword">break</span>;</span><br><span class="line">                    System.out.println(<span class="string">&quot;The time server receive order: &quot;</span>+body);</span><br><span class="line">                    currentTime = <span class="string">&quot;QUERY_TIME_ORDER&quot;</span>.equals(body)?LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)):<span class="string">&quot;BAD QUERY&quot;</span>;</span><br><span class="line">                    <span class="comment">// 输出流输出服务端响应内容</span></span><br><span class="line">                    printWriter.println(currentTime);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">if</span> (readerIn!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        readerIn.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                        e1.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (printWriter!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    printWriter.close();</span><br><span class="line">                    printWriter = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.socket!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.socket.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                        e1.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">this</span>.socket = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  程序中通过ServerSocket 监听指定端口，如果没有被占用，服务端监听成功。如果没有客户端接入，则主线程阻塞在 accept() 操作上，直到有新的客户短连接进来。</p><h5 id="同步阻塞式-I-O-创建的-TimeClient-源码分析"><a href="#同步阻塞式-I-O-创建的-TimeClient-源码分析" class="headerlink" title="同步阻塞式 I&#x2F;O 创建的 TimeClient 源码分析"></a>同步阻塞式 I&#x2F;O 创建的 TimeClient 源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8082</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8082</span>);</span><br><span class="line"></span><br><span class="line">            in = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream(),<span class="literal">true</span>);</span><br><span class="line">            out.println(<span class="string">&quot;QUERY_TIME_ORDER&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Send order to server succeed.&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> in.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;Now is：&quot;</span>+resp);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in!=<span class="literal">null</span>)&#123;</span><br><span class="line">                in.close();</span><br><span class="line">                in = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (out!=<span class="literal">null</span>)&#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket!=<span class="literal">null</span>)&#123;</span><br><span class="line">                socket.close();</span><br><span class="line">                socket=<span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  客户端通过 Socket 连接到服务端，通过 <code>PrintWriter</code> 向服务端发送 <code>QUERY_TIME_ORDER</code> 指令，然后通过 <code>BufferReader</code> 读取服务端响应结果。</p><p><strong>BIO</strong>主要问题是当有新的客户端请求接入时，服务端需要创建一个新的线程处理新接入的客户端链路，一个线程只能处理一个客户端连接，在高性能服务器应用领域，往往需要成千上万个客户端的并发连接，无法满足高性能，高并发的接入场景。</p><h4 id="伪异步-I-O-编程"><a href="#伪异步-I-O-编程" class="headerlink" title="伪异步 I&#x2F;O 编程"></a>伪异步 I&#x2F;O 编程</h4><p>为解决同步阻塞 **I&#x2F;O ** 面临的一个链路需要一个线程处理的问题，后来有人通过对线程模型的优化——后端通过线程池来处理多个客户端的接入请求，形成客户端M，线程池最大线程数 N 的比例关系，M远大于N，通过线程池灵活地调配资源，设置线程最大值，防止海量并发接入导致资源耗尽。</p><h5 id="伪异步-I-O-模型图"><a href="#伪异步-I-O-模型图" class="headerlink" title="伪异步 I&#x2F;O 模型图"></a>伪异步 I&#x2F;O 模型图</h5><p><img src="/../assets/blogImg/Netty/2-2.png" alt="2-1"></p><p>当有新的客户端接入时，将客户端 Socket 封装成一个 Task (实现 Runnable 接口）投递到后端线程池中进行处理，线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。</p><h5 id="伪异步-I-O-创建的TimeServer-源码分析"><a href="#伪异步-I-O-创建的TimeServer-源码分析" class="headerlink" title="伪异步 I&#x2F;O 创建的TimeServer 源码分析"></a>伪异步 I&#x2F;O 创建的TimeServer 源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnycBioTimeServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">TimeServerHandlerExecutePool</span> <span class="variable">executePool</span> <span class="operator">=</span> TimeServerHandlerExecutePool.getInstance();</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8082</span>;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">            System.out.println(<span class="string">&quot;the time server is start in port:&quot;</span>+port);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="comment">// 阻塞主线程，直到有新的 socket 客户端连接进来</span></span><br><span class="line">                socket = server.accept();</span><br><span class="line">                executePool.execute(<span class="keyword">new</span> <span class="title class_">TimeServerHandler</span>(socket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (server != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The time server close&quot;</span>);</span><br><span class="line">                server.close();</span><br><span class="line">                server = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程池类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeServerHandlerExecutePool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> TimeServerHandlerExecutePool INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> TimeServerHandlerExecutePool <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (TimeServerHandlerExecutePool.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE==<span class="literal">null</span>)&#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">TimeServerHandlerExecutePool</span>(<span class="number">50</span>,<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">TimeServerHandlerExecutePool</span><span class="params">(<span class="type">int</span> maxPoolSize, <span class="type">int</span> queueSize)</span> &#123;</span><br><span class="line">        executorService = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(Runtime.getRuntime().availableProcessors(),maxPoolSize,<span class="number">120L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(queueSize));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable runnable)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executorService!=<span class="literal">null</span>)&#123;</span><br><span class="line">            executorService.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池和消息队列类都有界，无论客户端并发连接数量多大，都不会导致线程个数膨胀或者内存溢出。采用线程池实现，避免了并发连接请求对系统资源的消耗问题。但是底层依然是同步阻塞模型，无法从根本上解决问题。</p><h5 id="伪异步-I-O-的弊端"><a href="#伪异步-I-O-的弊端" class="headerlink" title="伪异步 I&#x2F;O 的弊端"></a>伪异步 I&#x2F;O 的弊端</h5><ul><li><p>读写（read、out）操作都是同步阻塞，阻塞时间取决于对方 <strong>I&#x2F;O</strong> 线程处理速度和网络 <strong>I&#x2F;O</strong> 的传输速度。</p></li><li><p>线程池阻塞队列积满后，后续入队列操作将被阻塞。</p></li></ul><h4 id="NIO-编程"><a href="#NIO-编程" class="headerlink" title="NIO 编程"></a>NIO 编程</h4><p>相比于<strong>BIO</strong> 的 <code>ServerSocket</code> 和 <code>Socket</code> ，<strong>NIO</strong> 提供了<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 两种不同的套接字通道实现。新增的通道都支持 <em>阻塞式</em> 和 <em>非阻塞式</em>  两种模式。一般来说，低负载、低并发的应用程序可以选择同步阻塞I&#x2F;O以降低编程复杂度；对于高负载，高并发的网络应用需要使用<strong>NIO</strong>模式进行开发</p><h5 id="NIO-类库简介"><a href="#NIO-类库简介" class="headerlink" title="NIO 类库简介"></a>NIO 类库简介</h5><p><strong>NIO</strong> 库是 JDK1.4 中引入的，弥补了原来 <strong>BIO</strong> 同步阻塞的不足，在标准的 Java 代码中提供了高速的、面向块的 <strong>I&#x2F;O</strong>，通过定义包含数据的类，以及通过以块的形式去处理这些数据，<strong>NIO</strong> 不使用本机代码就可以利用低级优化，这是原来 <strong>I&#x2F;O</strong> 包所无法做到的。</p><p><strong>缓冲区 Buffer</strong></p><p>Buffer 是一个对象，它包含要读出或者写入的数据，在 NIO 库中加入 Buffer对象，体现新库与原来 I&#x2F;O 库的一个重要区别。在面向流的 I&#x2F;O 库中，可以将数据直接读入或者写出到 <strong>Stream</strong> 对象中。</p><p>在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，直接读到缓冲区中；同样，写数据时，写入到缓冲区中。任何访问 NIO中的数据，都是通过缓冲区进行操作。</p><p>缓冲区实质是一个数组。通常它是一个字节数组（ByteBuffer)，也可以使用其他种类数组，缓冲区不仅仅是一个数组，还提供了对数据结构化访问以及维护读写位置（limit) 等信息。</p><p><img src="/../assets/blogImg/Netty/2-3.png" alt="image-20210830164049161"></p><p>每个 Buffer 类都是 Buffer 接口的一个子实例，除了 ByteBuffer， 每一个 Buffer 类都有完全一样的操作，只是它们所处理的数据类型不一样。因为大多数标准 I&#x2F;O 操作都使用ByteBuffer，所以它具有一般缓冲区操作之外还提供了一些特有的操作，以便网络读写。</p><p><strong>通道Channel</strong></p><p>Channel 是一个通道，像自来水管一样，网络数据通过 Channel 读取和写入。通道与流的不同之处在于通道是双向的，流只在一个方向移动（一个流必须是 InputStream 或者 OutputStream），而通道可以用于读、写同时进行。</p><p>因为 Channel 是全双工，所以比流更好的映射底层操作系统API。</p><p><img src="/../assets/blogImg/Netty/2-4.png" alt="2-4"></p><p><strong>多路复用器</strong></p><p>多路复用器 Selector ， 是Java NIO 编程基础，它提供已经选择就绪的任务的能力。简单来讲，Selector 会不断轮询已经注册在其上的 Channel，如果 Channel 发生读写事件，这个Channel 就处于就绪状态，会被 Selector 轮询出来，然后通过 SelectionKey 可以获取就绪 Channel 集合，进行后续的 I&#x2F;O 操作。</p><p>一个多路复用器可以同时轮询多 Channel，由于 JDK 使用了 epoll() 代替传统的 select 实现，所以他并没有最大连接句柄 1024&#x2F;2048 的限制。这也意味着只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端。</p><h5 id="NIO-服务端序列图"><a href="#NIO-服务端序列图" class="headerlink" title="NIO 服务端序列图"></a>NIO 服务端序列图</h5><p><img src="/../assets/blogImg/Netty/2-5.png" alt="2-5"></p><h5 id="NIO-创建的-TimeServer-源码分析"><a href="#NIO-创建的-TimeServer-源码分析" class="headerlink" title="NIO 创建的 TimeServer 源码分析"></a>NIO 创建的 TimeServer 源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOTimeServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8082</span>;</span><br><span class="line">        <span class="type">MultiplexerTimeServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiplexerTimeServer</span>(port);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(server,<span class="string">&quot;NIO-MultiplexerTimeServer-001&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiplexerTimeServer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel servChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> stop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MultiplexerTimeServer</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            servChannel = ServerSocketChannel.open();</span><br><span class="line">            servChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            servChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port),<span class="number">1024</span>);</span><br><span class="line">            servChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(<span class="string">&quot;The time server is start in port: &quot;</span>+port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.select(<span class="number">1000</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeySet = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; itr = selectionKeySet.iterator();</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (itr.hasNext())&#123;</span><br><span class="line">                    key = itr.next();</span><br><span class="line">                    itr.remove();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        handlerInput(key);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="keyword">if</span> (key!=<span class="literal">null</span>)&#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            <span class="keyword">if</span> (key.channel()!=<span class="literal">null</span>) key.channel().close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (selector!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 多路复用器关闭后，所有注册在上面的Channel 和 Pipe 等资源都会被自动去注册并关闭，所有并不需要重复释放资源</span></span><br><span class="line">                selector.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlerInput</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.isValid())&#123;</span><br><span class="line">            <span class="comment">// 处理新接入的请求信息</span></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                <span class="comment">// accept new Connection</span></span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// Add the new connection to the selector</span></span><br><span class="line">                sc.register(selector,SelectionKey.OP_READ);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                <span class="comment">// read the data</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> sc.read(byteBuffer);</span><br><span class="line">                <span class="keyword">if</span> (readBytes&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    byteBuffer.flip();</span><br><span class="line">                    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[byteBuffer.remaining()];</span><br><span class="line">                    byteBuffer.get(bytes);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;The time server receive order : &quot;</span>+ body);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">currentTime</span> <span class="operator">=</span> <span class="string">&quot;QUERY_SERVER_TIME&quot;</span>.equals(body)? LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)):<span class="string">&quot;BAD REQUEST!&quot;</span>;</span><br><span class="line">                    dowrit(sc,currentTime);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (readBytes&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 关闭链路</span></span><br><span class="line">                    key.cancel();</span><br><span class="line">                    sc.close();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 读到 0字节，忽略</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dowrit</span><span class="params">(SocketChannel sc, String response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (response!=<span class="literal">null</span> &amp;&amp; response.trim().length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = response.getBytes();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(bytes.length);</span><br><span class="line">            byteBuffer.put(bytes);</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            sc.write(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>初始化资源，创建多路复用器 <code>Selector</code>、<code>ServerSocketChannel</code> ，对 Channel 和 TCP 参数进行配置。如：将 ServerSocketChannel 设置为异步非阻塞，backlog &#x3D; 1024。将 ServerSocketChannel 注册到 Selector，监听 SelectionKey.OP_ACCEPT 操作位。</p></li><li><p>在 run 方法体中循环遍历 selector ，它的休眠时间为 1s ，不管是否有读写事件发生，selector 每隔 1s都会被唤醒一次，selector 提供无参方法 selectedKeys，当有处于就绪状态的 Channel 时，selector 将返回该 Channel 的 SelectionKey 集合</p></li><li><p>在处理新接入客户端消息时，根据 SelectionKey 操作位判断可获知网络事件类型，通过 ServerSocketChannel 的 accept 接收客户端的连接请求，并创建 SocketChannel 实例 ，完成上述步骤相当于完成 TCP 三次握手，TCP 物理链路正式建立。</p></li><li><p>读取客户端消息时，先创建一个ByteBuffer ，由于事先不知客户端发送的码流的大小，在例程中，开辟 1MB 大小的缓冲区。接着调用SocketChannel 的 read 方法读取码流，因设置SocketChannel 为异步非阻塞模式，因此 read 也是非阻塞的。读取到码流后，进行解码。首先对 Byteffer 进行 flip() 操作，它的作用是将缓冲区当前的 limit 设为 position，position设置为0，用于后续对缓冲区的操作。然后根据缓冲区的可读字节个数创建字节数组，调用Byteffer的get 方法，将缓冲区中可读的字节数据复制到新创建的字节数组。</p><p>读取到数据的字节数可能有以下几种情况</p><ul><li>返回值大于0：读到了字节，对字节数据编解码</li><li>返回值等于0：没有读到字节，属于正常情况，可忽略</li><li>返回值小于-1：链路已经关闭，需要关闭 SocketChannel，释放资源。</li></ul></li><li><p>应答消息发送给客户端时，先将字符串编码成字节数组，根据字节数组的容量创建 ByteBuffer，调用 put 方法将字节数组复制到缓冲区中，然后调用 flip 操作，最后调用 SocketChannel 的 write 方法将缓冲区中的数据发送出去。</p></li></ol><h5 id="NIO-客户端序列图"><a href="#NIO-客户端序列图" class="headerlink" title="NIO 客户端序列图"></a>NIO 客户端序列图</h5><p><img src="/../assets/blogImg/Netty/2-6.png" alt="image-20210831105007494"></p><h5 id="NIO-创建的TimeClient-源码分析"><a href="#NIO-创建的TimeClient-源码分析" class="headerlink" title="NIO 创建的TimeClient 源码分析"></a>NIO 创建的TimeClient 源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOTimeClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span>&#123;</span><br><span class="line">        <span class="type">NIOTimeClientHandler</span> <span class="variable">clientHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NIOTimeClientHandler</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8082</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(clientHandler,<span class="string">&quot;NIOTimeClient-02&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOTimeClientHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel sc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> isStop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NIOTimeClientHandler</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.host = (host==<span class="literal">null</span> || host.equals(<span class="string">&quot;&quot;</span>) || host.length()==<span class="number">0</span>)?<span class="string">&quot;127.0.0.1&quot;</span>:host;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            sc = SocketChannel.open();</span><br><span class="line">            sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doConnect();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!isStop)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.select(<span class="number">1000</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeySet = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; itr = selectionKeySet.iterator();</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (itr.hasNext())&#123;</span><br><span class="line">                    key = itr.next();</span><br><span class="line">                    itr.remove();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        handlerInput(key);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="keyword">if</span> (key!=<span class="literal">null</span>)&#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            <span class="keyword">if</span> (key.channel()!=<span class="literal">null</span>)&#123;</span><br><span class="line">                                key.channel().close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 多路复用器关闭后，所以注册在上面的Channel 和 Pipe 等资源都会被自动注册并关闭，不需要重复释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (selector!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlerInput</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.isValid())&#123;</span><br><span class="line">            <span class="comment">// 判断连接是否成功</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="keyword">if</span> (key.isConnectable())&#123;</span><br><span class="line">                <span class="keyword">if</span> (sc.finishConnect())&#123;</span><br><span class="line">                    sc.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                    doWrite(sc);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 连接失败，退出进程</span></span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">readSize</span> <span class="operator">=</span> sc.read(byteBuffer);</span><br><span class="line">                <span class="keyword">if</span> (readSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    byteBuffer.flip();</span><br><span class="line">                    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[byteBuffer.remaining()];</span><br><span class="line">                    byteBuffer.get(bytes);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;NOW is : &quot;</span>+ resp);</span><br><span class="line">                    <span class="built_in">this</span>.isStop = <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (readSize&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 对链路关闭</span></span><br><span class="line">                    key.cancel();</span><br><span class="line">                    sc.close();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 0 字节，忽略</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">connected</span> <span class="operator">=</span> sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="built_in">this</span>.host,<span class="built_in">this</span>.port));</span><br><span class="line">        <span class="comment">// 判断是否连接成功，连接成功，注册读状态到多路复用器中</span></span><br><span class="line">        <span class="comment">// 连接不成功（客户端已经发生 sync 包，还没有收到服务端 ack 包，物理链路还没有建立起来），注册 OP_CONNECT 到多路复用器中，监听服务端ACK应答。</span></span><br><span class="line">        <span class="keyword">if</span> (connected)&#123;</span><br><span class="line">            sc.register(selector,SelectionKey.OP_READ);</span><br><span class="line">            doWrite(sc);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            sc.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doWrite</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] reqbyte = <span class="string">&quot;QUERY_SERVER_TIME&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(reqbyte.length);</span><br><span class="line">        byteBuffer.put(reqbyte);</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        sc.write(byteBuffer);</span><br><span class="line">        <span class="keyword">if</span> (!byteBuffer.hasRemaining())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Client has send order to server succeed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>初始化多路复用器 <code>Selector</code>、<code>SocketChannel</code> ，创建 <code>SocketChannel</code> 对象后，将其设置为异步非阻塞模式。</li><li>对 <code>SocketChannel</code> 的 connect 操作进行判断。如果连接成功，则将 <code>SocketChannel</code> 注册到多路复用器 <code>Selector</code> 上，注册 <code>SelectionKey.OP_READ</code>； 如果没有连接成功，说明服务端没有返回 TCP 握手应答信息，但是不意味着连接失败。需要将 <code>SocketChannel</code> 注册到多路复用器<code>Selector</code> 上，注册<code>SelectionKey.OP_CONNECT</code> ，当服务端TCP响应 sync-ack 消息后，<code>Selector</code> 就能轮询到这个 <code>SocketChannel</code> 处于连接就绪。</li><li>循环体中轮询多路复用器<code>Selector</code>，当有就绪的 Channel 时，会调用 handlerInput(key) 方法，下面将会分析</li><li>在上面的代码 handlerInput 方法中，对 SelectionKey 的状态进行判断，如果处于连接状态，说明服务端 TCP 已经响应返回 ACK 应答消息。这时需要调用 SocketChannel 的 finishConnect 方法判断，如果返回 true，说明客户端连接成功；如果false或者抛出 IOException 异常，说明连接失败。在例程中，连接成功后则把 SocketChannel 注册到多路复用器上，注册<code>SelectionKey.OP_READ</code> 操作位，监听网络读操作，然后发送请求消息给服务端。</li><li>发送消息给服务端是先对消息编码成字节数组，然后写入到数据缓冲区 ByteBuffer，最后调用 SocketChannel 的 write 方法发送到服务端。由于发送是异步的，存在 ”半写包“ 问题。通过 <code>hasRemaining</code> 方法可判断缓冲区的消息是否全部发送完成。</li><li>如果客户端收到服务端的应答消息，可以根据 <code>SelectionKey</code> 的 <code>isReadable</code>方法判断 SocketChannel 是可读的，因无法事先判断应答码流的大小，我们可以通过 <code>ByteBuffer.allocate(1024)</code> 预先分配 1MB 大小的缓冲区空间用于读取应答消息，然后调用 SocketChannel 的 read() 方法进行异步读取应答消息。</li><li>线程退出循环后，我们需要释放连接资源，由于释放多路复用器资源后，JDK底层会释放所有跟此多路复用器相关联的资源，因此我们无需对 Channel、Pipe 等资源进行一一释放。</li></ol><p><strong>NIO编程优点总结：</strong></p><ul><li>客户端发起的连接操作是异步的，可以通过在多路复用器注册 <code>SelectionKey.OP_CONNECT</code> 等待后续结果，不需要像之前的客户端那样被同步阻塞。</li><li><code>SocketChannel</code> 的读写操作都是异步的，如果没有可读写的数据它是不会同步等待的，直接返回，这样 I&#x2F;O 通信线程就可以处理其他的链路，不需要同步等待这个链路可用。</li><li>线程模型优化：由于 JDK 的 Selector 在 Linux 等主流操作系统上通过 epoll 实现，它没有连接句柄数的限制（只受操作系统的最大句柄数或者对单进程的句柄数限制），这意味着一个 Selector 可以同时处理成千上万个客户端连接，而且性能不会随着客户端的增加而线性下降。因此，它非常适合做高性能、高负载的网络服务器。</li></ul><p>注：JDK1.7 升级了NIO类库，升级后的NIO类库被称作 NIO2.0，Java 正式提供了异步文件I&#x2F;O操作，同时提供了与UNIX 网络编程事件驱动 I&#x2F;O 对应的 AIO。</p><h4 id="AIO-编程"><a href="#AIO-编程" class="headerlink" title="AIO 编程"></a>AIO 编程</h4><p>NIO 2.0 引入了新的异步通道概念，并提供了异步文件通道和异步套接字通道的实现。其异步套接字通道是真正的异步非阻塞I&#x2F;O。</p><p>异步通道提供了以下两种方式获取操作结果。</p><ul><li>通过 <code>java.util.concurrent.Future</code> 类来表示异步操作的结果。</li><li>在执行异步操作时传入一个 <code>java.nio.channels</code>。</li></ul><p>CompletionHandler 接口的实现类作为操作完成的回调。</p><h5 id="AIO创建的TimeServer-源码分析"><a href="#AIO创建的TimeServer-源码分析" class="headerlink" title="AIO创建的TimeServer 源码分析"></a>AIO创建的TimeServer 源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsynTimeServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span>&#123;</span><br><span class="line">        <span class="type">AsynTimeServerHandler</span> <span class="variable">serverHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsynTimeServerHandler</span>(<span class="number">8082</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(serverHandler,<span class="string">&quot;AIO-AsynTimeServerHandler-01&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AsynTimeServerHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsynTimeServerHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">public</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="keyword">public</span> AsynchronousServerSocketChannel asynchronousServerSocketChannel;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AsynTimeServerHandler</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            asynchronousServerSocketChannel = AsynchronousServerSocketChannel.open();</span><br><span class="line">            asynchronousServerSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line">            System.out.println(<span class="string">&quot;The time server is start in port：&quot;</span>+port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        countDownLatch = <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        doAccept();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAccept</span><span class="params">()</span> &#123;</span><br><span class="line">        asynchronousServerSocketChannel.accept(<span class="built_in">this</span>,<span class="keyword">new</span> <span class="title class_">AcceptCompletionHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AcceptCompletionHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AcceptCompletionHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel,AsynTimeServerHandler&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel result, AsynTimeServerHandler attachment)</span> &#123;</span><br><span class="line">        attachment.asynchronousServerSocketChannel.accept(attachment,<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        result.read(byteBuffer,byteBuffer,<span class="keyword">new</span> <span class="title class_">ReadCompletionHandler</span>(result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, AsynTimeServerHandler attachment)</span> &#123;</span><br><span class="line">        attachment.countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReadCompletionHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadCompletionHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel channel;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReadCompletionHandler</span><span class="params">(AsynchronousSocketChannel result)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.channel = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">        attachment.flip();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[attachment.remaining()];</span><br><span class="line">        attachment.get(bytes);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;The time server receive order : &quot;</span>+body);</span><br><span class="line">            <span class="type">String</span> <span class="variable">curentTime</span> <span class="operator">=</span> <span class="string">&quot;AIO_SYNC_SERVERTIME&quot;</span>.equals(body)? LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)):<span class="string">&quot;BAD REQUEST&quot;</span>;</span><br><span class="line">            doWrite(curentTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.channel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doWrite</span><span class="params">(String curentTime)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (curentTime!=<span class="literal">null</span> &amp;&amp; curentTime.trim().length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = curentTime.getBytes();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">writebuffer</span> <span class="operator">=</span> ByteBuffer.allocate(bytes.length);</span><br><span class="line">            writebuffer.put(bytes);</span><br><span class="line">            writebuffer.flip();</span><br><span class="line">            channel.write(writebuffer, writebuffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer buffer)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining())&#123;</span><br><span class="line">                        <span class="comment">// 如果没有发送完成，则继续发送</span></span><br><span class="line">                        channel.write(buffer,buffer,<span class="built_in">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer buffer)</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        channel.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在例程中是使用独立线程来创建服务端Handler，在<strong>实际项目中不需要独立线程创建</strong>，因为底层通过JDK的系统回调实现的。</p><ol><li><p><code>AsynTimeServerHandler</code> 在构造方法中，创建一个异步的服务端通道 <code>AsynchronousServerSocketChannel</code> ，然后调用其<code>bind()</code> 方法绑定监听端口，如果端口合法且没有被占用，则绑定成功。在 run 方法中，初始化 CountDownLatch  对象，其作用是完成一组正在执行的操作之前，允许线程一直阻塞（实际运用中不需用到，此次 CountDownLatch  仅作demo示例）。</p></li><li><p>在 <code>doAccept()</code> 方法中，用于接收客户端的连接，我们可以传递 CompletionHandler&lt;AsynchronousSocketChannel, ? super A&gt; 的handler 实例接收 accept 操作成功的消息通知。</p></li><li><p><code>AcceptCompletionHandler</code> 中的 completed 方法可以获取到 AsynTimeServerHandler 的成员变量 <code>AsynchronousServerSocketChannel </code> ，然后调用它的 accept 方法。细心的同学可能会问，为什么在这里会再次调用 accept 方法呢？原因是：调用<code>AsynchronousServerSocketChannel</code> 的 accept 方法后，当有新的客户端连接接入后，系统将会回调我们传入的 CompletionHandler 实例的 completed 方法，表示新的客户端已经接入成功。</p><p>链路建立成功后，通过 <code>AsynchronousSocketChannel</code> 的 <code>read()</code> 方法进行异步操作，其参数如下：</p><ul><li>ByteBuffer dst：结束缓冲区，用于从异步Channel 中读取数据包；</li><li>A attachment：异步 Channel 携带的附件，通知回调的时候作为入参使用；</li><li>CompletionHandler&lt;Integer,? super A&gt; ，接收通知回调的业务Handler</li></ul></li><li><p>在<code>ReadCompletionHandler</code> 的构造方法中，我们可以拿到 <code>AsynchronousSocketChannel</code> 的实例，主要用来读取半包信息和发送应答。在<code>completed()</code> 方法中是读取消息的处理，首先调用 attachment 的 <code>flip()</code> 方法，为后续读取缓冲区数据做准备。根据缓冲区数据的可读字节数创建 byte 数组，然后根据 byte 数组 new String 创建消息。</p><p><code>dowWrite()</code> 方法响应给客户端消息时，首先把字符串消息转换成字节数组，然后通过 ByteBuffer 复制到发送缓冲区，然后通过 <code>AsynchronousSocketChannel</code> 的异步 <code>write()</code> 方法发送消息。<code>write()</code> 方法的参数和<code>read()</code> 方法的参数一样。</p></li><li><p>CompletionHandler 的 <code>failed()</code> 方法，其作用是当发生异常时，对异常 Throwable 进行判断，根据异常做出相应的逻辑处理，如 I&#x2F;O 异常则关闭链路，释放资源。</p></li></ol><h5 id="AIO创建的-TimeClient-源码分析"><a href="#AIO创建的-TimeClient-源码分析" class="headerlink" title="AIO创建的 TimeClient 源码分析"></a>AIO创建的 TimeClient 源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsynTimeClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span>&#123;</span><br><span class="line">        <span class="type">AsynTimeClientHandler</span> <span class="variable">clientHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsynTimeClientHandler</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8082</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(clientHandler,<span class="string">&quot;AIO-AsynTimeClientHandler-01&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AsynTimeClientHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsynTimeClientHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, CompletionHandler&lt;Void, AsynTimeClientHandler&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AsynTimeClientHandler</span><span class="params">(String host,<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel = AsynchronousSocketChannel.open();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        latch = <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="built_in">this</span>.host,<span class="built_in">this</span>.port),<span class="built_in">this</span>,<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Void result, AsynTimeClientHandler attachment)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] req = <span class="string">&quot;AIO_SYNC_SERVERTIME&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">reqbuffer</span> <span class="operator">=</span> ByteBuffer.allocate(req.length);</span><br><span class="line">        reqbuffer.put(req);</span><br><span class="line">        reqbuffer.flip();</span><br><span class="line">        socketChannel.write(reqbuffer, reqbuffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer buffer)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (buffer.hasRemaining())&#123;</span><br><span class="line">                    socketChannel.write(buffer,buffer,<span class="built_in">this</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">readbuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    socketChannel.read(readbuffer, readbuffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                            attachment.flip();</span><br><span class="line">                            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[attachment.remaining()];</span><br><span class="line">                            attachment.get(bytes);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                                System.out.println(<span class="string">&quot;NOW is : &quot;</span>+ response);</span><br><span class="line">                                latch.countDown();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                socketChannel.close();</span><br><span class="line">                                latch.countDown();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socketChannel.close();</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, AsynTimeClientHandler attachment)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.close();</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端例程中，通过新建一个线程来创建一个异步时间服务器连接对象，实际项目中无需独立线程来创建异步连接对象的。</p><ol><li><p>在<code>AsynTimeClientHandler</code> 的源码中，在构造方法中创建了 <code>AsynchronousSocketChannel</code> 对象，在 <code>run()</code> 方法中，<code>CountDownLatch</code> 进行等待，防止异步操作没有执行完成线程就退出。同时 通过 <code>AsynchronousSocketChannel</code> 对象调用<code>connect</code> 方法发起异步操作，根据服务端地址和端口连接服务端，该方法除地址外的另外两个参数：</p><ul><li><p>A attachment：<code>AsynchronousSocketChannel</code>的附件，用于回调通知时作为入参被传递，调用者可以自定义。</p></li><li><p>CompletionHandler&lt;Void, ? super A&gt; handler : 异步操作回调通知接口，由调用者实现。</p><p>例程中两个参数都使用了 AsynTimeClientHandler 本身，因为它也实现了 CompletionHandler 接口。</p></li></ul></li><li><p>异步连接成功后的方法回调是 <code>completed()</code> ，在该方法中我们可以创建请求体消息，把字符串消息编码成字节数组，然后复制到 ByteBuffer ，最后调用 <code>AsynchronousSocketChannel</code> 的 <code>write</code> 方法发送到服务端，<code>write()</code> 的方法参数与服务端类似，此处就不展开细说。</p></li><li><p>客户端在读取服务端应答的消息时是通过 <code>AsynchronousSocketChannel</code> 的 <code>read()</code> 方法，其方法入参也和服务端一样。</p></li></ol><h5 id="AIO-的线程堆栈"><a href="#AIO-的线程堆栈" class="headerlink" title="AIO 的线程堆栈"></a>AIO 的线程堆栈</h5><p>通过打印线程堆栈信息可知，JDK 底层通过线程池 <code>ThreadPoolExecutor</code> 来执行回调通知，异步回调通知由 <code>cun.nio.AsynchronousChannelGroupImpl</code> 实现，通过层层调用，最终回调 <code>com.phei.netty.aio.AsynTimeClientHandler$1.completed</code> 方法，完成回调通知。</p><h4 id="名词概念澄清"><a href="#名词概念澄清" class="headerlink" title="名词概念澄清"></a>名词概念澄清</h4><h5 id="1、异步阻塞I-O"><a href="#1、异步阻塞I-O" class="headerlink" title="1、异步阻塞I&#x2F;O"></a>1、异步阻塞I&#x2F;O</h5><p>不少人喜欢把 JDK1.4 提供的NIO模型叫做异步非阻塞 I&#x2F;O，如果严格按照 UNIX 网络编程模型和 JDK的实现区分，实际上只能被称为非阻塞I&#x2F;O，不能叫异步非阻塞I&#x2F;O。在 JDK 1.4和 JDK 1.5 update 10之前的版本，JDK 的 Selector 是基于 select&#x2F;pull 模型实现，是基于 I&#x2F;O 复用技术的非阻塞 I&#x2F;O，在 JDK1.5 update 10 和 Linux core2.6以上版本，Sun 优化了 Selector 的实现，底层使用 epoll 替换了 select&#x2F;pull ，上层 API 并没有改变，属于 JDK NIO 的性能优化，没有改变 I&#x2F;O模型，依然是非阻塞 I&#x2F;O。</p><p>直到 JDK 1.7的出现，提供的NIO2.0 新增了异步套接字通道，才真正的实现了异步 I&#x2F;O ，也叫AIO。</p><h5 id="2、多路复用器-Selector"><a href="#2、多路复用器-Selector" class="headerlink" title="2、多路复用器 Selector"></a>2、多路复用器 Selector</h5><p>对于Selector，有的人叫多路复用器，有的叫选择器，实质是同一东西的不同叫法。</p><p>Java NIO 的实现关键是多路复用 I&#x2F;O 技术，其核心就是通过 Selector 来轮询注册在其上的 Channel，当发现有一个或者多个Channel  处于就绪状态，就会从阻塞状态返回就绪的Channel 集合，进行 I&#x2F;O 操作。</p><h5 id="3、伪异步-I-O"><a href="#3、伪异步-I-O" class="headerlink" title="3、伪异步 I&#x2F;O"></a>3、伪异步 I&#x2F;O</h5><p>伪异步I&#x2F;O 概念来源于实践，在没有 NIO 模型之前，为解决 Tomcat 通信线程同步 I&#x2F;O 导致业务线程被挂住问题，使用线程池和消息队列来隔离 I&#x2F;O 线程和业务线程，这样就业务线程不会被 I&#x2F;O 线程阻塞。</p><h4 id="4种-I-O-的对比"><a href="#4种-I-O-的对比" class="headerlink" title="4种 I&#x2F;O 的对比"></a>4种 I&#x2F;O 的对比</h4><h5 id="为什么不选择原生JAVA-的NIO编程"><a href="#为什么不选择原生JAVA-的NIO编程" class="headerlink" title="为什么不选择原生JAVA 的NIO编程"></a>为什么不选择原生JAVA 的NIO编程</h5><ol><li>NIO 类库和API 复杂，使用麻烦，需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。</li><li>需要具备其他额外技能做铺垫，如 Java 多线程编程，因为 NIO 编程涉及到 Rector 模式，需要对多线程和网络编程非常熟悉，才能写出高质量的NIO 程序。</li><li>可靠性能力补齐，工作量和难度都非常大，如客户端断连和重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流处理等问题。</li><li>Java NIO 臭名昭著的 epoll bug，它会导致 Selector 空轮询，最终导致 CPU 100%，虽然官方声称 JDK 1.6 版已修复，但在 JDK 1.7依然存在，只是bug 发生的概率降低了。</li></ol><h5 id="为什么选择-Netty"><a href="#为什么选择-Netty" class="headerlink" title="为什么选择 Netty"></a>为什么选择 Netty</h5><p>Netty的优点如下：</p><ol><li>API 使用简单，开发门槛较低</li><li>功能强大，预置了多种编解码功能，支持多种主流协议</li><li>定制能力强，可通过 ChannelHandler 对通信框架进行灵活的扩展。</li><li>性能高，通过与其他业界的主流 NIO 框架对比，Netty 的综合性能最高。</li><li>成熟、稳定，Netty 已经修复所有已经发现的 JDK NIO BUG，业务人员无再为 NIO 的 BUG 而烦恼。</li><li>社区活跃，版本迭代周期短，发现BUG 可以及时修复，同时更多的新功能会被加入。</li><li>经历了大规模的商业应用考验，质量得到验证。</li></ol><h3 id="三、Netty-入门应用"><a href="#三、Netty-入门应用" class="headerlink" title="三、Netty 入门应用"></a>三、Netty 入门应用</h3><h4 id="3-1、Netty-时间服务器服务端"><a href="#3-1、Netty-时间服务器服务端" class="headerlink" title="3.1、Netty 时间服务器服务端"></a>3.1、Netty 时间服务器服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyTimeServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChildChannelHandler</span>());</span><br><span class="line">            <span class="comment">// 绑定端口，等待同步成功</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> serverBootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">// 等待服务端监听端口关闭</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ChildChannelHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">TimeServerHandler</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TimeServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[buf.readableBytes()];</span><br><span class="line">            buf.readBytes(bytes);</span><br><span class="line">            <span class="type">String</span> <span class="variable">reqBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;The time Server receive the reqesut is : &quot;</span>+reqBody);</span><br><span class="line">            <span class="type">String</span> <span class="variable">currentTime</span> <span class="operator">=</span> <span class="string">&quot;NETTY_SEVER_TIME&quot;</span>.equals(reqBody)? LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)):<span class="string">&quot;BAD REQUEST&quot;</span>;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">resp</span> <span class="operator">=</span> Unpooled.copiedBuffer(currentTime.getBytes());</span><br><span class="line">            ctx.write(resp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;channelReadComplete....&quot;</span>);</span><br><span class="line">            ctx.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span>&#123;</span><br><span class="line">        <span class="type">NettyTimeServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyTimeServer</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server.bind(<span class="number">8082</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Netty 创建服务端的步骤主要分为以下几个：</p><ol><li>通过<code>NioEventLoopGroup</code> 创建 <code>EventLoopGroup </code> 线程组实例，它包含了一组NIO线程组，专门用于网络事件的处理，实际上就是 <code>Reactor</code> 线程组。创建两个的原因是：一个用于服务端接收客户端的连接，另一个用于<code>SocketChannel</code> 网络读写。</li><li>创建 <code>ServerBootStrap</code> 对象，其作用是启动 NIO 服务端的辅助启动类，目的是降低服务端的开发复杂度。通过它可以设置 <code>EventLoopGroup</code> 线程组，配置TCP 参数，设置创建channl 为<code>NioServerSocketChannel</code> 类，最后绑定 I&#x2F;O 事件处理类 <code>ChildChannelHandler</code> ，主要用于处理网络 I&#x2F;O 事件处理，如记录日志，消息编解码等。</li><li>配置完成后，通过<code>ServerBootStrap</code> 的实例调用<code>bind()</code> 方法绑定监听端口，接着，调用同步阻塞方法<code>sync()</code> 等待绑定操作完成。最后会返回一个 <code>ChannelFuture</code> 的实例，类似于<code>java.util.concurrent.Future</code> ，用于异步操作的回调通知。</li><li>调用 <code>future.channel().closeFuture().sync()</code> 方法进行阻塞是为了等待服务端链路关闭后才退出main 函数。</li><li>在 finally 中关闭 EventLoopGroup 线程组释放资源。</li><li><code>TimeServerHandler</code>  继承自 <code>ChannelHandlerAdapter</code> ，用于对网络事件进行读写操作。关键方法是<code>channelRead、channelReadComplete、exceptionCaught</code><ul><li>channelRead 方法主要是接收客户端消息，其有两个入参，一个 <code>ChannelHandlerContext</code> ，可以通过其 write 方法异步发送消息响应给客户端；而另一 Object 类型的msg 参数则为接收到的请求信息，可以被转换为 ByteBuf ，ByteBuf 类似于 JDK 中的 ByteBuffer ，不过它提供了更加灵活和强大的功能。可以公共 ByteBuf 的 readableBytes 获取缓冲区中的可读字节数。</li><li>channelReadComplete 方法中，调用了 ChannelHandlerContext 的 flush 方法，其作用是将消息发送队列中的消息写入到 <code>SocketChannel </code> 中发送给对方。从性能角度考虑，为了防止频繁地唤醒 Selector 进行消息发送，Netty 的 write 方法并不直接将消息写入到 SocketChannel 中，调用 write 方法只是把待发送的消息放到发送缓冲数组中，再通过调用flush 方法，将缓冲区中的消息全部写入到 SocketChannel 中。</li><li>exceptionCaught 是异常处理方法，出现异常是通过调用 ChannelHandlerContext 的 close 方法及时关闭释放资源。</li></ul></li></ol><h4 id="3-2、Netty-时间服务器客户端"><a href="#3-2、Netty-时间服务器客户端" class="headerlink" title="3.2、Netty 时间服务器客户端"></a>3.2、Netty 时间服务器客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyTimeClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(String address, <span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 配置客户端 NIO 线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">clientGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(clientGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY,<span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">TimeClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 发送异步连接操作</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(address,port).sync();</span><br><span class="line">            <span class="comment">// 等待客户端链路关闭</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            clientGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">byte</span>[] req = <span class="string">&quot;NETTY_SEVER_TIME&quot;</span>.getBytes();</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(req.length);</span><br><span class="line">            buf.writeBytes(req);</span><br><span class="line">            ctx.writeAndFlush(buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">            <span class="type">byte</span>[] resp = <span class="keyword">new</span> <span class="title class_">byte</span>[buf.readableBytes()];</span><br><span class="line">            buf.readBytes(resp);</span><br><span class="line">            <span class="type">String</span> <span class="variable">respStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(resp,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;NettyTimeClient receive server response time is：&quot;</span>+respStr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            ctx.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">NettyTimeClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyTimeClient</span>();</span><br><span class="line">        client.connect(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8082</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比起创建服务端，创建Netty 客户端更加简单</p><ol><li>在connect 方法中，首先通过<code>NioEventLoopGroup</code>创建 <code>EventLoopGroup</code> 的实例，处理客户端的网络 I&#x2F;O 线程组，然后创建客户端的辅助启动类 <code>Bootstrap</code>的实例并进行配置。客户端使用的 Channel 为 <code>NioSocketChannel</code> ，最后添加绑定 ChannelHandler 处理网络 I&#x2F;O 事件。</li><li><code>TimeClientHandler</code>  中有三个重要的方法，分别为：<code>channelActive、channelReadComplete、exceptionCaught</code> ，后两个就不展开说了，与上面的服务端相似，主要说下 <code>channelActive</code> 方法，该方法主要是在客户端与服务端TCP 通信链路建立后，Netty 的 NIO 线程会调用该方法。</li></ol><h3 id="四、TCP-粘包-拆包问题的解决之道"><a href="#四、TCP-粘包-拆包问题的解决之道" class="headerlink" title="四、TCP 粘包&#x2F;拆包问题的解决之道"></a>四、TCP 粘包&#x2F;拆包问题的解决之道</h3><h4 id="4-1、TCP-粘包-拆包"><a href="#4-1、TCP-粘包-拆包" class="headerlink" title="4.1、TCP 粘包&#x2F;拆包"></a>4.1、TCP 粘包&#x2F;拆包</h4><p>TCP 是个 “流” 协议，所谓流，就是没有界限的一串数据。TCP 并不了解上层业务数据的具体含义，它会根据缓冲区的实际情况进行包的划分，所以在业务上任务，一个完整的包可能会被拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的 TCP 粘包和拆包问题。</p><h5 id="4-1-1-TCP-粘包-拆包问题说明"><a href="#4-1-1-TCP-粘包-拆包问题说明" class="headerlink" title="4.1.1 TCP 粘包&#x2F;拆包问题说明"></a>4.1.1 TCP 粘包&#x2F;拆包问题说明</h5><p><img src="/../assets/blogImg/Netty/4-1.png" alt="4-1"></p><p>假设客户端分别发送了两个数据包 D1 和 D2 个服务端，由于服务端一次读到的字节数是不确定的，可能存在以下 4 种情况。</p><ul><li>服务端分两次读取到了两个独立的数据包，分别是 D1 和 D2，没有发生粘包和拆包问题。</li><li>服务端一次读到了两个数据包，D1 和 D2 粘在一起，被称为 TCP 粘包。</li><li>服务端分两次读到了两个数据包，第一次读取到了完整的 D1 包和 D2 包的部分内容，第二次读到了 D2 包的剩余内容，这被称为 TCP 拆包。</li><li>服务端分两次读到了两个数据包，第一次读取到 D1包的部分内容，第二次读到了 D1包剩余的内容以及完整的D2 包内容。</li></ul><p>如果服务端 TCP 接收滑窗非常小，而数据包 D1 和 D2 比较大，有可能会发生第5种情况，服务端要分多次才能将 D1 和 D 包完全接收，期间发生多次拆包。</p><h5 id="4-1-2、TCP-粘包拆包发生的原因"><a href="#4-1-2、TCP-粘包拆包发生的原因" class="headerlink" title="4.1.2、TCP 粘包拆包发生的原因"></a>4.1.2、TCP 粘包拆包发生的原因</h5><ol><li>应用程序 write 写入的字节大小大于套接口发送缓冲区大小；</li><li>进行MSS大小的 TCP 分段；</li><li>以太网帧的 payload 大于 MTU 进行 IP 分片。</li></ol><p><img src="/../assets/blogImg/Netty/4-2.png" alt="4-2"></p><h5 id="4-1-3、粘包问题的解决策略"><a href="#4-1-3、粘包问题的解决策略" class="headerlink" title="4.1.3、粘包问题的解决策略"></a>4.1.3、粘包问题的解决策略</h5><p>由于底层 TCP 无法理解上层的业务数据，所以在底层无法保证数据包不被拆分和重组，这个问题只能通过上层的应用协议栈设计来解决，主流协议的解决方案如下：</p><ol><li>消息定长，如每个报文的大小固定为200个字节，如果不够，空位补空格；</li><li>在包尾增加回车换行进行分割，如 FTP 协议；</li><li>将消息分为消息头和消息体，消息头包含表示消息总长度（或者消息体的长度）的字段，通常设计思路为消息头的第一个字段使用 int32 来表示消息的总长度；</li><li>更为复杂的应用层协议。</li></ol><h4 id="4-2、未考虑-TCP-粘包导致功能异常的案例"><a href="#4-2、未考虑-TCP-粘包导致功能异常的案例" class="headerlink" title="4.2、未考虑 TCP 粘包导致功能异常的案例"></a>4.2、未考虑 TCP 粘包导致功能异常的案例</h4><p>通过模拟故障场景，然后看看如何正确使用 Netty 半包解码器来解决 TCP 的粘包和拆包问题。</p><h5 id="4-2-1、NettyTimeServer改造"><a href="#4-2-1、NettyTimeServer改造" class="headerlink" title="4.2.1、NettyTimeServer改造"></a>4.2.1、NettyTimeServer改造</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorTimeServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> counter;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[buf.readableBytes()];</span><br><span class="line">        buf.readBytes(bytes);</span><br><span class="line">        <span class="type">String</span> <span class="variable">reqBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="string">&quot;UTF-8&quot;</span>).substring(<span class="number">0</span>,bytes.length-System.getProperty(<span class="string">&quot;line.separator&quot;</span>).length());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;The time Server receive the reqesut is : &quot;</span>+reqBody+<span class="string">&quot;; the counter is: &quot;</span>+ ++counter);</span><br><span class="line">        <span class="type">String</span> <span class="variable">currentTime</span> <span class="operator">=</span> <span class="string">&quot;NETTY_SEVER_TIME&quot;</span>.equals(reqBody)? LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)):<span class="string">&quot;BAD REQUEST&quot;</span>;</span><br><span class="line">        currentTime = currentTime + System.getProperty(<span class="string">&quot;line.separator&quot;</span>);</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">resp</span> <span class="operator">=</span> Unpooled.copiedBuffer(currentTime.getBytes());</span><br><span class="line">        ctx.writeAndFlush(resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelReadComplete....&quot;</span>);</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对服务端的改造是，增加一个全局 int counter 变量，每接收到一次消息就计数一次，然后发送应答给客户端。按设计服务端收到的消息数与客户端发送的消息数应该保持一致。</p><h5 id="4-2-2、NettyTimeClient-改造"><a href="#4-2-2、NettyTimeClient-改造" class="headerlink" title="4.2.2、NettyTimeClient 改造"></a>4.2.2、NettyTimeClient 改造</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorTimeClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> counter;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] req = (<span class="string">&quot;NETTY_SEVER_TIME&quot;</span>+System.getProperty(<span class="string">&quot;line.separator&quot;</span>)).getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">            buf = Unpooled.buffer(req.length);</span><br><span class="line">            buf.writeBytes(req);</span><br><span class="line">            ctx.writeAndFlush(buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        <span class="type">byte</span>[] resp = <span class="keyword">new</span> <span class="title class_">byte</span>[buf.readableBytes()];</span><br><span class="line">        buf.readBytes(resp);</span><br><span class="line">        <span class="type">String</span> <span class="variable">respStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(resp,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;NettyTimeClient receive server response time is：&quot;</span>+respStr + <span class="string">&quot;; the counter is: &quot;</span>+ ++counter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对客户端的改造是，建立连接后，循环发送消息100次，每发送一条消息就刷新一次，保证每条消息都被写入到Channel 中，按设计服务端应该收到客户端的100条查询指令。同时增加一个全局的 countor，每收到一次服务端的应答消息就计数一次，同样地，应该是打印100 次服务端响应的时间消息。</p><h5 id="4-2-3、运行结果"><a href="#4-2-3、运行结果" class="headerlink" title="4.2.3、运行结果"></a>4.2.3、运行结果</h5><p><strong>服务端运行结果如下</strong></p><p><img src="/../assets/blogImg/Netty/4-2-3.png" alt="4-2-3"></p><p> 从服务端的运行结果可以看到，服务端总共只收到两条消息，第一条包含了57条 NETTY_SERVER_TIME 指令，第二条包含43 条指令，总数是100条指令。而与我们期待的结果，100条消息的结果有偏差，这说明 TCP 发生了粘包。</p><p><strong>客户端运行结果如下</strong></p><p><img src="/../assets/blogImg/Netty/4-2-3.1.png" alt="4-2-3.1"></p><p>在设计上，客户端应当收到服务端100条时间消息的响应，但是实际上只收到了1条消息响应。不难理解，结合上面的服务端运行结果可知，因为服务端只收到了两条消息请求指令，由于请求条件不满足指定的指令，所以服务端返回了2条 “ BAD REQUEST ”，而实际上客户端只收到了一条包含了2条 “BAD REQUEST” 的消息，说明 服务端响应的消息也发生了粘包。</p><h4 id="4-3、利用-LineBasedFrameDecoder-解决-TCP-粘包问题"><a href="#4-3、利用-LineBasedFrameDecoder-解决-TCP-粘包问题" class="headerlink" title="4.3、利用 LineBasedFrameDecoder 解决 TCP 粘包问题"></a>4.3、利用 LineBasedFrameDecoder 解决 TCP 粘包问题</h4><h5 id="4-3-1、支持TCP-粘包的TimeServer"><a href="#4-3-1、支持TCP-粘包的TimeServer" class="headerlink" title="4.3.1、支持TCP 粘包的TimeServer"></a>4.3.1、支持TCP 粘包的TimeServer</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoStickyNettyTimeServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">1024</span>));</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NoStickyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 绑定端口，等待同步成功</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> serverBootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">// 等待服务端监听端口关闭</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NoStickyServerHandler 负责网络 I/O 事件处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoStickyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> counter;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">req</span> <span class="operator">=</span> (String) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;The time Server receive the reqesut is : &quot;</span>+req+<span class="string">&quot;; the counter is: &quot;</span>+ ++counter);</span><br><span class="line">        <span class="type">String</span> <span class="variable">currentTime</span> <span class="operator">=</span> <span class="string">&quot;NETTY_SEVER_TIME&quot;</span>.equals(req)? LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)):<span class="string">&quot;BAD REQUEST&quot;</span>;</span><br><span class="line">        currentTime = currentTime + System.getProperty(<span class="string">&quot;line.separator&quot;</span>);</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">resp</span> <span class="operator">=</span> Unpooled.copiedBuffer(currentTime.getBytes());</span><br><span class="line">        ctx.writeAndFlush(resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelReadComplete....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在服务端的代码中 <code>ChannelInitializer</code> 的<code> initChannel</code> 方法，增加 <code>LineBasedFrameDecoder、StringDecoder </code> 两个解码器。而在 <code>NoStickyServerHandler</code> 中，可以直接接收 客户端的消息 msg，不需要处理半包读写，以及消息编码问题。</p><h5 id="4-3-2、支持TCP-粘包的TimeClient"><a href="#4-3-2、支持TCP-粘包的TimeClient" class="headerlink" title="4.3.2、支持TCP 粘包的TimeClient"></a>4.3.2、支持TCP 粘包的TimeClient</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoStickyNettyTimeClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(String address, <span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 配置客户端 NIO 线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">clientGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(clientGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY,<span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">1024</span>));</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NoStickyClinetHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 发送异步连接操作</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(address,port).sync();</span><br><span class="line">            <span class="comment">// 等待客户端链路关闭</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            clientGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NoStickyClinetHandler 负责客户端网络 I/O 事件处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoStickyClinetHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> counter;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] req = (<span class="string">&quot;NETTY_SEVER_TIME&quot;</span>+System.getProperty(<span class="string">&quot;line.separator&quot;</span>)).getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">            buf = Unpooled.buffer(req.length);</span><br><span class="line">            buf.writeBytes(req);</span><br><span class="line">            ctx.writeAndFlush(buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">respStr</span> <span class="operator">=</span> (String) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;NettyTimeClient receive server response time is：&quot;</span>+respStr + <span class="string">&quot;; the counter is: &quot;</span>+ ++counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同样地，客户端也增加 <code>LineBasedFrameDecoder、StringDecoder </code> 两个解码器</p><p><strong>最终的运行结果：</strong></p><p>最终的运行结果是符合预期，服务端和客户端均分别收到了100请求消息和响应消息。</p><h5 id="4-3-3、LineBasedFrameDecoder-和-StringDecoder-的原理分析"><a href="#4-3-3、LineBasedFrameDecoder-和-StringDecoder-的原理分析" class="headerlink" title="4.3.3、LineBasedFrameDecoder 和 StringDecoder 的原理分析"></a>4.3.3、LineBasedFrameDecoder 和 StringDecoder 的原理分析</h5><p><code>LineBasedFrameDecoder</code> 的工作原理是依次变量 ByteBuf 的可读字节，判断是否存在 “\n”、“\r\n”，如果有，则以此位置结束，从可读索引到结束位置区间的字节就组成了一行。他是以换行符作为结束标志的解码器，支持携带结束符或不携带结束符两种解码方式，同时支持配置单行最大长度。如果连续读取到最大长度仍然没有发现换行符，则抛出异常，同时忽略之前读到的异常码流。</p><p><code>StringDecoder</code> 的功能很简单，就是将接收到的对象转换成字符，并调用后面的 handler。<code>LineBasedFrameDecoder</code>+ <code>StringDecoder</code> 组合就是按行切换文本解码器，它被设计用来支持 TCP 的粘包和拆包。</p><h3 id="五、分隔符和定长解码器的应用"><a href="#五、分隔符和定长解码器的应用" class="headerlink" title="五、分隔符和定长解码器的应用"></a>五、分隔符和定长解码器的应用</h3><p>TCP 以流的方式传输数据，上层应用协议为了方便对消息区分，采用如下4种方式：</p><ol><li>消息为固定长度，累计读取到的长度总和为定长 LEN 的报文后，就认为读取到一个完整的消息；将计数器复位，重新开始下一个数据报。</li><li>将回车换行符作为消息结束位置，如FTP 协议，这种方式在文本协议应用广泛</li><li>将特殊的分隔符作为消息的结束标志，回车换行就是一种特殊的结束分隔符。</li><li>通过在消息头定义长度字段来标识消息的总长度。</li></ol><p>在 Netty 中，对上面4种应用做了统一抽象，提供了 4 种解码器来解决对应的问题。</p><h4 id="5-1、DelimiterBasedFrameDecoder-应用开发"><a href="#5-1、DelimiterBasedFrameDecoder-应用开发" class="headerlink" title="5.1、DelimiterBasedFrameDecoder 应用开发"></a>5.1、DelimiterBasedFrameDecoder 应用开发</h4><p>使用 <code>DelimiterBasedFrameDecoder </code> 可以自动完成以分隔符作为码流结束标识的消息解码。</p><h5 id="5-1-1、DelimiterBasedFrameDecoder-服务端代码"><a href="#5-1-1、DelimiterBasedFrameDecoder-服务端代码" class="headerlink" title="5.1.1、DelimiterBasedFrameDecoder 服务端代码"></a>5.1.1、DelimiterBasedFrameDecoder 服务端代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 初始化线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化服务端启动工具</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 临时存放已完成三次握手的请求的队列的最大长度。</span></span><br><span class="line">                    <span class="comment">// 如果未设置或所设置的值小于1，Java将使用默认值50。</span></span><br><span class="line">                    <span class="comment">// 如果大于队列的最大长度，请求会被拒绝</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                    .group(bossGroup,workerGroup)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel serverChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">delimiter</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;$_&quot;</span>.getBytes());</span><br><span class="line">                            serverChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">DelimiterBasedFrameDecoder</span>(<span class="number">1024</span>,delimiter));</span><br><span class="line">                            serverChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            serverChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">EchoServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 绑定端口，同步等待</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> serverBootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">// 等待服务端监听绑定端口关闭</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 退出线程组</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// EchoServerHandler 处理服务端网络 I/O 事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> counter;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">req</span> <span class="operator">=</span> (String) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is &quot;</span>+ ++counter+<span class="string">&quot; times The EchoServer receive msg is: [ &quot;</span>+req+<span class="string">&quot; ]&quot;</span>);</span><br><span class="line">        <span class="comment">// 因为 DelimiterBasedFrameDecoder 过滤了分隔符，所以返回给客户端时，需要在消息尾部拼接分隔符 $_</span></span><br><span class="line">        req = req+<span class="string">&quot; I&#x27;m Server!$_&quot;</span>;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(req.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>值服务端代码中，主要是创建 <code>DelimiterBasedFrameDecoder </code> 对象并增加到 <code>ChannelPipeline</code> 中。<code>DelimiterBasedFrameDecoder</code> 有多个构造方法，例程中，我们传递了两个参数，一个为 1024，表示单条消息最大长度，当达到最大长度仍然没有查找到分隔符，就会抛出 <code>TooLongFrameException</code> 异常，防止由于异常码流缺失分隔符导致内存溢出，这是 Netty 解码器可靠性保护；第二个参数为分隔符的缓冲对象。</p><h5 id="5-1-2、DelimiterBasedFrameDecoder-客户端代码"><a href="#5-1-2、DelimiterBasedFrameDecoder-客户端代码" class="headerlink" title="5.1.2、DelimiterBasedFrameDecoder 客户端代码"></a>5.1.2、DelimiterBasedFrameDecoder 客户端代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(String host, <span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 初始化 NIO 线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">clientGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化 NIO 客户端辅助工具类</span></span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(clientGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY,<span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">delimiter</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;$_&quot;</span>.getBytes());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">DelimiterBasedFrameDecoder</span>(<span class="number">1024</span>*<span class="number">3</span>,delimiter));</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">EchoClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发起异步连接</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> bootstrap.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(host,port)).sync();</span><br><span class="line">            <span class="comment">// 等待客户端关闭连接</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            clientGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理客户端网络 I/O 事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> counter;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello,Sinin! welcome to netty world!$_&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            ctx.writeAndFlush(Unpooled.copiedBuffer(msg.getBytes()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is &quot;</span>+ ++counter+<span class="string">&quot; time client receive the message is: &quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与服务端一样，创建 <code>DelimiterBasedFrameDecoder </code> 对象并增加到 <code>ChannelPipeline</code> 中。然后循环发送消息到服务端。</p><p>最后运行结果如下：</p><p><img src="/../assets/blogImg/Netty%5C5-1.png" alt="5-1"></p><p><img src="/../assets/blogImg/Netty/5-2.png" alt="5-2"></p><h4 id="5-2、FixedLengthFrameDecoder-应用开发"><a href="#5-2、FixedLengthFrameDecoder-应用开发" class="headerlink" title="5.2、FixedLengthFrameDecoder 应用开发"></a>5.2、FixedLengthFrameDecoder 应用开发</h4><p>FixedLengthFrameDecoder 是固定长度的解码器，它能够按指定长度对消息进行解码，开发者不需要考虑 TCP 粘包&#x2F;拆包问题。</p><h5 id="5-2-1-、FixedLengthFrameDecoder-服务端"><a href="#5-2-1-、FixedLengthFrameDecoder-服务端" class="headerlink" title="5.2.1 、FixedLengthFrameDecoder 服务端"></a>5.2.1 、FixedLengthFrameDecoder 服务端</h5><p>在服务端的 ChannelPipeline 中增加 <code>FixedLengthFrameDecoder </code> 长度为 20 ，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedLenFrameServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 初始化线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化服务端启动工具</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 临时存放已完成三次握手的请求的队列的最大长度。</span></span><br><span class="line">                    <span class="comment">// 如果未设置或所设置的值小于1，Java将使用默认值50。</span></span><br><span class="line">                    <span class="comment">// 如果大于队列的最大长度，请求会被拒绝</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                    .group(bossGroup,workerGroup)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel serverChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">delimiter</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;$_&quot;</span>.getBytes());</span><br><span class="line">                            serverChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">20</span>));</span><br><span class="line">                            serverChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            serverChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">EchoServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 绑定端口，同步等待</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> serverBootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">// 等待服务端监听绑定端口关闭</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 退出线程组</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用固定长度解码器 <code>FixedLengthFrameDecoder </code> ， 无论一次接收到多少数据报，都会按照构造函数中设置的固定长度进行解码，如果是半包消息，会缓存半包消息等待下一个包到达后再进行拼包，直到读取到一个完整的包。</p><h5 id="5-2-2、使用-telnet-命令测试-FixedLenFrameServer-服务"><a href="#5-2-2、使用-telnet-命令测试-FixedLenFrameServer-服务" class="headerlink" title="5.2.2、使用 telnet 命令测试 FixedLenFrameServer 服务"></a>5.2.2、使用 telnet 命令测试 FixedLenFrameServer 服务</h5><p>同 cmd 打开命令窗口，输入<code>telnet localhost 8082 </code> 命令，连接 FixedLenFrameServer 服务。</p><p><img src="/../assets/blogImg/Netty/5-3.png" alt="5-3"></p><p>telnet 连接成功后通过<code>CTRL + ]</code>打开 设置界面，通过 <code>set localecho</code> 命令开启本地回显。</p><p><img src="/../assets/blogImg/Netty/5-4.png" alt="5-4"></p><p>输入如下内容</p><p><img src="/../assets/blogImg/Netty/5-5.png" alt="5-5"></p><p>服务端收到的内容，发现完全符合<code>FixedLengthFrameDecoder</code> 定长解码器按照20 个字节长度对请求消息进行截取。</p><p><img src="/../assets/blogImg/Netty/5-6.png" alt="5-6"></p><h3 id="六、编解码技术"><a href="#六、编解码技术" class="headerlink" title="六、编解码技术"></a>六、编解码技术</h3><p>基于Java 提供的对象输入&#x2F;输出流 ObjectInpuStream、ObjectOutputStream，可以直接把 Java 对象作为可存储的字节数组写入到文件，也可以传输到网络上。基于 JDK 默认的序列化机制可以避免操作底层的字节数组，从而提升开发效率。</p><p>Java 序列化对象的目的：</p><ul><li>网络传输</li><li>持久化对象</li></ul><p>**Java 对象编解码技术：**当进行远程跨进程调用时，需要把被传输的 Java 对象编码为字节数组或者ByteBuffer 对象。而当远程服务读取到字节数组或者ByteBuffer 对象时，需要将其解码为发送时的Java 对象。这被称为Java 对象编解码技术。</p><p>Java 序列化仅仅是Java 编解码技术中的一种，由于它的种种缺陷，衍生出多种编解码技术和框架。接下来会结合Netty 介绍业界主流的编解码技术和框架。</p><h4 id="6-1、Java-序列化的缺点"><a href="#6-1、Java-序列化的缺点" class="headerlink" title="6.1、Java 序列化的缺点"></a>6.1、Java 序列化的缺点</h4><p>Java 序列化从 JDK 1.1 就已经提供，不需要添加额外的类库，只需要继承 java.io.Serializable 接口并生成序列 ID 即可。</p><p>缺点：</p><ul><li>无法跨语言</li><li>序列化后码流太大</li><li>序列化性能太低</li></ul><h4 id="6-2、业界主流的编解码框架"><a href="#6-2、业界主流的编解码框架" class="headerlink" title="6.2、业界主流的编解码框架"></a>6.2、业界主流的编解码框架</h4><h5 id="6-2-1、Google-Protobuf-介绍"><a href="#6-2-1、Google-Protobuf-介绍" class="headerlink" title="6.2.1、Google Protobuf 介绍"></a>6.2.1、Google Protobuf 介绍</h5><p>Protobuf 全称 Protocol Buffers，由 Google 开源而来，它将数据结构以 .proto 文件进行描述，通过代码生成工具生成对应的数据结构 POJO 对象和 Protocol 相关的方法和属性。</p><p>它的特点如下：</p><ul><li>结构化数据存储格式（XML，JSON 等）</li><li>高效的编解码性能</li><li>语言无关、平台无关、扩展性好</li><li>官方支持 Java、C++ 和 Python</li></ul><p>利用数据描述文件对数据结构进行说明的有点如下：</p><ul><li>文本化的数据结构描述语言，可以实现语言和平台无关，适合异构系统间的集成。</li><li>通过标识字段的顺序，可以实现协议的向前兼容。</li><li>自动代码生成，不需要手工编写同样数据结构的 Java 和 C++ 版本。</li><li>方便后续的管理和维护。相比代码，结构化的代码和文档更易于维护。</li></ul><h5 id="6-2-2、Facebook-的-Thrift-介绍"><a href="#6-2-2、Facebook-的-Thrift-介绍" class="headerlink" title="6.2.2、Facebook 的 Thrift 介绍"></a>6.2.2、Facebook 的 Thrift 介绍</h5><p>Thrift 源于 Facebook，创造 Thrift 主要是解决各系统间大数据量的传输通信以及系统之间语言环境不同需要跨平台的特性。</p><p>能在多种语言之间通信，Thrift 可以作为高性能的通信中间件使用，他支持数据（对象）序列化和多种类型的RPC 服务。</p><p>Thrift 主要有5 部分组成：</p><ul><li>语言系统以及IDL编译器：负责由用户给定的 IDL 文件生成相应语言的接口代码；</li><li>TProtocol : RPC 的协议层，可选择多种不同的对象序列化方式，如 JSON 和 Binary；</li><li>TTransport : RPC 的传输层，同样可以选择不同的传输层实现，如 socket、NIO、MemoryBuffer 等；</li><li>TProcessor： 作为协议层和用户提供的服务实现之间的纽带，负责调用服务实现的接口；</li><li>TServer：聚合 TProtoco、TTransport 和 TProcessor 等对象。</li></ul><p>Thrift 支持的编解码方式：</p><ul><li>通用的二进制编解码</li><li>压缩二进制编解码</li><li>优化的可选字段压缩编解码</li></ul><h5 id="6-2-3、JBoss-Marshalling-介绍"><a href="#6-2-3、JBoss-Marshalling-介绍" class="headerlink" title="6.2.3、JBoss Marshalling 介绍"></a>6.2.3、JBoss Marshalling 介绍</h5><p>JBoss Marshalling 是一个 Java 对象的序列化 API 包，修正了 JDK 自带的序列化包的很多问题，但又保持和<code>java.io.Seriablizable</code>  接口的兼容。同时增加可调参数和附加特性，并且这些参数和特性可通过工厂类进行配置。</p><p>相比传统 Java 序列化机制，其优点如下：</p><ul><li>可插拔的类解析器，提供更加便捷的类加载定制策略，通过一个接口即可定制；</li><li>可插拔的对象替换技术，不需要通过继承方式；</li><li>可插拔的预定义类缓存表，可以减小序列化的字节数组长度，提升常用类型的对象序列化性能；</li><li>无需实现 <code>java.io.Seriablizable</code> 接口，即可实现 Java 序列化；</li><li>通过缓存技术提升对象的序列化性能。</li></ul><p>相比前两种编解码框架，JBoss Marshalling  更多是在 JBoss 内部使用。</p><h3 id="七、MessagePack-编解码"><a href="#七、MessagePack-编解码" class="headerlink" title="七、MessagePack 编解码"></a>七、MessagePack 编解码</h3><p>MessagePack 是一个高效的二进制序列化框架，它像 JSON 一样支持不同语言间的数据交换，但是性能更快，序列化后的码流更小。</p><p>特点：</p><ul><li>编解码高效，性能高。</li><li>序列化后的码流小。</li><li>支持跨语言。</li></ul><h4 id="7-1-MessagePack-编解码器开发"><a href="#7-1-MessagePack-编解码器开发" class="headerlink" title="7.1 MessagePack 编解码器开发"></a>7.1 MessagePack 编解码器开发</h4><p>Netty 的编解码框架可以非常方便地集成第三方序列化框架，或者自定义。</p><h5 id="7-1-1-MessagePack-编码器开发"><a href="#7-1-1-MessagePack-编码器开发" class="headerlink" title="7.1.1 MessagePack 编码器开发"></a>7.1.1 MessagePack 编码器开发</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承  MessageToByteEncoder 负责将 Object 对象编码为byte 数组。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgpackEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Object o, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MessagePack</span> <span class="variable">msgpack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessagePack</span>();</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        <span class="type">byte</span>[] raw = msgpack.write(o);</span><br><span class="line">        byteBuf.writeBytes(raw);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="7-1-2-MessagePack-解码器开发"><a href="#7-1-2-MessagePack-解码器开发" class="headerlink" title="7.1.2 MessagePack 解码器开发"></a>7.1.2 MessagePack 解码器开发</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 ByteBuf 中获取需要解密的字节数组，通过 MessagePack 的 read 方法反序列化为相应的对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgpackDecoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageDecoder</span>&lt;ByteBuf&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] raw = <span class="keyword">new</span> <span class="title class_">byte</span>[byteBuf.readableBytes()];</span><br><span class="line">        byteBuf.getBytes(byteBuf.readerIndex(),raw,<span class="number">0</span>,raw.length);</span><br><span class="line">        <span class="type">MessagePack</span> <span class="variable">msgpack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessagePack</span>();</span><br><span class="line">        list.add(msgpack.read(raw));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-1-3-集成Netty-功能测试"><a href="#7-1-3-集成Netty-功能测试" class="headerlink" title="7.1.3 集成Netty 功能测试"></a>7.1.3 集成Netty 功能测试</h5><p>Netty 服务端 代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgpackServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 初始化线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;mesgpack Decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">MsgpackDecoder</span>());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;mesgpack Encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">MsgpackEncoder</span>());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">MsgpackServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 绑定端口同步等待</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> serverBootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">// 等待服务监听绑定端口关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 负责网络事件消息处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgpackServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MsgpackServerHandler receive the msg : &quot;</span>+msg);</span><br><span class="line">        ctx.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgpackClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(String address, <span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 初始化线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">loopGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(loopGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY,<span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;MessagePack Decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">MsgpackDecoder</span>());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;MessagePack Encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">MsgpackEncoder</span>());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">MsgpackClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> bootstrap.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(address,port)).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            loopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端网络事件消息处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgpackClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">            <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfo</span>();</span><br><span class="line">            userInfo.setName(<span class="string">&quot;client=&gt;&quot;</span>+i);</span><br><span class="line">            userInfo.setAge(<span class="number">18</span>);</span><br><span class="line">            userInfo.setAddress(<span class="string">&quot;China&quot;</span>);</span><br><span class="line">            userInfo.setContact(<span class="string">&quot;86&quot;</span>);</span><br><span class="line">            ctx.write(userInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Client receive the msg : &quot;</span>+msg);</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：消息传输对象UserInfo 应该添加@Message 注解否则会在 MessageToByteEncoder 的 writeBytes 方法中报错</strong></p><h4 id="7-2、粘包-半包支持"><a href="#7-2、粘包-半包支持" class="headerlink" title="7.2、粘包&#x2F;半包支持"></a>7.2、粘包&#x2F;半包支持</h4><p>利用 Netty 提供的 <code>LengthFieldPrepender</code> 和 <code>LengthFieldBasedFrameDecoder</code> 结合MessagePack 编解码框架，实现对 TCP 粘包&#x2F;半包支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 初始化线程组</span></span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">        serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">// 增加 LengthFieldBasedFrameDecoder 解码器处理粘包/拆包问题</span></span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="string">&quot;frameDecoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">65535</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="string">&quot;MessagePack Decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">MsgpackDecoder</span>());</span><br><span class="line">                        <span class="comment">// 增加 LengthFieldPrepender 编码器处理粘包/拆包问题</span></span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="string">&quot;frameEnder&quot;</span>,<span class="keyword">new</span> <span class="title class_">LengthFieldPrepender</span>(<span class="number">2</span>));</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="string">&quot;MessagePack Encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">MsgpackEncoder</span>());</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">MsgpackServerHandler</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 绑定端口同步等待</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> serverBootstrap.bind(port).sync();</span><br><span class="line">        <span class="comment">// 等待服务监听绑定端口关闭</span></span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合 MessagePack 编解码框架支持TCP 粘包&#x2F;拆包问题比较简单，只需在 <code>ChannelInitializer</code> 的 <code>initChannel</code> 中添加 <code>LengthFieldPrepender</code> 和 <code>LengthFieldBasedFrameDecoder</code>即可。同样地，在客户端也应添加相应的编解码器。</p><p>在 MessagePack 编码器<strong>之前（主要编解码器的添加顺序）</strong> 增加 <code>LengthFieldPrepender</code> ，它将在 ByteBuf 之前增加 2个字节的消息长度，其原理如下：</p><p><img src="/../assets/blogImg/Netty/7-1.png" alt="7-1"></p><p>在 MessagePack 解码器之前增加 <code>LengthFieldBasedFrameDecoder</code> ，用于处理半包消息，这样后面 MessagePack 收到的永远是整包消息。</p><p><img src="/../assets/blogImg/Netty/7-2.png" alt="7-2"></p><h3 id="八、Google-Protobuf-编解码"><a href="#八、Google-Protobuf-编解码" class="headerlink" title="八、Google Protobuf 编解码"></a>八、Google Protobuf 编解码</h3><p>Google Protobuf 在业界非常流行，很多项目选择的Protobuf 作为编解码框架，<strong>其优点如下：</strong></p><ul><li>在谷歌内部长期使用，产品成熟度高</li><li>跨语言，支持多种语言，包括 C++ 、Java 和 Python</li><li>编码后的消息更小，更加有利于传输和存储</li><li>编解码性能非常高</li><li>支持不同协议版本的向前兼容</li><li>支持定义可以选和必选字段</li></ul><h4 id="8-1、Protobuf-入门"><a href="#8-1、Protobuf-入门" class="headerlink" title="8.1、Protobuf 入门"></a>8.1、Protobuf 入门</h4><p>1、首先下载 Protobuf 编译器，下载地址为：<a href="https://github.com/protocolbuffers/protobuf/releases%EF%BC%8C%E9%80%89%E6%8B%A9%E5%AF%B9%E5%BA%94%E5%B9%B3%E5%8F%B0%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%EF%BC%8C%E7%84%B6%E5%90%8E%E8%A7%A3%E5%8E%8B%E5%88%B0%E7%89%B9%E5%AE%9A%E7%9A%84%E7%9B%AE%E5%BD%95%E3%80%82%E6%8A%8A%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%96%87%E4%BB%B6%60protoc.exe">https://github.com/protocolbuffers/protobuf/releases，选择对应平台以及版本下载，然后解压到特定的目录。把下载的文件`protoc.exe</a> <code>所在的文件夹添加到环境变量。打开cmd命令行输入</code>protoc –version &#96; ，如果输出版本号，说明配置成功。</p><p><code>protoc.exe</code> 工具主要根据 .proto 文件生成代码。</p><p>2、创建 .proto 文件，定义数据结构（message 关键字后面跟上消息名称）</p><blockquote><p>syntax &#x3D; “”</p><p>message xxx {</p><p>&#x2F;&#x2F; 字段规则：required -&gt; 字段只能也必须出现 1 次</p><p>&#x2F;&#x2F; 字段规则：optional -&gt; 字段可出现 0 次或1次</p><p>&#x2F;&#x2F; 字段规则：repeated -&gt; 字段可出现任意多次（包括 0）</p><p>&#x2F;&#x2F; 类型：int32、int64、sint32、sint64、string、32-bit ….</p><p>&#x2F;&#x2F; 字段编号：0 ~ 536870911（除去 19000 到 19999 之间的数字）</p><p>字段规则 类型 名称 &#x3D; 字段编号;<br>}</p></blockquote><p>分别新建<code>SubscribeReq</code>和<code>SubscribeResp</code> 两个 proto 文件，代码如下。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.study.netty.proto&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;SubscribeReq&quot;</span>;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">ClientReq</span>&#123;</span><br><span class="line">    <span class="type">int32</span> subReqID = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> userName = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> productName = <span class="number">3</span>;</span><br><span class="line">    <span class="type">string</span> address = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.study.netty.proto&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;SubscribeRep&quot;</span>;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Respponse</span>&#123;</span><br><span class="line">    <span class="type">int32</span> subReqID = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int32</span> respCode = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> desc = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：1、protobuf2 和 protobuf3 语法不同， protobuf3 仅仅支持 repeated 字段，如果使用 optional 、required 编译会报错； 2、java_outer_classname 中的名字和 message中的名字不能重名，否则会报 protobuf matches the name of one of the types declared inside it 错误。</strong></p><p>最终通过 idea protobuf 插件或者直接运行 <code>protc</code>或者通过 protobuf maven 插件 compile 编译指令得到 编译结果如下：</p><p><img src="/../assets/blogImg/Netty/8-1.png" alt="8-1"></p><h4 id="8-2-、Netty-的-Protobuf-服务端开发"><a href="#8-2-、Netty-的-Protobuf-服务端开发" class="headerlink" title="8.2 、Netty 的 Protobuf 服务端开发"></a>8.2 、Netty 的 Protobuf 服务端开发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscribeServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 初始化线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;Protobuf frame decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">ProtobufVarint32FrameDecoder</span>());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;Protobuf decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">ProtobufDecoder</span>(SubscribeReq.ClientReq.getDefaultInstance()));</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;Protobuf frame encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">ProtobufVarint32LengthFieldPrepender</span>());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;Protobuf encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">ProtobufEncoder</span>());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SubcribeServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 绑定端口，同步等待成功</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> serverBootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">// 等待服务端绑定监听端口关闭</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SubcribeServerHandler 处理网络 I/O 事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubcribeServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        SubscribeReq.<span class="type">ClientReq</span> <span class="variable">req</span> <span class="operator">=</span> (SubscribeReq.ClientReq) msg;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;hello&quot;</span>.equals(req.getUserName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Service accept client subscribe req is: [ &quot;</span>+req.toString() +<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            SubscribeResp.<span class="type">Respponse</span> <span class="variable">resp</span> <span class="operator">=</span> createSubscribeResp(req.getSubReqID());</span><br><span class="line">            ctx.writeAndFlush(resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SubscribeResp.Respponse <span class="title function_">createSubscribeResp</span><span class="params">(<span class="type">int</span> subReqID)</span> &#123;</span><br><span class="line">        SubscribeResp.Respponse.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> SubscribeResp.Respponse.newBuilder();</span><br><span class="line">        builder.setSubReqID(subReqID);</span><br><span class="line">        builder.setRespCode(<span class="number">0</span>);</span><br><span class="line">        builder.addDesc(<span class="string">&quot;Netty book order succeed, 3 day later, send to the designated address.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ChannelPipeline 添加 <code>ProtobufVarint32FrameDecoder</code>，主要用于半包处理，添加<code>ProtobufDecoder</code> 是用于消息的自动解码。</p><h4 id="8-3、Netty-的-Protobuf-客户端开发"><a href="#8-3、Netty-的-Protobuf-客户端开发" class="headerlink" title="8.3、Netty 的 Protobuf 客户端开发"></a>8.3、Netty 的 Protobuf 客户端开发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscribeClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(String host, <span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 初始化线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">loopGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(loopGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY,<span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;Protobuf frame decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">ProtobufVarint32FrameDecoder</span>());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;Protobuf decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">ProtobufDecoder</span>(SubscribeResp.Respponse.getDefaultInstance()));</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;Protobuf frame encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">ProtobufVarint32LengthFieldPrepender</span>());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;Protobuf encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">ProtobufEncoder</span>());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SubcribeClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 发起异步连接</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> bootstrap.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(host,port)).sync();</span><br><span class="line">            <span class="comment">// 同步等待客户端关闭连接</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            loopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SubcribeClientHandler 负责客户端网络 I/O 事件处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubcribeClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">            SubscribeReq.<span class="type">ClientReq</span> <span class="variable">req</span> <span class="operator">=</span> createClientReq(i);</span><br><span class="line">            ctx.writeAndFlush(req);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SubscribeReq.ClientReq <span class="title function_">createClientReq</span><span class="params">(<span class="type">int</span> reqId)</span>&#123;</span><br><span class="line">        SubscribeReq.ClientReq.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> SubscribeReq.ClientReq.newBuilder();</span><br><span class="line">        builder.setSubReqID(reqId);</span><br><span class="line">        builder.setProductName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        builder.setUserName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        List&lt;String&gt; address = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        address.add(<span class="string">&quot;BeiJing&quot;</span>);</span><br><span class="line">        address.add(<span class="string">&quot;Guangdong&quot;</span>);</span><br><span class="line">        address.add(<span class="string">&quot;ShengZhen&quot;</span>);</span><br><span class="line">        builder.addAllAddress(address);</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        SubscribeResp.<span class="type">Respponse</span> <span class="variable">resp</span> <span class="operator">=</span> (SubscribeResp.Respponse) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;Client receive the order response : [ &quot;</span>+resp.toString()+<span class="string">&quot; ]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="九、JBoss-Marshalling-编解码"><a href="#九、JBoss-Marshalling-编解码" class="headerlink" title="九、JBoss Marshalling 编解码"></a>九、JBoss Marshalling 编解码</h3><p>JBoss Marshalling 是一个 Java 对象序列化包，对 JDK 默认的序列化框架进行了优化，但又保持了更 java.io.Serializable 接口的兼容，同时增加一些可调的参数和附加特性。</p><h4 id="9-1、开发准备"><a href="#9-1、开发准备" class="headerlink" title="9.1、开发准备"></a>9.1、开发准备</h4><p>maven 依赖 JBoss Marshalling </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.jboss.marshalling&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jboss-marshalling&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.12.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.jboss.marshalling&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jboss-marshalling-serial&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.12.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="9-2、Netty-的-Marshalling-服务端开发"><a href="#9-2、Netty-的-Marshalling-服务端开发" class="headerlink" title="9.2、Netty 的 Marshalling 服务端开发"></a>9.2、Netty 的 Marshalling 服务端开发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarshallingServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 初始化线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                           <span class="comment">// 添加 MarshallingDecoder 解码器</span></span><br><span class="line">                           socketChannel.pipeline().addLast(MarshallingCodeFactory.buildMarshallingDecode());</span><br><span class="line">                            <span class="comment">// 添加 MarshallingEncoder 编码器  </span></span><br><span class="line">                            </span><br><span class="line">socketChannel.pipeline().addLast(MarshallingCodeFactory.buildMarshallingEncoder());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SubcribeServerHandler</span>());</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> serverBootstrap.bind(port).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Marshalling 编解码器工厂类，用于创建MarshallingDecoder 和 MarshallingEncoder </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarshallingCodeFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 JBoss Marshalling 解码器 MarshallingDecoder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MarshallingDecoder <span class="title function_">buildMarshallingDecode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">MarshallerFactory</span> <span class="variable">marshallerFactory</span> <span class="operator">=</span> Marshalling.getProvidedMarshallerFactory(<span class="string">&quot;serial&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">MarshallingConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MarshallingConfiguration</span>();</span><br><span class="line">        configuration.setVersion(<span class="number">5</span>);</span><br><span class="line">        <span class="type">UnmarshallerProvider</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultUnmarshallerProvider</span>(marshallerFactory,configuration);</span><br><span class="line">        <span class="type">MarshallingDecoder</span> <span class="variable">decoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MarshallingDecoder</span>(provider,<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">return</span> decoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 JBoss Marshalling 编码器 MarshallingEncoder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MarshallingEncoder <span class="title function_">buildMarshallingEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">MarshallerFactory</span> <span class="variable">marshallerFactory</span> <span class="operator">=</span> Marshalling.getProvidedMarshallerFactory(<span class="string">&quot;serial&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">MarshallingConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MarshallingConfiguration</span>();</span><br><span class="line">        configuration.setVersion(<span class="number">5</span>);</span><br><span class="line">        <span class="type">MarshallerProvider</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMarshallerProvider</span>(marshallerFactory,configuration);</span><br><span class="line">        <span class="type">MarshallingEncoder</span> <span class="variable">encoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MarshallingEncoder</span>(provider);</span><br><span class="line">        <span class="keyword">return</span> encoder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 ChannelPipeline 中添加 Marshalling 的 解码器以及编码器，其中<code>SubcribeServerHandler</code> 网络 I&#x2F;O 事件处理和第8章的例程一样。</p><h4 id="9-3、Netty-的-Marshalling-客户端开发"><a href="#9-3、Netty-的-Marshalling-客户端开发" class="headerlink" title="9.3、Netty 的 Marshalling 客户端开发"></a>9.3、Netty 的 Marshalling 客户端开发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarshallingClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(String host, <span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 初始化线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">loopGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(loopGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY,<span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(MarshallingCodeFactory.buildMarshallingDecode());</span><br><span class="line">                            socketChannel.pipeline().addLast(MarshallingCodeFactory.buildMarshallingEncoder());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SubcribeClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> bootstrap.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(host,port)).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            loopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的在开户端的代码中在ChannelPipeline 中也通过添加 Marshalling 的编解码器</p><h3 id="十、HTTP-协议开发应用"><a href="#十、HTTP-协议开发应用" class="headerlink" title="十、HTTP 协议开发应用"></a>十、HTTP 协议开发应用</h3><h4 id="10-1、HTTP-协议介绍"><a href="#10-1、HTTP-协议介绍" class="headerlink" title="10.1、HTTP 协议介绍"></a>10.1、HTTP 协议介绍</h4><p>HTTP（超文本传输协议）是建立在TCP传输协议之上的属于应用层的面向对象的协议，其主要特点如下：</p><ul><li>支持 Client&#x2F;Server 模式；</li><li>简单—— 客户向服务器发送请求服务时，只需指定服务URL，携带必要的请求参数或者消息体；</li><li>灵活—— HTTP 允许传输任意类型的数据对象，传输内容类型由HTTP 消息头中的Content-Type 加以标记；</li><li>无状态—— HTTP协议是无状态协议，无状态是指对事务处理没有记忆能力。缺少状态意味着如果后续处理需要之前的信息，则它需要重传，这样导致每次连接传输的数据量变大。另一方面，在服务器不需要先前信息时它的应答就较快，负载较轻。</li></ul><h5 id="10-1-1、HTTP-协议的-URL"><a href="#10-1-1、HTTP-协议的-URL" class="headerlink" title="10.1.1、HTTP 协议的 URL"></a>10.1.1、HTTP 协议的 URL</h5><p>HTTP URL（URL 是一种特殊类型的 URI，包含了查询某个资源的足够信息）格式如下：</p><p><code>http://host[“:”port][abs_path]</code></p><p>http 表示要通过 HTTP 协议来定位网络资源；</p><p>host 表示合法的 Internet 主机域名或者 IP 地址；</p><p>port 表示一个指定的端口号，空则默认为 80；</p><p>asb_path 表示指定请求资源的 URI ；</p><h5 id="10-1-2、HTTP-请求消息（HttpRequest"><a href="#10-1-2、HTTP-请求消息（HttpRequest" class="headerlink" title="10.1.2、HTTP 请求消息（HttpRequest)"></a>10.1.2、HTTP 请求消息（HttpRequest)</h5><p>HTTP 请求的三部分组成如下：</p><ul><li>HTTP 请求行；</li><li>HTTP 请求头；</li><li>HTTP 请求正文；</li></ul><p>请求行以一个方法符开头，以空格分开，后面跟着请求的URI 和协议版本，格式为： Method  Request-URI  HTTP-Version CRLF。如：<code>GET /netty5.0 HTTP/1.1</code></p><p>Method 请求方法有多种，各方法作用如下：</p><ul><li><p>GET：请求获取 Request-URI 所标识的资源；</p></li><li><p>POST：在 Request-URI 所标识的资源后附件新的提交数据；</p></li><li><p>HEAD：请求获取由 Request-URI 所标识的资源的响应消息报头；</p></li><li><p>PUT：请求服务器存储一个资源，并用 Request-URI 作为其标识；</p></li><li><p>DELETE：请求服务器删除 Request-URI 所标识的资源；</p></li><li><p>TRACE：请求服务器返回所接收到的信息，主要用于诊断或测试；</p></li><li><p>CONNECT：保留将来使用；</p></li><li><p>OPTION：请求查询服务器性能，或查询与资源相关的选项和需求。</p></li></ul><h4 id="10-2、Netty-HTTP-服务端入门开发"><a href="#10-2、Netty-HTTP-服务端入门开发" class="headerlink" title="10.2、Netty HTTP 服务端入门开发"></a>10.2、Netty HTTP 服务端入门开发</h4><p>由于Netty 天生是异步事件驱动框架，因此基于NIO TCP 协议栈开发的Http 协议栈也是异步非阻塞的。</p><p>Netty 的 HTTP 协议栈无论是在性能还是可靠性上，都表现优异，非常适合在非Web 容器的场景下使用，相比传统的 Tomcat、Jetty 等 Web 容器，它更加轻量和小巧，灵活性和定制性也更好。</p><p><strong>例程场景描述：</strong></p><p>以文件服务器为例学习Netty 的 Http 服务端开发入门，场景如下：</p><p>文件服务器使用Http 协议对外提供服务，当客户端通过浏览器访问文件服务器时，对访问路径进行检查，检查失败时返回 403；</p><p>校验通过，以链接的方式打开文件目录，每个目录或者文件都是一个超链接，可以递归访问；</p><p>如果是目录，可以递归访问他的子目录或者文件，如果文件可读，则可以在浏览器端直接打开，或通过【目标另存为】下载文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpFileServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_URL</span> <span class="operator">=</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span>&#123;</span><br><span class="line">        <span class="type">HttpFileServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpFileServer</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server.start(DEFAULT_URL,<span class="number">8080</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(String url, <span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 初始化线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;http-decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;http-aggregator&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">65536</span>));</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;http-encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpResponseEncoder</span>());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;http-Chunked&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>());</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="string">&quot;fileserverHandler&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpFileServerHandler</span>(url));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> serverBootstrap.bind(<span class="string">&quot;127.0.0.1&quot;</span>,port).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;Http 文件目录服务器启动，网址为：http://127.0.0.1:&quot;</span>+port+url);</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HttpFileServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;FullHttpRequest&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> String url;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">HttpFileServerHandler</span><span class="params">(String url)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.url = url;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 对请求消息进行解码判断，如果解码失败，构造响应返回 400 错误</span></span><br><span class="line">            <span class="keyword">if</span> (!request.decoderResult().isSuccess())&#123;</span><br><span class="line">                sendError(ctx, BAD_REQUEST);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对请求方法判断，如果不是GET请求，则响应 405 错误</span></span><br><span class="line">            <span class="keyword">if</span> (request.method()!=HttpMethod.GET)&#123;</span><br><span class="line">                sendError(ctx,METHOD_NOT_ALLOWED);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对 url 进行分析判断</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.uri();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> sanitizeUri(uri);</span><br><span class="line">            <span class="keyword">if</span> (path == <span class="literal">null</span>)&#123;</span><br><span class="line">                sendError(ctx,FORBIDDEN);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">            <span class="comment">// 如果文件隐藏或者不存在，响应 404</span></span><br><span class="line">            <span class="keyword">if</span> (file.isHidden() || !file.exists())&#123;</span><br><span class="line">                sendError(ctx,NOT_FOUND);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory())&#123;</span><br><span class="line">                <span class="keyword">if</span> (uri.endsWith(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                    <span class="comment">// 如果文件是目录则发送文件目录连接给浏览器客户端</span></span><br><span class="line">                    sendList(ctx,file);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    sendRedirect(ctx,uri+<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!file.isFile())&#123;</span><br><span class="line">                sendError(ctx,FORBIDDEN);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过随机文件读写类RandomAccessFile类打开文件，并构造响应。</span></span><br><span class="line">            <span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                randomAccessFile = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (FileNotFoundException fnfd)&#123;</span><br><span class="line">                sendError(ctx,NOT_FOUND);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">fileLength</span> <span class="operator">=</span> randomAccessFile.length();</span><br><span class="line">            <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultHttpResponse</span>(HttpVersion.HTTP_1_1,OK);</span><br><span class="line">            <span class="comment">// 设置 content-length</span></span><br><span class="line">            HttpUtil.setContentLength(response,fileLength);</span><br><span class="line">            setContentTypeHeader(response,file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否为 keep-alive 如果是则在请求头设置 connection 为 keep-alive</span></span><br><span class="line">            <span class="keyword">if</span> (HttpUtil.isKeepAlive(request))&#123;</span><br><span class="line">                response.headers().set(HttpHeaderNames.CONNECTION,HttpHeaderValues.KEEP_ALIVE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发送响应消息</span></span><br><span class="line">            ctx.write(response);</span><br><span class="line">            ChannelFuture sendFuture;</span><br><span class="line">            <span class="comment">// 通过Netty的ChunkedFile对象直接将文件写入发送到缓冲区中</span></span><br><span class="line">            sendFuture = ctx.write(<span class="keyword">new</span> <span class="title class_">ChunkedFile</span>(randomAccessFile,<span class="number">0</span>,fileLength,<span class="number">8192</span>),ctx.newProgressivePromise());</span><br><span class="line">            sendFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelProgressiveFutureListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationProgressed</span><span class="params">(ChannelProgressiveFuture future, <span class="type">long</span> progress, <span class="type">long</span> total)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">if</span> (total&lt;<span class="number">0</span>)</span><br><span class="line">                        System.out.println(<span class="string">&quot;Transfer progress : &quot;</span>+progress);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;Transfer progress : &quot;</span>+progress+<span class="string">&quot;/&quot;</span>+total);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelProgressiveFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Transfer complete.&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 如果使用 chunked 编码，需要发送一个编码结束的空消息体，标识所有消息体已经发送完成</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">lastfuture</span> <span class="operator">=</span> ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);</span><br><span class="line">            <span class="keyword">if</span> (!HttpUtil.isKeepAlive(request))&#123;</span><br><span class="line">                lastfuture.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive())&#123;</span><br><span class="line">                sendError(ctx,INTERNAL_SERVER_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">INSECURE_URI</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;.*[&lt;&gt;&amp;\&quot;].*&quot;</span>);</span><br><span class="line">        <span class="comment">// 对 uri 进行解码并判断其合法性，</span></span><br><span class="line">        <span class="keyword">private</span> String <span class="title function_">sanitizeUri</span><span class="params">(String uri)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                uri = URLDecoder.decode(uri,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    uri = URLDecoder.decode(uri,<span class="string">&quot;ISO-8859-1&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!uri.startsWith(url))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!uri.startsWith(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 将硬编码的文件路径分隔符替换为本地操作系统的文件路径分隔符</span></span><br><span class="line">            uri = uri.replace(<span class="string">&#x27;/&#x27;</span>, File.separatorChar);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uri.contains(File.separator + <span class="string">&#x27;.&#x27;</span>) || uri.contains(<span class="string">&#x27;.&#x27;</span>+File.separator)</span><br><span class="line">                    || uri.startsWith(<span class="string">&quot;.&quot;</span>) || uri.endsWith(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                    || INSECURE_URI.matcher(uri).matches())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>)+File.separator + uri;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">ALLOWED_FILE_NAME</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;[A-Za-z0-9][-_A-Za-z0-9\\.]*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造文件目录 HTML 响应消息体发送给客户端</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendList</span><span class="params">(ChannelHandlerContext ctx, File file)</span> &#123;</span><br><span class="line">            <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1,OK);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">dirPath</span> <span class="operator">=</span> file.getPath();</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            builder.append(<span class="string">&quot;&lt;!DOCTYPE html&gt;\r\n&quot;</span>);</span><br><span class="line">            builder.append(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;\r\n&quot;</span>);</span><br><span class="line">            builder.append(dirPath);</span><br><span class="line">            builder.append(<span class="string">&quot;目录：&quot;</span>);</span><br><span class="line">            builder.append(<span class="string">&quot;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\r\n&quot;</span>);</span><br><span class="line">            builder.append(<span class="string">&quot;&lt;h3&gt;&quot;</span>);</span><br><span class="line">            builder.append(dirPath+<span class="string">&quot;目录：&quot;</span>);</span><br><span class="line">            builder.append(<span class="string">&quot;&lt;/h3&gt;\r\n&quot;</span>);</span><br><span class="line">            builder.append(<span class="string">&quot;&lt;ul&gt;&quot;</span>);</span><br><span class="line">            builder.append(<span class="string">&quot;&lt;li&gt;链接：&lt;a href=\&quot; ../\&quot;&gt;..&lt;/a&gt;&lt;/li&gt;\r\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (File f: file.listFiles())&#123;</span><br><span class="line">                <span class="keyword">if</span> (f.isHidden() || !f.canRead())&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> f.getName();</span><br><span class="line">                <span class="keyword">if</span> (!ALLOWED_FILE_NAME.matcher(name).matches())&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                builder.append(<span class="string">&quot;&lt;li&gt;链接：&lt;a href=\&quot;&quot;</span>);</span><br><span class="line">                builder.append(name);</span><br><span class="line">                builder.append(<span class="string">&quot;\&quot;&gt;&quot;</span>);</span><br><span class="line">                builder.append(name);</span><br><span class="line">                builder.append(<span class="string">&quot;&lt;/a&gt;&lt;/li&gt;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            builder.append(<span class="string">&quot;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> Unpooled.copiedBuffer(builder,CharsetUtil.UTF_8);</span><br><span class="line">            response.content().writeBytes(buffer);</span><br><span class="line">            buffer.release();</span><br><span class="line">            ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendRedirect</span><span class="params">(ChannelHandlerContext ctx, String newUri)</span> &#123;</span><br><span class="line">            <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1,FOUND);</span><br><span class="line">            response.headers().set(HttpHeaderNames.LOCATION,newUri);</span><br><span class="line">            ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendError</span><span class="params">(ChannelHandlerContext ctx, HttpResponseStatus status)</span> &#123;</span><br><span class="line">            <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1,status,</span><br><span class="line">                    Unpooled.copiedBuffer(<span class="string">&quot;Failure:&quot;</span>+status.toString()+<span class="string">&quot;\r\n&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">            ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setContentTypeHeader</span><span class="params">(HttpResponse response, File file)</span>&#123;</span><br><span class="line">            <span class="type">MimetypesFileTypeMap</span> <span class="variable">mimetypesFileTypeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimetypesFileTypeMap</span>();</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE,mimetypesFileTypeMap.getContentType(file.getPath()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/../assets/blogImg/Netty%5C10-1.png" alt="10-1"></p><p>重点：</p><ul><li>添加编码器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 负责把字节解码成Http请求</span></span><br><span class="line">socketChannel.pipeline().addLast(<span class="string">&quot;http-decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>());</span><br><span class="line"><span class="comment">// 负责把多个HttpMessage组装成一个完整的Http请求或者响应把响应编码成字节。到底是组装成请求还是响应，则取决于它所处理的内容是请求的内容，还是响应的内容。这其实可以通过Inbound和Outbound来判断，对于Server端而言，在Inbound 端接收请求，在Outbound端返回响应。</span></span><br><span class="line">socketChannel.pipeline().addLast(<span class="string">&quot;http-aggregator&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">65536</span>));</span><br><span class="line"><span class="comment">// 把响应编码成字节</span></span><br><span class="line">socketChannel.pipeline().addLast(<span class="string">&quot;http-encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpResponseEncoder</span>());</span><br><span class="line"><span class="comment">// 该通道处理器主要是为了处理大文件传输的情形。大文件传输时，需要复杂的状态管理，而ChunkedWriteHandler实现这个功能。</span></span><br><span class="line">socketChannel.pipeline().addLast(<span class="string">&quot;http-Chunked&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>());</span><br><span class="line"><span class="comment">// 自定义的通道处理器，其目的是实现文件服务器的业务逻辑。</span></span><br><span class="line">socketChannel.pipeline().addLast(<span class="string">&quot;fileserverHandler&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpFileServerHandler</span>(url));</span><br></pre></td></tr></table></figure><ul><li><p>自定义通道处理器继承<code>SimpleChannelInboundHandler&lt;FullHttpRequest&gt;</code> 实现 <code>channelRead0</code> 方法</p></li><li><p>通过 <code>ChunkedFile </code>将文件写入发送到缓冲区中</p></li></ul><h4 id="10-3、Netty-HTTP-XML-协议栈开发"><a href="#10-3、Netty-HTTP-XML-协议栈开发" class="headerlink" title="10.3、Netty HTTP+XML 协议栈开发"></a>10.3、Netty HTTP+XML 协议栈开发</h4><p>由于 HTTP 协议的通用性，很多异构系统间的通信交互采用 HTTP 协议，通过 HTTP 协议承载业务数据进行消息交互。</p><p><strong>模拟客户订购系统示例场景：</strong></p><p>客户填写订单，通过 HTTP 客户端向服务端发送订购请求，请求消息以XML承载放在 HTTP 消息体中。</p><p>HTTP服务端接收到客户端的订购请求后，对订单进行修改，然后通过 HTTP+XML 的方式返回响应内容。</p><p>双方采用 HTTP 协议版本 为 HTTP1.1，连接类型为CLOSE，即双方交互完成后，由服务端主动关闭链路。</p><h5 id="10-3-1、XML绑定框架-JiBx-入门"><a href="#10-3-1、XML绑定框架-JiBx-入门" class="headerlink" title="10.3.1、XML绑定框架 JiBx 入门"></a>10.3.1、XML绑定框架 JiBx 入门</h5><p>JiBx 是一款优秀的 XML 数据绑定框架，它提供了灵活的绑定映射文件，实现数据对象与XML 文件之间的转换，不需要修改现有的Java 类。</p><p>使用 JiBx 绑定 XML 文档与 Java 对象需要分两边走： </p><ol><li>生成绑定绑定 XML 文件（binding.xml) 和 数据映射文件（pojo.xml)，也就是映射 XML 文件与 Java 对象之间的对应关系；</li><li>实现 XML 文件与 Java 实例之间的相互转换，即根据 binding.xml 生成 Marshal 或者 Unmarshal 所需的 class 文件。</li></ol><p>首先maven 依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jibx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span> &gt;</span>jibx-run<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span> &gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jibx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jibx-extras<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后编写响应的 pojo 文件，Order、Address、Customer、Shipping 等，此次不展开细说。</p><p><strong>产生binding以及增强字节</strong></p><p>一、产生binding.xml 文件，通过cmd 或者在idea 的Terminal  切换到项目的 <code>target\classes</code> 目录下，使用 <code>jibx-tools.jar</code> 来生成。其中jibx-tools.jar包生成xml的时候，必须这个jar包所在文件夹中包含所有的jibx其他jar包 因为在生成binging.xml时候会用到其他jar包。（如果使用maven 的包会报错）</p><blockquote><p>java -cp bin;D:\jar\lib\jibx-tools.jar org.jibx.binding.generator.BindGen -b binding.xml com.study.netty.poj<br>o.Order</p></blockquote><p><img src="/../assets/blogImg/Netty/10-2.png" alt="10-2"></p><p>二、通过生成的binding.xml 增强字节码，生成 Marshal 或者 Unmarshal 所需的 class，如下图</p><p>此方式需要maven 依赖  jibx-tools 和 jibx-bind</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jibx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jibx-tools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jibx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jibx-bind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenBindFileTool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JiBXException, IOException &#123;</span><br><span class="line">        <span class="comment">// 根据 java 对象产生 binding 文件</span></span><br><span class="line">        <span class="comment">//genBindFiles();</span></span><br><span class="line">        <span class="comment">// 增强字节码</span></span><br><span class="line">        compile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增强字节码</span></span><br><span class="line"><span class="comment">     * 等效于 mvn jibx:bind（需要依赖maven 的 jibx 插件）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">compile</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] args = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印生成过程的详细信息。可选</span></span><br><span class="line">        args[<span class="number">0</span>] = <span class="string">&quot;-v&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定 binding 和 schema 文件的路径。必须</span></span><br><span class="line">        <span class="comment">//args[1] = &quot;./src/main/java/com/study/netty/jibxgen/binding.xml&quot;;</span></span><br><span class="line">        args[<span class="number">1</span>] = <span class="string">&quot;./target/classes/com/study/netty/jibx/binding.xml&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Compile.main(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 java 对象产生 binding 文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JiBXException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">genBindFiles</span><span class="params">()</span> <span class="keyword">throws</span> JiBXException, IOException &#123;</span><br><span class="line">        String[] args = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定pojo源码路径（指定父包也是可以的）。必须</span></span><br><span class="line">        args[<span class="number">0</span>] = <span class="string">&quot;-s&quot;</span>;</span><br><span class="line">        args[<span class="number">1</span>] = <span class="string">&quot;src&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义生成的binding文件名，默认文件名binding.xml。可选</span></span><br><span class="line">        args[<span class="number">2</span>] = <span class="string">&quot;-b&quot;</span>;</span><br><span class="line">        args[<span class="number">3</span>] = <span class="string">&quot;binding.xml&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印生成过程的一些信息。可选</span></span><br><span class="line">        args[<span class="number">4</span>] = <span class="string">&quot;-v&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果目录已经存在，就删除目录。可选</span></span><br><span class="line">        args[<span class="number">5</span>] = <span class="string">&quot;-w&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定输出路径。默认路径 .（当前目录,即根目录）。可选</span></span><br><span class="line">        args[<span class="number">6</span>] = <span class="string">&quot;-t&quot;</span>;</span><br><span class="line">        <span class="comment">//args[7] = &quot;./src/main/java/com/study/netty/jibxgen&quot;;</span></span><br><span class="line">        args[<span class="number">7</span>] = <span class="string">&quot;./target/classes/com/study/netty/jibx&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 告诉 BindGen 使用下面的类作为 root 生成 binding 和 schema。必须</span></span><br><span class="line">        args[<span class="number">8</span>] = <span class="string">&quot;com.study.netty.pojo.Order&quot;</span>;</span><br><span class="line"></span><br><span class="line">        BindGen.main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../assets/blogImg/Netty/10-3.png" alt="10-3"></p><p>最后编写测试程序TestXmlOrder，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestXmlOrder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">IBindingFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">CHARSET_NAME</span> <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">encode2Xml</span><span class="params">(Order order)</span> <span class="keyword">throws</span> JiBXException, IOException &#123;</span><br><span class="line">        <span class="comment">// 根据 Order的 class 实例构建 IBindingFactory 对象</span></span><br><span class="line">        factory = BindingDirectory.getFactory(Order.class);</span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">        <span class="comment">// 获取 Marshalling 上下文</span></span><br><span class="line">        <span class="type">IMarshallingContext</span> <span class="variable">mctx</span> <span class="operator">=</span> factory.createMarshallingContext();</span><br><span class="line">        mctx.setIndent(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 把 order 实例 序列化到 StringWriter中</span></span><br><span class="line">        mctx.marshalDocument(order, CHARSET_NAME, <span class="literal">null</span>, writer);</span><br><span class="line">        <span class="type">String</span> <span class="variable">xmlStr</span> <span class="operator">=</span> writer.toString();</span><br><span class="line">        writer.close();</span><br><span class="line">        System.out.println(xmlStr.toString());</span><br><span class="line">        <span class="keyword">return</span> xmlStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Order <span class="title function_">decode2Order</span><span class="params">(String xmlBody)</span> <span class="keyword">throws</span> JiBXException &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> <span class="title class_">StringReader</span>(xmlBody);</span><br><span class="line">        <span class="comment">// 获取 Unmarshallling 上下文</span></span><br><span class="line">        <span class="type">IUnmarshallingContext</span> <span class="variable">uctx</span> <span class="operator">=</span> factory.createUnmarshallingContext();</span><br><span class="line">        <span class="comment">// 把 XML 数据反序列化为 order 实例对象</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> (Order) uctx.unmarshalDocument(reader);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JiBXException, IOException &#123;</span><br><span class="line">        <span class="type">TestXmlOrder</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestXmlOrder</span>();</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> OrderFactory.createOrder(<span class="number">123</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> test.encode2Xml(order);</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order2</span> <span class="operator">=</span> test.decode2Order(body);</span><br><span class="line">        System.out.println(order2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/../assets/blogImg/Netty/10-4.png" alt="10-4"></p><h5 id="10-3-2、HTTP-XML-编解码框架开发"><a href="#10-3-2、HTTP-XML-编解码框架开发" class="headerlink" title="10.3.2、HTTP+XML 编解码框架开发"></a>10.3.2、HTTP+XML 编解码框架开发</h5><p>下面将会通过商品订购流程来实现 HTTP+XML 协议栈的开发，其中流程图如下：</p><p><img src="/../assets/blogImg/Netty/10-9.png" alt="10-9"></p><p>步骤大概有：</p><ol><li>在客户端构造订购消息，并将消息编码为 HTTP+XML 格式，通过 HTTP 协议栈发送HTTP请求消息</li><li>服务端接收 HTTP+XML请求消息进行解码，解码成请求POJO</li><li>服务端构造应答消息并编码，通过 HTTP+XML 方式返回个客户端</li><li>客户端对 HTTP + XML 响应消息进行解码，解码成响应的POJO</li></ol><p>由上可知，共应该需要 4 个编解码器，分别是客户端 请求时对消息的编码器和接受响应消息时的解码器；服务端接收请求消息的解码器和响应消息时的编码器。</p><p><strong>1、HTTP + XML 请求消息编解码码类</strong></p><p>因为请求消息编码和响应消息编码都需要用到编码器，需要抽象一个编码器供具体的类来实现。同样的解码器也需要封装抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XML 编码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractHttpXmlEncoder</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">MessageToMessageEncoder</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">IBindingFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">CHARSET_NAME</span> <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Charset</span> <span class="variable">UTF_8</span> <span class="operator">=</span> Charset.forName(CHARSET_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ByteBuf <span class="title function_">encode0</span><span class="params">(ChannelHandlerContext ctx, Object body)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 根据 请求体 class 实例构建 IBindingFactory 对象</span></span><br><span class="line">        factory = BindingDirectory.getFactory(body.getClass());</span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">        <span class="type">IMarshallingContext</span> <span class="variable">mctx</span> <span class="operator">=</span> factory.createMarshallingContext();</span><br><span class="line">        mctx.setIndent(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 通过 Marshalling 把数据对象转换为 XML 格式数据</span></span><br><span class="line">        mctx.marshalDocument(body, CHARSET_NAME, <span class="literal">null</span>, writer);</span><br><span class="line">        <span class="type">String</span> <span class="variable">xmlStr</span> <span class="operator">=</span> writer.toString();</span><br><span class="line">        writer.close();</span><br><span class="line">        writer = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.copiedBuffer(xmlStr,UTF_8);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">        <span class="keyword">if</span> (writer!=<span class="literal">null</span>)&#123;</span><br><span class="line">            writer.close();</span><br><span class="line">            writer=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XML 解码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractHttpXmlDecoder</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">MessageToMessageDecoder</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;AbstractHttpXmlDecoder&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">IBindingFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; aClass;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isPrint;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">CHARSET_NAME</span> <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Charset</span> <span class="variable">UTF_8</span> <span class="operator">=</span> Charset.forName(CHARSET_NAME);</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractHttpXmlDecoder</span><span class="params">(Class&lt;?&gt; aClass)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.aClass = aClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractHttpXmlDecoder</span><span class="params">(Class&lt;?&gt; aClass, <span class="type">boolean</span> isPrint)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.aClass = aClass;</span><br><span class="line">        <span class="built_in">this</span>.isPrint = isPrint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">decode0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 根据 需要的响应体 class 实例构建 IBindingFactory 对象</span></span><br><span class="line">        factory = BindingDirectory.getFactory(aClass);</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> msg.toString(UTF_8);</span><br><span class="line">        <span class="keyword">if</span> (isPrint)</span><br><span class="line">            System.out.println(<span class="string">&quot;decoder &quot;</span>+TAG+<span class="string">&quot; receive contant is :\r\n&quot;</span>+content);</span><br><span class="line">        reader = <span class="keyword">new</span> <span class="title class_">StringReader</span>(content);</span><br><span class="line">        <span class="comment">// 通过 Unmarshalling 把XML 数据转换为响应数据对象实体</span></span><br><span class="line">        <span class="type">IUnmarshallingContext</span> <span class="variable">uctx</span> <span class="operator">=</span> factory.createUnmarshallingContext();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> uctx.unmarshalDocument(reader);</span><br><span class="line">        reader.close();</span><br><span class="line">        reader = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (reader!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            reader.close();</span><br><span class="line">            reader = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>2、服务端 HTTP+XML 编解码器开发</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求消息编码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpXmlRequestEncoder</span> <span class="keyword">extends</span> <span class="title class_">AbstractHttpXmlEncoder</span>&lt;HttpXmlRequest&gt;  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, HttpXmlRequest msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">body</span> <span class="operator">=</span> encode0(ctx,msg.getBody());</span><br><span class="line">        <span class="type">FullHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> msg.getRequest();</span><br><span class="line">        <span class="keyword">if</span> (request==<span class="literal">null</span>)&#123;</span><br><span class="line">            request = <span class="keyword">new</span> <span class="title class_">DefaultFullHttpRequest</span>(HttpVersion.HTTP_1_1, HttpMethod.GET,<span class="string">&quot;/do&quot;</span>,body);</span><br><span class="line">            <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> request.headers();</span><br><span class="line">            headers.set(HttpHeaderNames.HOST, InetAddress.getLocalHost().getHostAddress());</span><br><span class="line">            headers.set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);</span><br><span class="line">            headers.set(HttpHeaderNames.ACCEPT_ENCODING,HttpHeaderValues.GZIP.toString()+<span class="string">&#x27;,&#x27;</span>+HttpHeaderValues.DEFLATE.toString());</span><br><span class="line">            headers.set(HttpHeaderNames.ACCEPT_CHARSET,<span class="string">&quot;ISO-8859-1,utf-8;q=0.7,*;q=0.7&quot;</span>);</span><br><span class="line">            headers.set(HttpHeaderNames.ACCEPT_LANGUAGE,<span class="string">&quot;zh&quot;</span>);</span><br><span class="line">            headers.set(HttpHeaderNames.USER_AGENT,<span class="string">&quot;Netty xml http client side&quot;</span>);</span><br><span class="line">            headers.set(HttpHeaderNames.ACCEPT,<span class="string">&quot;text/html,application/xhtml+xml,application/xml,q=0.9,*/*;q=0.8&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        HttpUtil.setContentLength(request,body.readableBytes());</span><br><span class="line">        out.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端响应消息编码器，吧响应消息数据对象编码为XML</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpXmlResponseEncoder</span> <span class="keyword">extends</span> <span class="title class_">AbstractHttpXmlEncoder</span>&lt;HttpXmlResponse&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, HttpXmlResponse msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> encode0(ctx,msg.getBody());</span><br><span class="line">        <span class="type">FullHttpResponse</span> <span class="variable">fullHttpResponse</span> <span class="operator">=</span> msg.getHttpResponse();</span><br><span class="line">        <span class="keyword">if</span> (fullHttpResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">            fullHttpResponse = <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, HttpResponseStatus.OK,buf);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            fullHttpResponse  = <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(fullHttpResponse.protocolVersion(),fullHttpResponse.status(),</span><br><span class="line">                    fullHttpResponse.content());</span><br><span class="line">        &#125;</span><br><span class="line">        fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/xml&quot;</span>);</span><br><span class="line">        HttpUtil.setContentLength(fullHttpResponse,buf.readableBytes());</span><br><span class="line">        out.add(fullHttpResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpXmlServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HttpXmlServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpXmlServer</span>();</span><br><span class="line">        server.start(<span class="number">8081</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-aggregator&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">65535</span>));</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-response-xml-decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpXmlRequestDecoder</span>(Order.class,<span class="literal">true</span>));</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpResponseEncoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-response-xml-encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpXmlResponseEncoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;XML-server-handler&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpXmlServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> serverBootstrap.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port)).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpXmlServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;HttpXmlRequest&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, HttpXmlRequest msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> msg.getRequest();</span><br><span class="line">            <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> (Order) msg.getBody();</span><br><span class="line">            System.out.println(<span class="string">&quot;http XML Server receive order is :\r\n&quot;</span>+order.toString());</span><br><span class="line">            dobussiness(order);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">HttpXmlResponse</span>(<span class="literal">null</span>,order));</span><br><span class="line">            <span class="keyword">if</span> (!HttpUtil.isKeepAlive(request))&#123;</span><br><span class="line">                f.addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="built_in">super</span> Void&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;? <span class="built_in">super</span> Void&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ctx.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive())&#123;</span><br><span class="line">                sendError(ctx,HttpResponseStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dobussiness</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">            order.setTotal(<span class="number">10f</span>);</span><br><span class="line">            order.setCustomer(OrderFactory.createCustomer(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendError</span><span class="params">(ChannelHandlerContext ctx, HttpResponseStatus status)</span> &#123;</span><br><span class="line">            <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1,status,</span><br><span class="line">                    Unpooled.copiedBuffer(<span class="string">&quot;Failure:&quot;</span>+status.toString()+<span class="string">&quot;\r\n&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">            ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在服务端的代码中，实现HTTP+XML 自动编解码，其核心主要是请求消息的解码器和响应消息编码器的实现，并且把边编解码器添加到 pipeline 中。</p><p><strong>3、客户端 HTTP+XML 编解码器开发</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端接收请求解码器，把XML 消息通过Jibx 解码为指定的消息体实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpXmlRequestDecoder</span> <span class="keyword">extends</span> <span class="title class_">AbstractHttpXmlDecoder</span>&lt;FullHttpRequest&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">HttpXmlRequestDecoder</span><span class="params">(Class&lt;?&gt; aClass)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(aClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HttpXmlRequestDecoder</span><span class="params">(Class&lt;?&gt; aClass, <span class="type">boolean</span> isPrint)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(aClass, isPrint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (!msg.decoderResult().isSuccess())&#123;</span><br><span class="line">            sendError(ctx,HttpResponseStatus.BAD_REQUEST);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HttpXmlRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpXmlRequest</span>(msg,decode0(ctx,msg.content()));</span><br><span class="line">        out.add(request);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendError</span><span class="params">(ChannelHandlerContext ctx, HttpResponseStatus status)</span> &#123;</span><br><span class="line">        <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1,status,</span><br><span class="line">                Unpooled.copiedBuffer(<span class="string">&quot;Failure:&quot;</span>+status.toString()+<span class="string">&quot;\r\n&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应消息解码器，接收到服务端消息时自动解码，解码为指定的Class 实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpXmlResponseDecoder</span> <span class="keyword">extends</span> <span class="title class_">AbstractHttpXmlDecoder</span>&lt;FullHttpResponse&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HttpXmlResponseDecoder</span><span class="params">(Class&lt;?&gt; aClass)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(aClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HttpXmlResponseDecoder</span><span class="params">(Class&lt;?&gt; aClass, <span class="type">boolean</span> isPrint)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(aClass, isPrint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, FullHttpResponse msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpXmlResponse</span> <span class="variable">httpXmlResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpXmlResponse</span>(msg,decode0(ctx,msg.content()));</span><br><span class="line">        out.add(httpXmlResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpXmlClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HttpXmlClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpXmlClient</span>();</span><br><span class="line">        client.connect(<span class="number">8081</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">loopGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(loopGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY,<span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpResponseDecoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-aggregator&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">65535</span>));</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-response-xml-decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpXmlResponseDecoder</span>(Order.class,<span class="literal">true</span>));</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpRequestEncoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-request-xml-encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpXmlRequestEncoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-xml-handler&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpXmlClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> bootstrap.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port)).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            loopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HttpXmlClientHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;HttpXmlResponse&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">HttpXmlRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpXmlRequest</span>(<span class="literal">null</span>, OrderFactory.createOrder(<span class="number">123</span>));</span><br><span class="line">            ctx.writeAndFlush(request);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpXmlResponse msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;http xml client receive msg header is : &quot;</span>+msg.getHttpResponse().headers().names());</span><br><span class="line">            System.out.println(<span class="string">&quot;http xml client receive msg is : &quot;</span>+msg.getBody());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive())&#123;</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与服务端代码类似，需要实现编解码器并且添加到 pipeline 中，最终的运行效果如下：</p><p><img src="/../assets/blogImg/Netty/10-5.png" alt="10-5"></p><p><img src="/../assets/blogImg/Netty/10-6.png" alt="10-6"></p><h4 id="10-4、Netty-HTTP-JSON-协议开发"><a href="#10-4、Netty-HTTP-JSON-协议开发" class="headerlink" title="10.4、Netty HTTP+JSON 协议开发"></a>10.4、Netty HTTP+JSON 协议开发</h4><p> 在接下来的例程中，使用了 fastjson 框架来实现 json 的序列化以及反序列化</p><p>与 HTTP+XML 类似的，客户端和服务端同样需要实现自定义的编解码器，在编解码器中需要用fastjson 来实现序列化和反序列化，其中代码实现如下：</p><h5 id="10-4-1、HTTP-JSON-协议栈服务端以及编码器的实现"><a href="#10-4-1、HTTP-JSON-协议栈服务端以及编码器的实现" class="headerlink" title="10.4.1、HTTP+JSON 协议栈服务端以及编码器的实现"></a>10.4.1、HTTP+JSON 协议栈服务端以及编码器的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端请求消息解码器实现，把json 数据反序列化。</span></span><br><span class="line"><span class="comment"> * 为了方便实现，没有将数据反序列化为具体数据，仍按String 来传递，将数据交给下一级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpJsonRequestDecoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageDecoder</span>&lt;FullHttpRequest&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">CHARSET_NAME</span> <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Charset</span> <span class="variable">UTF_8</span> <span class="operator">=</span> Charset.forName(CHARSET_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (!msg.decoderResult().isSuccess())&#123;</span><br><span class="line">            sendError(ctx, HttpResponseStatus.BAD_REQUEST);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> msg.content().toString(UTF_8);</span><br><span class="line">        <span class="keyword">if</span> (!JSON.isValidObject(content))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请求内容非JSON数据格式&quot;</span>);</span><br><span class="line">            sendError(ctx,HttpResponseStatus.BAD_REQUEST);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HttpTextRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpTextRequest</span>(msg,content);</span><br><span class="line">        out.add(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendError</span><span class="params">(ChannelHandlerContext ctx, HttpResponseStatus status)</span> &#123;</span><br><span class="line">        <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1,status,</span><br><span class="line">                Unpooled.copiedBuffer(<span class="string">&quot;Failure:&quot;</span>+status.toString()+<span class="string">&quot;\r\n&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端编码器实现，把具体响应数据对象序列化为 json 数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpJsonResponseEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageEncoder</span>&lt;HttpTextResponse&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">CHARSET_NAME</span> <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Charset</span> <span class="variable">UTF_8</span> <span class="operator">=</span> Charset.forName(CHARSET_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, HttpTextResponse msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> msg.getFullHttpResponse();</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.copiedBuffer(JSON.toJSONString(msg.getBody()),UTF_8);</span><br><span class="line">        <span class="keyword">if</span> (response==<span class="literal">null</span>)&#123;</span><br><span class="line">            response = <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1,HttpResponseStatus.OK,buf);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            response  = <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(response.protocolVersion(),response.status(),</span><br><span class="line">                    response.content());</span><br><span class="line">        &#125;</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/json&quot;</span>);</span><br><span class="line">        HttpUtil.setContentLength(response,buf.readableBytes());</span><br><span class="line">        out.add(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// json 消息服务端实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpJsonServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HttpJsonServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpJsonServer</span>();</span><br><span class="line">        server.start(<span class="number">8081</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-aggregator&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">65535</span>));</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-response-json-decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpJsonRequestDecoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpResponseEncoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-response-json-encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpJsonResponseEncoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;json-server-handler&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpJsonServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> serverBootstrap.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port)).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 经过上层各种处理器出后，处理最终的数据，负责网络 IO 事件的具体处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpJsonServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;HttpTextRequest&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, HttpTextRequest msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> msg.getRequest();</span><br><span class="line">            <span class="type">String</span> <span class="variable">orderStr</span> <span class="operator">=</span> (String) msg.getBody();</span><br><span class="line">            System.out.println(<span class="string">&quot;http json Server receive order is :\r\n&quot;</span>+ orderStr);</span><br><span class="line">            <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> JSON.parseObject(orderStr,Order.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;deserializable order is :\r\n&quot;</span>+ order.toString());</span><br><span class="line">            dobussiness(order);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">HttpTextResponse</span>(<span class="literal">null</span>,order));</span><br><span class="line">            <span class="keyword">if</span> (!HttpUtil.isKeepAlive(request))&#123;</span><br><span class="line">                f.addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="built_in">super</span> Void&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;? <span class="built_in">super</span> Void&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ctx.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dobussiness</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">            order.setTotal(<span class="number">112f</span>);</span><br><span class="line">            order.setCustomer(OrderFactory.createCustomer(<span class="number">11</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive())&#123;</span><br><span class="line">                sendError(ctx, HttpResponseStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendError</span><span class="params">(ChannelHandlerContext ctx, HttpResponseStatus status)</span> &#123;</span><br><span class="line">            <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1,status,</span><br><span class="line">                    Unpooled.copiedBuffer(<span class="string">&quot;Failure:&quot;</span>+status.toString()+<span class="string">&quot;\r\n&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">            ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="10-4-2、HTTP-JSON协议栈客户端和编解码器开发"><a href="#10-4-2、HTTP-JSON协议栈客户端和编解码器开发" class="headerlink" title="10.4.2、HTTP+JSON协议栈客户端和编解码器开发"></a>10.4.2、HTTP+JSON协议栈客户端和编解码器开发</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求消息编码器，把请求数据对象序列化为json 数据，以及添加自定义请求头数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpJsonRequestEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageEncoder</span>&lt;HttpTextRequest&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">CHARSET_NAME</span> <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Charset</span> <span class="variable">UTF_8</span> <span class="operator">=</span> Charset.forName(CHARSET_NAME);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, HttpTextRequest msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">FullHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> msg.getRequest();</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">body</span> <span class="operator">=</span> Unpooled.copiedBuffer(JSON.toJSONString(msg.getBody()),UTF_8);</span><br><span class="line">        <span class="keyword">if</span> (request==<span class="literal">null</span>)&#123;</span><br><span class="line">            request = <span class="keyword">new</span> <span class="title class_">DefaultFullHttpRequest</span>(HttpVersion.HTTP_1_1, HttpMethod.POST,<span class="string">&quot;/do&quot;</span>,body);</span><br><span class="line">            <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> request.headers();</span><br><span class="line">            headers.set(HttpHeaderNames.HOST, InetAddress.getLocalHost().getHostAddress());</span><br><span class="line">            headers.set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);</span><br><span class="line">            headers.set(HttpHeaderNames.ACCEPT_ENCODING,HttpHeaderValues.GZIP.toString()+<span class="string">&#x27;,&#x27;</span>+HttpHeaderValues.DEFLATE.toString());</span><br><span class="line">            headers.set(HttpHeaderNames.ACCEPT_CHARSET,<span class="string">&quot;ISO-8859-1,utf-8;q=0.7,*;q=0.7&quot;</span>);</span><br><span class="line">            headers.set(HttpHeaderNames.ACCEPT_LANGUAGE,<span class="string">&quot;zh&quot;</span>);</span><br><span class="line">            headers.set(HttpHeaderNames.USER_AGENT,<span class="string">&quot;Netty json http client side&quot;</span>);</span><br><span class="line">            headers.set(HttpHeaderNames.ACCEPT,<span class="string">&quot;text/html,application/json,q=0.9,*/*;q=0.8&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        HttpUtil.setContentLength(request,body.readableBytes());</span><br><span class="line">        out.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端响应消息解码器，用于处理服务端响应的消息数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpJsonResponseDecoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageDecoder</span>&lt;FullHttpResponse&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">CHARSET_NAME</span> <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Charset</span> <span class="variable">UTF_8</span> <span class="operator">=</span> Charset.forName(CHARSET_NAME);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, FullHttpResponse msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpTextResponse</span> <span class="variable">httpTextResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpTextResponse</span>(msg,msg.content().toString(UTF_8));</span><br><span class="line">        out.add(httpTextResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpJsonClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HttpJsonClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpJsonClient</span>();</span><br><span class="line">        client.connect(<span class="number">8081</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">loopGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(loopGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY,<span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpResponseDecoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-aggregator&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">65535</span>));</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-response-json-decoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpJsonResponseDecoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpRequestEncoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-request-json-encoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpJsonRequestEncoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-json-handler&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpJsonClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> bootstrap.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port)).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            loopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpJsonClientHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;HttpTextResponse&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpTextResponse msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;http json client receive msg header is : &quot;</span>+msg.getFullHttpResponse().headers().names());</span><br><span class="line">            System.out.println(<span class="string">&quot;http json client receive msg is :\r\n &quot;</span>+msg.getBody());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> OrderFactory.createOrder(<span class="number">10</span>);</span><br><span class="line">            <span class="type">HttpTextRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpTextRequest</span>(<span class="literal">null</span>, order);</span><br><span class="line">            ctx.writeAndFlush(request);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive())&#123;</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="10-4-3、运行效果"><a href="#10-4-3、运行效果" class="headerlink" title="10.4.3、运行效果"></a>10.4.3、运行效果</h5><p><img src="/../assets/blogImg/Netty/10-7.png" alt="10-7"></p><p><img src="/../assets/blogImg/Netty/10-8.png" alt="10-8"></p><h3 id="十一、WebSocket-协议开发应用"><a href="#十一、WebSocket-协议开发应用" class="headerlink" title="十一、WebSocket 协议开发应用"></a>十一、WebSocket 协议开发应用</h3><h4 id="11-1、HTTP-协议的弊端"><a href="#11-1、HTTP-协议的弊端" class="headerlink" title="11.1、HTTP 协议的弊端"></a>11.1、HTTP 协议的弊端</h4><p>HTTP 协议的弊端主要如下：</p><ol><li>HTTP协议为半双工协议。半双工协议是指数据可以在客户端和服务端两个方向上传输，但是不能同时传输。意味着在同一时刻，只有一个方向的数据在传输。</li><li>HTTP消息冗长而繁琐。HTTP 消息包含消息头、消息体和换行符等，通常情况下采用文本传输，相比其他二进制通信协议，冗长而繁琐。</li><li>针对服务器推送的黑客攻击，比如长轮询。</li></ol><h4 id="11-2、WebSocket-入门"><a href="#11-2、WebSocket-入门" class="headerlink" title="11.2、WebSocket 入门"></a>11.2、WebSocket 入门</h4><p>WebSocket 是 HTML5 开始提供的一种浏览器和服务器间进行全双工通信的网络技术，WebSocket 设计出来的目的就是要取代轮询和 Comet 技术，使得客户端浏览器具备像C&#x2F;S 架构下桌面系统一样的实时通信能力。其于2011年被 IEFE 定为标准 RFC6455，WebSocket API 被 W3C  定位标准。在WebSocket API 中，浏览器和服务端只需做一个握手动作，然后就可以快速建立通信通道，接着互相传递数据。</p><p>特点：</p><ul><li>单一的TCP 链接，采用全双工模式通信</li><li>对代理、防火墙和路由透明</li><li>无头部信息、Cookie 和身份验证</li><li>无安全开销</li><li>通过<code>Ping/Pong</code> 帧保持链路激活</li><li>服务器可以主动传递消息给客户端，无需轮询。</li></ul><h5 id="11-2-1、WebSocket-链接建立"><a href="#11-2-1、WebSocket-链接建立" class="headerlink" title="11.2.1、WebSocket 链接建立"></a>11.2.1、WebSocket 链接建立</h5><p>建立 WebSocket 链接时，需要客户端浏览器向服务器发起握手请求，其中该请求为一个HTTP 请求。该请求与一般的HTTP 请求不同，包含了一些附加头部信息。其中附件头<code>Upgrade:websocket</code> 表明这是一个申请协议升级的HTTP 请求。同时请求头消息中还包含了<code>Sec-WebSocket-Key</code> ，这是随机字符串信息，服务端会根据这些信息构造一个 SHA-1 的信息摘要，把 <code>Sec-WebSocket-Key</code> 加上一个魔幻字符串，使用 SHA-1 加密，然后进行 BASE-64 编码，将结果作为<code>Sec-WebSocket-Accept</code> 头的值，返回给客户端。</p><p>请求头响应头如下图</p><p><img src="/../assets/blogImg/Netty/11-1.png" alt="11-1"></p><p><img src="/../assets/blogImg/Netty/11-2.png" alt="11-2"></p><h5 id="11-2-2、WebSocket-生命周期"><a href="#11-2-2、WebSocket-生命周期" class="headerlink" title="11.2.2、WebSocket 生命周期"></a>11.2.2、WebSocket 生命周期</h5><p>握手成功后，服务端和客户端就可以通过<code>message</code> 的方式进行通信，一个消息可以由一个或多个帧组成，WebSocket 并不一定特定对应一个网络层的帧，他可以被分割成多个帧或被合并。</p><p>帧都有自己对应的消息类型，属于同一个消息的多个帧具有相同类型的数据。</p><p><img src="/../assets/blogImg/Netty/11-3.png" alt="11-3"></p><h5 id="11-2-3、WebSocket-链接关闭"><a href="#11-2-3、WebSocket-链接关闭" class="headerlink" title="11.2.3、WebSocket 链接关闭"></a>11.2.3、WebSocket 链接关闭</h5><p>为关闭 WebSocket 连接，客户端和服务端需要一个安全的方法关闭底层TCP 连接和 TLS回话。如果合适，丢弃任何可能已经接收的字节，必要时（受到攻击）可以通过任何手段关闭连接。</p><p>底层 TCP 连接，在正常情况下，应首先由服务器关闭。异常情况下，可由客户端发起 TCP Close，因此，当服务器被指示关闭 WebSocket 连接时，它应立即发起一个TCP Close 操作，客户端应该等待服务器的 TCP Close 。</p><h4 id="11-3、Netty-WebSocket-协议开发"><a href="#11-3、Netty-WebSocket-协议开发" class="headerlink" title="11.3、Netty WebSocket 协议开发"></a>11.3、Netty WebSocket 协议开发</h4><p>Netty 基于 HTTP 协议栈开发了 WebSocket 协议栈，利用 Netty 的 WebSocket 的协议栈可以非常方便的开发出 WebSocket 的服务端和客户端。</p><p>下面将通过一个小例程来实现 Netty WebSocket 的客户端和服务端的开发，其主要功能为：客户端发送消息到服务端，服务端对请求消息进行判断，如果是合法的 WebSocket 消息，则响应返回 Netty WebSocket 服务端消息以及时间。</p><h5 id="11-3-1、WebSocket-服务端开发"><a href="#11-3-1、WebSocket-服务端开发" class="headerlink" title="11.3.1、WebSocket 服务端开发"></a>11.3.1、WebSocket 服务端开发</h5><p>利用Netty 开发WebSocket 服务端的关键是网络 I&#x2F;O 事件处理器handler，其中在 handler 处理的事件有:</p><ul><li>判断区分 HTTP请求和 WebSocke 请求，因为第一次请求握手消息是由HTTP 协议承载；</li><li>如果是 HTTP 握手请求，则根据通过握手工厂类<code>WebSocketServerHandshakerFactory</code> 创建握手处理类<code>WebSocketServerHandshaker</code> 实例；其中握手处理了中的<code>handshake</code> 方法会将 websocket的编辑码类动态的添加到 ChannelPipeline</li><li>链路建立成功后，客户端提交文本到服务端，服务端分别判断，是否是关闭连接、是否为 ping 指令消息，是否是支持的文本消息，然后做出响应，返回给客户端。</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">WebSocketServer</span> <span class="variable">webSocketServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocketServer</span>();</span><br><span class="line">        webSocketServer.bind(<span class="number">8082</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-codec&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-aggregator&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">65535</span>));</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;http-chuncked&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;websocket-handler&quot;</span>,<span class="keyword">new</span> <span class="title class_">WebSocketHandler</span>(port));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> serverBootstrap.bind(port).sync().channel();</span><br><span class="line">            System.out.println(<span class="string">&quot;websocket sart at prot:&quot;</span>+port);</span><br><span class="line">            System.out.println(<span class="string">&quot;please open your web browser and navigate to : http://localhost:&quot;</span>+port+<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;Object&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">        <span class="comment">// 处理 websocket 握手请求</span></span><br><span class="line">        <span class="keyword">private</span> WebSocketServerHandshaker handshaker;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WebSocketHandler</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.port = port;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;server receive msg:&quot;</span>+msg);</span><br><span class="line">            <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FullHttpRequest)&#123;</span><br><span class="line">                <span class="comment">// 传统 Http 请求接入</span></span><br><span class="line">                handlerHttpRequest(ctx,(FullHttpRequest)msg);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> WebSocketFrame)&#123;</span><br><span class="line">                <span class="comment">// websocket 接入</span></span><br><span class="line">                handlerWebSocketFrame(ctx,(WebSocketFrame)msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlerHttpRequest</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest msg)</span> &#123;</span><br><span class="line">            <span class="comment">// Http 解码失败或者不是请求建立 websocket 连接的http 请求，返回请求失败</span></span><br><span class="line">            <span class="keyword">if</span> (!msg.decoderResult().isSuccess() || !<span class="string">&quot;websocket&quot;</span>.equals(msg.headers().get(<span class="string">&quot;Upgrade&quot;</span>)))&#123;</span><br><span class="line">                sendHttpResponse(ctx,msg,<span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1,HttpResponseStatus.BAD_REQUEST));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 构造握手请求响应</span></span><br><span class="line">            <span class="type">WebSocketServerHandshakerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocketServerHandshakerFactory</span>(<span class="string">&quot;ws://localhost:&quot;</span>+port+<span class="string">&quot;/websocket&quot;</span>,</span><br><span class="line">                    <span class="literal">null</span>,<span class="literal">false</span>);</span><br><span class="line">            handshaker = factory.newHandshaker(msg);</span><br><span class="line">            <span class="keyword">if</span> (handshaker==<span class="literal">null</span>)&#123;</span><br><span class="line">                WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                handshaker.handshake(ctx.channel(),msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 websocket 帧</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlerWebSocketFrame</span><span class="params">(ChannelHandlerContext ctx, WebSocketFrame msg)</span> &#123;</span><br><span class="line">            <span class="comment">// 判断是否为关闭 websocket 链路指令</span></span><br><span class="line">            <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> CloseWebSocketFrame)&#123;</span><br><span class="line">                handshaker.close(ctx.channel(),((CloseWebSocketFrame) msg).retain());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否为 ping 指令消息</span></span><br><span class="line">            <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> PingWebSocketFrame)&#123;</span><br><span class="line">                ctx.channel().write(<span class="keyword">new</span> <span class="title class_">PongWebSocketFrame</span>(msg.content().retain()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 本例程仅支持文本消息，不支持二进制消息</span></span><br><span class="line">            <span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> TextWebSocketFrame))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(String.format(<span class="string">&quot;%s frame types ne supported.&quot;</span>,msg.getClass().getName()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回应答消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> ((TextWebSocketFrame) msg).text();</span><br><span class="line">            System.out.println(ctx.channel()+<span class="string">&quot; recived client message: \r\n&quot;</span>+text);</span><br><span class="line">            ctx.channel().writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(text+<span class="string">&quot;,欢迎使用 Netty WebSocket 服务，现在时间：&quot;</span></span><br><span class="line">                    + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>))));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendHttpResponse</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest req, FullHttpResponse resp)</span>&#123;</span><br><span class="line">            <span class="comment">// 返回应答给客户端</span></span><br><span class="line">            <span class="keyword">if</span> (resp.status().code()==<span class="number">200</span>)&#123;</span><br><span class="line">                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.copiedBuffer(resp.status().code()+<span class="string">&quot;&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">                resp.content().writeBytes(buf);</span><br><span class="line">                buf.release();</span><br><span class="line">                HttpUtil.setContentLength(resp,resp.content().readableBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> ctx.writeAndFlush(resp);</span><br><span class="line">            <span class="comment">// 如果非 keep-alive, 关闭连接</span></span><br><span class="line">            <span class="keyword">if</span> (!HttpUtil.isKeepAlive(req) || resp.status().code()!=<span class="number">200</span>)&#123;</span><br><span class="line">                f.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive())&#123;</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下</p><p><img src="/../assets/blogImg/Netty/11-4.png" alt="11-4"></p><p><img src="/../assets/blogImg/Netty/11-5.png" alt="11-5"></p><h4 id="11-4、Netty-UDP-协议开发"><a href="#11-4、Netty-UDP-协议开发" class="headerlink" title="11.4、Netty UDP 协议开发"></a>11.4、Netty UDP 协议开发</h4><p>用户数据报协议（User Datagram Protocol，UDP）是一种传输层协议。在 TCP&#x2F;IP 网络中，它与 TCP 协议一样用于处理数据包，是一种无连接的协议。</p><p>TCP 协议在进行数据传输时，需要建立连接，并且每次传输的数据都需要进行确认。当不再进行传输数据时，还需要断开连接。这样做虽然安全，但是效率较低。而 UDP 协议正好避免了这些过程，它是一种没有复杂控制，提供面向无连接的通信服务协议。</p><p>UDP 协议具备以下特点：</p><ul><li>没有各种连接：在传输数据前不需要建立连接，也避免了后续的断开连接。</li><li>不重新排序：对到达顺序混乱的数据包不进行重新排序。</li><li>没有确认：发送数据包无须等待对方确认。因此，使用 UDP 协议可以随时发送数据，但无法保证数据能否成功被目标主机接收。</li></ul><h5 id="11-4-1、UDP-服务端开发"><a href="#11-4-1、UDP-服务端开发" class="headerlink" title="11.4.1、UDP 服务端开发"></a>11.4.1、UDP 服务端开发</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyUdpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">NettyUdpServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyUdpServer</span>();</span><br><span class="line">        server.bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup)</span><br><span class="line">                    <span class="comment">// 指定通道类型为 NioDatagramChannel</span></span><br><span class="line">                    .channel(NioDatagramChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BROADCAST,<span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">//UDP相对于TCP不需要在客户端和服务端建立实际的连接，因此不需要为连接（ChannelPipeline）设置handler</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">NettyUdpServerHandler</span>());</span><br><span class="line">            serverBootstrap.bind(port).sync().channel().closeFuture().await();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyUdpServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;DatagramPacket&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, DatagramPacket msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> msg.content().toString(CharsetUtil.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">&quot;收到客户端消息为：&quot;</span>+content);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;udp-req&quot;</span>.equals(content))&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">respStr</span> <span class="operator">=</span> <span class="string">&quot;欢迎使用UDP服务，盲盒开奖成功！&quot;</span>;</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">respPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(Unpooled.copiedBuffer(respStr,CharsetUtil.UTF_8),msg.sender());</span><br><span class="line">                ctx.writeAndFlush(respPacket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            ctx.close();</span><br><span class="line">            cause.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="11-4-2、UDP-客户端开发"><a href="#11-4-2、UDP-客户端开发" class="headerlink" title="11.4.2、UDP 客户端开发"></a>11.4.2、UDP 客户端开发</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyUdpClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">NettyUdpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyUdpClient</span>();</span><br><span class="line">        client.connect(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">loopGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(loopGroup)</span><br><span class="line">                    .option(ChannelOption.SO_BROADCAST,<span class="literal">true</span>)</span><br><span class="line">                    .channel(NioDatagramChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ClientUdpHandler</span>());</span><br><span class="line"></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8081</span>).sync().channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向网段内的所有机器广播</span></span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(Unpooled.copiedBuffer(<span class="string">&quot;udp-req&quot;</span>,CharsetUtil.UTF_8),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;255.255.255.255&quot;</span>,port)));</span><br><span class="line">            <span class="comment">//客户端等待15s用于接收服务端的应答消息，然后退出并释放资源</span></span><br><span class="line">            <span class="keyword">if</span>(!channel.closeFuture().await(<span class="number">15000</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请求超时！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            loopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ClientUdpHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;DatagramPacket&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, DatagramPacket msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> msg.content().toString(CharsetUtil.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">&quot;client receive msg is : &quot;</span>+content);</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            ctx.close();</span><br><span class="line">            cause.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十二、私有协议栈开发"><a href="#十二、私有协议栈开发" class="headerlink" title="十二、私有协议栈开发"></a>十二、私有协议栈开发</h3><p>广义上区分，通信协议可以分为共有协议和私有协议。由于私有协议的灵活性，和时候在公司或者组织内部使用，按需定制，升级方便，灵活性好。绝大多数私有协议传输层基于TCP&#x2F;IP，利用 Netty 的 NIO TCP 协议栈可以非常方便地进行私有协议的定制和开发。</p><h4 id="12-1、私有协议介绍"><a href="#12-1、私有协议介绍" class="headerlink" title="12.1、私有协议介绍"></a>12.1、私有协议介绍</h4><p>私有协议本质上是厂商内部发展和才有的标准，除非授权，其他厂商一般无权限使用该协议。私有协议具有封闭性、垄断性、排他性等特点。其设计初衷并非是为了垄断，而主要是为了解决企业软件系统各个模块之间的跨节点通信问题。</p><p>在 Java 传统应用中，通常使用以下4中方式进行跨节点通信。</p><ul><li>通过 RMI 进行远程服务调用</li><li>通过 Java 的 Socket+Java 序列化方式进行跨节点调用</li><li>利用一些开源的 RPC 框架进行远程服务调用，如 Facebook 的 Thrift 、Apache 的 Avro 等</li><li>利用标准的公有协议进行跨节点服务调用，如：HTTP+XML、RESTful + JSON、WebService 等。</li></ul><p>跨节点的远程服务调用，除了链路层的物理连接外，还需要对请求和响应消息的编解码。在请求和应答消息之外，还需要携带一些其他控制和管理指令。如链路的握手请求和响应消息、链路检测的心跳消息等。这些功能组合到一起，就形成了私有协议。</p><p>事实上，私有协议并没有标准的定义，只要能拥有跨进程、跨主机数据交换的非标准协议，都可以被称为私有协议。</p><h4 id="12-2、Netty-协议栈功能设计"><a href="#12-2、Netty-协议栈功能设计" class="headerlink" title="12.2、Netty 协议栈功能设计"></a>12.2、Netty 协议栈功能设计</h4><p>Netty 协议栈用于内部各模块之间的通信，它基于TCP&#x2F;IP 协议栈，是一个类HTTP协议的应用层协议，相比传统的标准协议栈，它更加轻巧、灵活和实用。</p><h5 id="12-2-1、网络拓扑图"><a href="#12-2-1、网络拓扑图" class="headerlink" title="12.2.1、网络拓扑图"></a>12.2.1、网络拓扑图</h5><p><img src="/../assets/blogImg/Netty/12-1.png" alt="12-1"></p><ul><li>每个Netty 节点（Netty 进程）之间建立长连接， 使用 Netty 协议进行通信。</li><li>一个Netty 节点既可以作为客户端连接另外的Netty节点，也可以作为Netty服务端被其他Netty 节点连接。</li></ul><h5 id="12-2-2、协议栈功能描述"><a href="#12-2-2、协议栈功能描述" class="headerlink" title="12.2.2、协议栈功能描述"></a>12.2.2、协议栈功能描述</h5><p>Netty 协议栈承载了业务内部各模块之间的消息交互和服务调用，它的主要功能如下：</p><ul><li>基于Netty 的 NIO 通信，提供高性能异步通信能力</li><li>提供消息编解码框架，实现 POJO 的序列化和反序列化</li><li>提供基于IP地址的白名单接入认证机制</li><li>链路的有效性验证机制</li><li>链路断连重试机制</li></ul><h5 id="12-2-3、通讯模型"><a href="#12-2-3、通讯模型" class="headerlink" title="12.2.3、通讯模型"></a>12.2.3、通讯模型</h5><p><img src="/../assets/blogImg/Netty/12-2.png" alt="12-2"></p><ol><li>Netty 协议栈客户端发送握手请求消息，携带节点 ID 的有效身份验证信息；</li><li>Netty 协议栈服务端对握手请求消息进行合法性校验，包括节点 ID 有效性校验、节点重复登录校验和 IP地址合法性校验；</li><li>链路建立成功后，客户端发送业务消息</li><li>链路建立成功后，服务端发送心跳消息</li><li>链路建立成功后，客户端发送心跳消息</li><li>链路建立成功后，服务端发送业务消息</li><li>服务端退出关闭连接，客户端感知对方关闭连接，客户端被动关闭连接</li></ol><p>注意：双方的心跳采用 Ping-Pong 机制</p><h5 id="12-2-4、消息定义"><a href="#12-2-4、消息定义" class="headerlink" title="12.2.4、消息定义"></a>12.2.4、消息定义</h5><p>Netty 协议栈的消息主要有两部分</p><ul><li>消息头</li><li>消息体</li></ul><p>消息结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * netty 协议栈消息头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> NettyMsgHeader headers;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * netty 协议栈消息体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object body;</span><br></pre></td></tr></table></figure><p>消息头定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Netty消息校验码</span></span><br><span class="line"><span class="comment"> * 固定值 0xABEF 表名是 Netty 协议消息 2个字节</span></span><br><span class="line"><span class="comment"> * 主版本号：1-255  1个字节</span></span><br><span class="line"><span class="comment"> * 此版本好：1-255  1个字节</span></span><br><span class="line"><span class="comment"> * crc = 0xABEF + 主版本号 + 次版本号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> crcCode;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息长度，整个消息包括消息头和消息体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> length;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 会话id，集群内全局唯一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> sessionID;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息类型</span></span><br><span class="line"><span class="comment"> * 0：业务请求</span></span><br><span class="line"><span class="comment"> * 1：业务响应</span></span><br><span class="line"><span class="comment"> * 2：业务 ONE WAY 消息(既是请求又是响应)</span></span><br><span class="line"><span class="comment"> * 3：握手请求消息</span></span><br><span class="line"><span class="comment"> * 4：握手应答消息</span></span><br><span class="line"><span class="comment"> * 5：心跳请求消息</span></span><br><span class="line"><span class="comment"> * 6：心跳应答消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span> type;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息优先级 1-255</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span> priority;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可选字段，拓展请求头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,Object&gt; attachment;</span><br></pre></td></tr></table></figure><h5 id="12-2-5、Netty-消息字段支持的类型"><a href="#12-2-5、Netty-消息字段支持的类型" class="headerlink" title="12.2.5、Netty 消息字段支持的类型"></a>12.2.5、Netty 消息字段支持的类型</h5><p><img src="/../assets/blogImg/Netty/12-3.png" alt="12-3"></p><h5 id="12-2-6、Netty-协议的编码规范"><a href="#12-2-6、Netty-协议的编码规范" class="headerlink" title="12.2.6、Netty 协议的编码规范"></a>12.2.6、Netty 协议的编码规范</h5><p>对于NettyMessage 的编码，根据具体的数据类型调用 ByteBuffer 的方法来编码，如果请求头 header 的 int类型数据 crcCode 可以分别通过 <code>ByteBuffer.putInt</code> 和<code>ByteBuffer.getInt</code>来编解码，byte 类型数据 如 type 可以分别通过<code>ByteBuffer.put</code>和 <code>ByteBuffer.get</code>来实现编解码。</p><p>对于请求头中的 <code>attachment</code> 拓展属性字段数据的编解码的操作步骤相对多一些。它的编码规则首先判断是否有数据，如果不存在数据则写入编码长度 0，<code>ByteBuffer.putInt(0)</code>，如果有数据则写编码长度 <code>ByteBuffer.putInt(attachment.size())</code>。然后再对 key 编码，先编码长度，再编码 key 值数据。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attachment 编码过程</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">byte</span>[] value = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Object&gt; entry : attachment.entrySet())&#123;</span><br><span class="line">    key = entry.getKey();</span><br><span class="line">    buffer.writeString(key);</span><br><span class="line">    value = marshaller.writeObject(entry.getValue());</span><br><span class="line">    buffer.writeBinary(value);</span><br><span class="line">&#125;</span><br><span class="line">key = <span class="literal">null</span>;</span><br><span class="line">value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// attachment 解码过程</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Object</span> <span class="variable">objVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">    key = buffer.readString();</span><br><span class="line">    objVal = unmarshaller.readObject(buffer.readBinary());</span><br><span class="line">    <span class="built_in">this</span>.attachment.put(key,objVal);</span><br><span class="line">&#125;</span><br><span class="line">key = <span class="literal">null</span>;</span><br><span class="line">objVal = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h5 id="12-2-7、链路的建立"><a href="#12-2-7、链路的建立" class="headerlink" title="12.2.7、链路的建立"></a>12.2.7、链路的建立</h5><p>不区分客户端和服务端，一个节点既可以作为服务端也可以作为客户端，根据具体情况而定，先发起请求调用的一方节点作为客户端，被调用的作为服务端。</p><p>为了安全，使用基于 IP 地址黑白名单校验机制，如果有多个IP，通过逗号分割。实际商用环境可以通过密钥对用户名和密码加密以增加安全性。</p><h5 id="12-2-8、链路的关闭"><a href="#12-2-8、链路的关闭" class="headerlink" title="12.2.8、链路的关闭"></a>12.2.8、链路的关闭</h5><p>由于采用长链通信，在正常的业务运行期间，双方通过心跳和业务信息维持链路，任何一方都不需要主动关闭连接。</p><p>但是，以下情况，客户端和服务端需要关闭连接。</p><ol><li>当对方宕机或者重启时，会主动关闭链路，另一方读取到操作系统的通知信号，得知对方 RESET 链路，需要关闭连接，释放自身的句柄等资源。由于采用 TCP 全双工通信，通信双方都需要关闭连接，释放资源。</li><li>消息读写过程，发送 I&#x2F;O 异常，需要主动关闭连接</li><li>心跳消息读写过程发生 I&#x2F;O 异常，需要主动关闭连接</li><li>心跳超时，需要主动关闭连接</li><li>发送编码异常等不可恢复错误是，需要主动关闭连接。</li></ol><h5 id="12-2-9、可靠性设计"><a href="#12-2-9、可靠性设计" class="headerlink" title="12.2.9、可靠性设计"></a>12.2.9、可靠性设计</h5><p>可能会遇到恶劣的网络环境，如网络超时、闪断、或对方进程僵死等，为保证能在这种极端的网络环境下正常运行和自动恢复，我们需要对协议的可靠性进行设计和规划。</p><h6 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h6><p>在业务低谷时段，如果发生网络闪断、连接被Hang 住等网络问题时，由于没有业务消息，应用进程很难发现。到业务高峰期，会发送大量的网络通信失败，严重会导致一段时间内进程无法处理业务信息。</p><p>为解决这个问题，在网络空闲时采用心跳机制来检测链路的互通性，一旦发现网络故障，立即关闭网络，主动重连。</p><p>设计思路：</p><ol><li>当网络处于空闲状态持续时间达到 <em>T</em> 时，客户端主动发送 Ping 心跳消息给服务端。</li><li>如果下一个周期 <em>T</em> 到来时客户端没有收到对方发送的 Pong 心跳应答消息或者读取到服务端发送的其他业务消息，则心跳失败计数器加1。</li><li>每当客户端接收到服务的业务消息或者 Pong 应答消息是，将心跳失败计算器清零； 连续 <em>N</em> 次没有接收到服务器端的 Pong 消息或者业务消息，则关闭链路，间隔 INTERVAL 时间后发起重连操作。</li><li>服务端网络空闲状态时间达到 <em>T</em> 后，服务端将心跳失败计数器加1,；只要接收到客户端发送的 Ping 消息或者其他业务消息，计数器清零。</li><li>服务端连续 <em>N</em> 次没有接收到客户端的 Ping 消息或者其他业务消息，则关闭链路释放资源，等待客户端重连。</li></ol><h6 id="重连机制"><a href="#重连机制" class="headerlink" title="重连机制"></a>重连机制</h6><p>如果链路中断，等待 INTERVAL 时间后，客户端发起重连操作，如果重连失败，间隔周期 INTERVAL 后再次发起重连，直到重连成功。间隔 INTERVAL 时间再发起重连主要是保证句柄资源能够及时释放。</p><h6 id="重复登录保护"><a href="#重复登录保护" class="headerlink" title="重复登录保护"></a>重复登录保护</h6><p>当客户端握手成功之后，在链路正常状态下，不允许客户端重复登录，防止客户端在异常状态下反复重连导致句柄资源被耗尽。</p><p>服务端接收到客户端的握手请求消息后，首先对 IP 地址进行合法性校验，如果校验成功，在缓存地址表查看客户端是否已经登录，如果已经登录，则拒绝重复登录。</p><p>为了防止有服务端和客户端对链路状态理解不一致导致客户端无法握手成功的问题，当服务端连续 <em>N</em> 次心跳超时之后需要主动关闭链路，清空改客户端的地址缓存信息，保证后续该客户端可以重连成功，防止被重复登录保护机制拒绝掉。</p><h6 id="消息缓存重发"><a href="#消息缓存重发" class="headerlink" title="消息缓存重发"></a>消息缓存重发</h6><p>无论客户端还是服务端，当链路发生中断之后，在链路恢复之前，缓存在消息队列中待发送的消息不能丢失，等链路恢复之后，重新发送这些消息，保证链路中断期间消息不丢失。</p><h4 id="12-3、Netty-协议栈开发"><a href="#12-3、Netty-协议栈开发" class="headerlink" title="12.3、Netty 协议栈开发"></a>12.3、Netty 协议栈开发</h4><h5 id="12-3-1、数据结构定义"><a href="#12-3-1、数据结构定义" class="headerlink" title="12.3.1、数据结构定义"></a>12.3.1、数据结构定义</h5><p>自定义消息体数据结构定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyMessage</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * netty 协议栈消息头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> NettyMsgHeader headers;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * netty 协议栈消息体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object body;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> NettyMsgHeader <span class="title function_">getHeaders</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeaders</span><span class="params">(NettyMsgHeader headers)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.headers = headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBody</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBody</span><span class="params">(Object body)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.body = body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NettyMessage&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;headers=&quot;</span> + headers +</span><br><span class="line">                <span class="string">&quot;, body=&quot;</span> + body +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消息头</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyMsgHeader</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Netty消息校验码</span></span><br><span class="line"><span class="comment">     * 固定值 0xABEF 表名是 Netty 协议消息 2个字节</span></span><br><span class="line"><span class="comment">     * 主版本号：1-255  1个字节</span></span><br><span class="line"><span class="comment">     * 此版本好：1-255  1个字节</span></span><br><span class="line"><span class="comment">     * crc = 0xABEF + 主版本号 + 次版本号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">crcCode</span> <span class="operator">=</span> <span class="number">0xabef0101</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息长度，整个消息包括消息头和消息体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> length;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会话id，集群内全局唯一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> sessionID;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息类型</span></span><br><span class="line"><span class="comment">     * 0：业务请求</span></span><br><span class="line"><span class="comment">     * 1：业务响应</span></span><br><span class="line"><span class="comment">     * 2：业务 ONE WAY 消息(既是请求又是响应)</span></span><br><span class="line"><span class="comment">     * 3：握手请求消息</span></span><br><span class="line"><span class="comment">     * 4：握手应答消息</span></span><br><span class="line"><span class="comment">     * 5：心跳请求消息</span></span><br><span class="line"><span class="comment">     * 6：心跳应答消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> type;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息优先级 1-255</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> priority;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可选字段，拓展请求头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; attachment = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCrcCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> crcCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCrcCode</span><span class="params">(<span class="type">int</span> crcCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.crcCode = crcCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getSessionID</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sessionID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSessionID</span><span class="params">(<span class="type">long</span> sessionID)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sessionID = sessionID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span> <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setType</span><span class="params">(<span class="type">byte</span> type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span> <span class="title function_">getPriority</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">byte</span> priority)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getAttachment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> attachment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAttachment</span><span class="params">(Map&lt;String, Object&gt; attachment)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.attachment = attachment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NettyMsgHeader&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;crcCode=&quot;</span> + crcCode +</span><br><span class="line">                <span class="string">&quot;, length=&quot;</span> + length +</span><br><span class="line">                <span class="string">&quot;, sessionID=&quot;</span> + sessionID +</span><br><span class="line">                <span class="string">&quot;, type=&quot;</span> + type +</span><br><span class="line">                <span class="string">&quot;, priority=&quot;</span> + priority +</span><br><span class="line">                <span class="string">&quot;, attachment=&quot;</span> + attachment +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>握手请求、握手应答、心跳检测消息都可以通过该消息结构来承载，所以不需要单独定义独立的数据结构。</p><h5 id="12-3-2、消息编解码"><a href="#12-3-2、消息编解码" class="headerlink" title="12.3.2、消息编解码"></a>12.3.2、消息编解码</h5><p>在例程中，消息的编解码分别使用 NettyMessageEncoder和NettyMessageDecoder 来处理，其实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义编码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyMessageEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;NettyMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    MarshallingEncoder marshallingEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NettyMessageEncoder</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        marshallingEncoder = <span class="keyword">new</span> <span class="title class_">MarshallingEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, NettyMessage msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg==<span class="literal">null</span> || msg.getHeaders()==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The encode message is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.writeInt(msg.getHeaders().getCrcCode());</span><br><span class="line">        out.writeInt(msg.getHeaders().getLength());</span><br><span class="line">        out.writeLong(msg.getHeaders().getSessionID());</span><br><span class="line">        out.writeByte(msg.getHeaders().getType());</span><br><span class="line">        out.writeByte(msg.getHeaders().getPriority());</span><br><span class="line">        Map&lt;String,Object&gt; attachmentMap = msg.getHeaders().getAttachment();</span><br><span class="line">        out.writeInt(attachmentMap.size());</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,Object&gt; entry : attachmentMap.entrySet())&#123;</span><br><span class="line">            <span class="type">byte</span>[] key_arr = entry.getKey().getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            out.writeInt(key_arr.length);</span><br><span class="line">            out.writeBytes(key_arr);</span><br><span class="line">            marshallingEncoder.encode(entry.getValue(),out);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.getBody()==<span class="literal">null</span>)&#123;</span><br><span class="line">            out.writeInt(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            marshallingEncoder.encode(msg.getBody(),out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置 header.length 的值，重新设置整个消息的长度，包括消息头和消息体。</span></span><br><span class="line"><span class="comment">         * 因为解码器 &#123;<span class="doctag">@link</span> NettyMessageDecoder&#125; 是通过继承 &#123;<span class="doctag">@link</span> io.netty.handler.codec.LengthFieldBasedFrameDecoder&#125;</span></span><br><span class="line"><span class="comment">         * 自定义长度解码器来解决TCP粘包问题。</span></span><br><span class="line"><span class="comment">         * &lt;pre/&gt;</span></span><br><span class="line"><span class="comment">         * 此处减去 8 是因为：</span></span><br><span class="line"><span class="comment">         * 长度字段的位移位置为 4，长度字段本身所占的长度也为 4，帧长度的调整字段=0</span></span><br><span class="line"><span class="comment">         * 即：</span></span><br><span class="line"><span class="comment">         * lengthFieldOffset = 4</span></span><br><span class="line"><span class="comment">         * lengthFieldLength = 4</span></span><br><span class="line"><span class="comment">         * lengthAdjustment = 0</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 由 LengthFieldBasedFrameDecoder 源码可知 lengthFieldEndOffset = lengthFieldOffset + lengthFieldLength = 8</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 调节帧长度</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;frameLength += lengthAdjustment + lengthFieldEndOffset;&lt;p/&gt;</span></span><br><span class="line"><span class="comment">         * frameLength = 整个消息的长度，即从长度字段中读取出来的长度数据</span></span><br><span class="line"><span class="comment">         * 所以 -8 其作用相当于 lengthAdjustment=-8， 因为消息头部包含消息的长度，需要作出修正调整，避免读取消息不完整。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        out.setInt(<span class="number">4</span>,out.readableBytes()-<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义解码器</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> NettyMessageDecoder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> netty message 解码器开发</span></span><br><span class="line"><span class="comment"> * 继承 &#123;<span class="doctag">@link</span> LengthFieldBasedFrameDecoder&#125;</span></span><br><span class="line"><span class="comment"> * 因为 LengthFieldBaseFrameDecoder 自动支持TCP 粘包和半包处理。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/9/23 14:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyMessageDecoder</span> <span class="keyword">extends</span> <span class="title class_">LengthFieldBasedFrameDecoder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MarshallingDecoder marshallingDecoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NettyMessageDecoder</span><span class="params">(<span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength);</span><br><span class="line">        marshallingDecoder = <span class="keyword">new</span> <span class="title class_">MarshallingDecoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 调用父类解码方法，返回整包或者半空，为空的话，说明是个半包消息，直接返回由 IO线程 读取后续码流。</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">frame</span> <span class="operator">=</span> (ByteBuf) <span class="built_in">super</span>.decode(ctx, in);</span><br><span class="line">        <span class="keyword">if</span> (frame==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">NettyMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyMessage</span>();</span><br><span class="line">        <span class="type">NettyMsgHeader</span> <span class="variable">header</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyMsgHeader</span>();</span><br><span class="line">        header.setCrcCode(frame.readInt());</span><br><span class="line">        header.setLength(frame.readInt());</span><br><span class="line">        header.setSessionID(frame.readLong());</span><br><span class="line">        header.setType(frame.readByte());</span><br><span class="line">        header.setPriority(frame.readByte());</span><br><span class="line">        <span class="type">int</span> <span class="variable">attachmentMapSize</span> <span class="operator">=</span> frame.readInt();</span><br><span class="line">        <span class="keyword">if</span> (attachmentMapSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            Map&lt;String,Object&gt; attachmentMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="type">byte</span>[] key_arr = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;attachmentMapSize; i++)&#123;</span><br><span class="line">                key_arr = <span class="keyword">new</span> <span class="title class_">byte</span>[frame.readInt()];</span><br><span class="line">                frame.readBytes(key_arr);</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(key_arr,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                value = marshallingDecoder.decode(in);</span><br><span class="line">                attachmentMap.put(key,value);</span><br><span class="line">            &#125;</span><br><span class="line">            key_arr=<span class="literal">null</span>;</span><br><span class="line">            value=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        message.setHeaders(header);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (frame.readableBytes()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">body</span> <span class="operator">=</span> marshallingDecoder.decode(frame);</span><br><span class="line">            <span class="keyword">if</span> (body!=<span class="literal">null</span>)&#123;</span><br><span class="line">                message.setBody(body);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中使用了 Marshalling 来处理对象序列化和反序列化，其代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义的 Marshalling 编码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarshallingEncoder</span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] LENGTH_PLACEHOLDER = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="type">Marshaller</span> <span class="variable">marshaller</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MarshallingEncoder</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.marshaller = MarshallingCodeFactory.buildMarshaller();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(Object obj, ByteBuf out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lengthPos</span> <span class="operator">=</span> out.writerIndex();</span><br><span class="line">        out.writeBytes(LENGTH_PLACEHOLDER);</span><br><span class="line">        <span class="type">ChannelBufferByteOutput</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelBufferByteOutput</span>(out);</span><br><span class="line">        marshaller.start(output);</span><br><span class="line">        marshaller.writeObject(obj);</span><br><span class="line">        marshaller.finish();</span><br><span class="line">        marshaller.close();</span><br><span class="line"></span><br><span class="line">        out.setInt(lengthPos, out.writerIndex() - lengthPos - <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义 Unmarshalling 解码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarshallingDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Unmarshaller unmarshaller;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MarshallingDecoder</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        unmarshaller = MarshallingCodeFactory.buildUnmarshaller();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">decode</span><span class="params">(ByteBuf in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">objectSize</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="keyword">if</span> (objectSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> in.slice(in.readerIndex(),objectSize);</span><br><span class="line">            <span class="type">ByteInput</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelBufferByteInput</span>(buf);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                unmarshaller.start(input);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> unmarshaller.readObject();</span><br><span class="line">                unmarshaller.finish();</span><br><span class="line">                in.readerIndex(in.readerIndex()+objectSize);</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// Call close in a finally block as the ReplayingDecoder will throw an Error if not enough bytes are</span></span><br><span class="line">                <span class="comment">// readable. This helps to be sure that we do not leak resource</span></span><br><span class="line">                unmarshaller.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="12-3-3、握手和安全认证"><a href="#12-3-3、握手和安全认证" class="headerlink" title="12.3.3、握手和安全认证"></a>12.3.3、握手和安全认证</h5><p><strong>客户端握手认证</strong></p><p>握手认证是在客户端和服务端成功建立TCP通信激活时，发送握手请求给服务端，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientMsgHeaderHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.writeAndFlush(buildNettyMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NettyMessage</span> <span class="variable">message</span> <span class="operator">=</span> (NettyMessage) msg;</span><br><span class="line">        <span class="comment">// 判断如果是握手应答消息，判断是否成功</span></span><br><span class="line">        <span class="keyword">if</span> (message!=<span class="literal">null</span> &amp;&amp; message.getHeaders()!=<span class="literal">null</span></span><br><span class="line">                &amp;&amp; message.getHeaders().getType()==MessageType.SHARKHAND_RESP.val)&#123;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">loginResult</span> <span class="operator">=</span> (<span class="type">byte</span>) message.getBody();</span><br><span class="line">            <span class="keyword">if</span> (loginResult != (<span class="type">byte</span>) <span class="number">0</span>)&#123;</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;login is ok:&quot;</span>+message);</span><br><span class="line">                ctx.fireChannelRead(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireExceptionCaught(cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建请求消息</span></span><br><span class="line">    <span class="keyword">public</span> NettyMessage <span class="title function_">buildNettyMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">NettyMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyMessage</span>();</span><br><span class="line">        <span class="type">NettyMsgHeader</span> <span class="variable">header</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyMsgHeader</span>();</span><br><span class="line">        header.setType(MessageType.SHARKHAND_REQ.val);</span><br><span class="line">        message.setHeaders(header);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginAuthRespHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Boolean&gt; nodeCheck = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> String[] whiteIps = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;127.0.0.1&quot;</span>,<span class="string">&quot;192.168.2.190&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NettyMessage</span> <span class="variable">message</span> <span class="operator">=</span> (NettyMessage) msg;</span><br><span class="line">        <span class="keyword">if</span> (message.getHeaders()!=<span class="literal">null</span> &amp;&amp; message.getHeaders().getType()== MessageType.SHARKHAND_REQ.val)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">nodeIndex</span> <span class="operator">=</span> ctx.channel().remoteAddress().toString();</span><br><span class="line">            <span class="type">NettyMessage</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 已登录节点校验检查，避免重复登录</span></span><br><span class="line">            <span class="keyword">if</span> (nodeCheck.containsKey(nodeIndex))&#123;</span><br><span class="line">                <span class="comment">// 重复登录</span></span><br><span class="line">                resp = buildResponse((<span class="type">byte</span>) -<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 白名单登录校验</span></span><br><span class="line">                <span class="type">InetSocketAddress</span> <span class="variable">socketAddress</span> <span class="operator">=</span> (InetSocketAddress) ctx.channel().remoteAddress();</span><br><span class="line">                <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> socketAddress.getAddress().getHostAddress();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isOk</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (String wip : whiteIps)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (wip.equals(ip))&#123;</span><br><span class="line">                        isOk = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isOk)&#123;</span><br><span class="line">                    resp = buildResponse((<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">                    nodeCheck.put(ip,<span class="literal">true</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    resp = buildResponse((<span class="type">byte</span>) -<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;The login response is : &quot;</span>+resp+<span class="string">&quot;, body is [&quot;</span>+resp.getBody()+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            ctx.writeAndFlush(resp);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        nodeCheck.remove(ctx.channel().remoteAddress().toString());</span><br><span class="line">        ctx.close();</span><br><span class="line">        ctx.fireExceptionCaught(cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建握手请求消息返回</span></span><br><span class="line">    <span class="keyword">private</span> NettyMessage <span class="title function_">buildResponse</span><span class="params">(<span class="type">byte</span> result)</span>&#123;</span><br><span class="line">        <span class="type">NettyMessage</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyMessage</span>();</span><br><span class="line">        <span class="type">NettyMsgHeader</span> <span class="variable">header</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyMsgHeader</span>();</span><br><span class="line">        header.setType(MessageType.SHARKHAND_RESP.val);</span><br><span class="line">        response.setHeaders(header);</span><br><span class="line">        response.setBody(result);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过与客户端TCP三次握手成功后，客户端发送握手认证消息给服务端，服务端根据消息类型判断，如果是握手认证消息，则判断是否已经登录并且是否在白名单配置中，如果通过则构造握手响应消息返回给客户端。</p><h5 id="12-3-4、心跳检测"><a href="#12-3-4、心跳检测" class="headerlink" title="12.3.4、心跳检测"></a>12.3.4、心跳检测</h5><p>握手成功后，在客户端接收到服务端响应的握手成功消息后。客户端主动发起心跳消息，服务端收到客户端心跳消息后，返回心跳应答，在此过程中，心跳消息主要是检测链路的可用性，不需要携带消息体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端心跳请求代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeartBeatReqHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ScheduledFuture&lt;?&gt; heartBeat;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NettyMessage</span> <span class="variable">message</span> <span class="operator">=</span> (NettyMessage) msg;</span><br><span class="line">        <span class="comment">// 客户端握手成功主动发心跳消息</span></span><br><span class="line">        <span class="keyword">if</span> (message.getHeaders()!=<span class="literal">null</span> &amp;&amp; message.getHeaders().getType()== MessageType.SHARKHAND_RESP.val)&#123;</span><br><span class="line">            heartBeat = ctx.executor().scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">HeartBeatTask</span>(ctx),<span class="number">0</span>,<span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (message.getHeaders()!=<span class="literal">null</span> &amp;&amp; message.getHeaders().getType()==MessageType.HEARTBEAT_RESP.val)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;client received hear tbeat message : &lt;---- &quot;</span>+message);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(heartBeat!=<span class="literal">null</span>)&#123;</span><br><span class="line">            heartBeat.cancel(<span class="literal">true</span>);</span><br><span class="line">            heartBeat=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.fireExceptionCaught(cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeartBeatTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ChannelHandlerContext ctx;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">HeartBeatTask</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.ctx = ctx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">NettyMessage</span> <span class="variable">message</span> <span class="operator">=</span> buildHeartBeat();</span><br><span class="line">            System.out.println(<span class="string">&quot;client send heart beat to server : ----&gt; &quot;</span>+message);</span><br><span class="line">            ctx.writeAndFlush(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> NettyMessage <span class="title function_">buildHeartBeat</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">NettyMessage</span> <span class="variable">nettyMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyMessage</span>();</span><br><span class="line">            <span class="type">NettyMsgHeader</span> <span class="variable">nettyMsgHeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyMsgHeader</span>();</span><br><span class="line"></span><br><span class="line">            nettyMsgHeader.setType(MessageType.HEARTBEAT_REQ.val);</span><br><span class="line">            nettyMessage.setHeaders(nettyMsgHeader);</span><br><span class="line">            <span class="keyword">return</span> nettyMessage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 服务端心跳应答代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeartBeatRespHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NettyMessage</span> <span class="variable">message</span> <span class="operator">=</span> (NettyMessage) msg;</span><br><span class="line">        <span class="keyword">if</span> (message.getHeaders()!=<span class="literal">null</span> &amp;&amp; message.getHeaders().getType()== MessageType.HEARTBEAT_REQ.val)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Server received heart beat : &lt;---- &quot;</span>+message);</span><br><span class="line">            <span class="type">NettyMessage</span> <span class="variable">respHeartBeat</span> <span class="operator">=</span> buildRespHeartBeat();</span><br><span class="line">            System.out.println(<span class="string">&quot;Server send heart beat to client : ----&gt; &quot;</span>+respHeartBeat);</span><br><span class="line">            ctx.writeAndFlush(respHeartBeat);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> NettyMessage <span class="title function_">buildRespHeartBeat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NettyMessage</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyMessage</span>();</span><br><span class="line">        <span class="type">NettyMsgHeader</span> <span class="variable">header</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyMsgHeader</span>();</span><br><span class="line">        header.setType(MessageType.HEARTBEAT_RESP.val);</span><br><span class="line">        resp.setHeaders(header);</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireExceptionCaught(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在客户端接收到握手成功的响应消息后，响应信息通过 Handler 继续向下传递，HeartBeatReqHandler 接收到消息，判断如果是握手成功，则启动无限循环定时器发送心跳消息。NioEventLoop 是一个 Schdule，因此支持定时器的执行。心跳第定时器很简单，通过构造参数获取 <code>ChannelHandlerContext</code> 发送消息。</p><p>在服务端接收到心跳消息则返回心跳应答即可。</p><p>心跳超时很简单，利用 Netty 的 <code>ReadTimeOutHandler</code> 机制，一定周期内没有读取到对方消息时，需要主动关闭客户端连接。如果是客户端，重新发起连接；如果是服务端，释放资源，清除客户端登录缓存，等待客户端重连。</p><h5 id="12-3-5、断连重试"><a href="#12-3-5、断连重试" class="headerlink" title="12.3.5、断连重试"></a>12.3.5、断连重试</h5><p>在客户端中，感知到断连后，释放资源，重新发起连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(host,port)</span><br><span class="line">            ,<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(NettyConstant.LOCALIP,NettyConstant.LOCALPORT)).sync();</span><br><span class="line">    future.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放所有资源再重新发起连接</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">                connect(NettyConstant.REMOTEIP,NettyConstant.PORT);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听网络断连事件，如果 <code>Channel</code> 关闭，则自行后续重连任务，通过 Bootstrap 重新发起连接。客户端挂在<code>closeFuture</code> 上监听链路关闭信号，一旦关闭，则创建重连定时器，5s 重新发起连接，直到连接成功。</p><h5 id="12-3-6、客户端代码"><a href="#12-3-6、客户端代码" class="headerlink" title="12.3.6、客户端代码"></a>12.3.6、客户端代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">EventLoopGroup</span> <span class="variable">loopGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(String host, <span class="type">int</span> port)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(loopGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY,<span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyMessageDecoder</span>(<span class="number">1024</span>*<span class="number">1024</span>,<span class="number">4</span>,<span class="number">4</span>));</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;MessageEncoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">NettyMessageEncoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;redadTimeOutHandler&quot;</span>,<span class="keyword">new</span> <span class="title class_">ReadTimeoutHandler</span>(<span class="number">50</span>));</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;loginHandler&quot;</span>,<span class="keyword">new</span> <span class="title class_">ClientMsgHeaderHandler</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;HeartBeatHandler&quot;</span>,<span class="keyword">new</span> <span class="title class_">HeartBeatReqHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(host,port)</span><br><span class="line">                    ,<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(NettyConstant.LOCALIP,NettyConstant.LOCALPORT)).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放所有资源再重新发起连接</span></span><br><span class="line">            executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">5</span>);</span><br><span class="line">                        connect(NettyConstant.REMOTEIP,NettyConstant.PORT);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span>&#123;</span><br><span class="line">        <span class="type">NettyClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyClient</span>();</span><br><span class="line">        client.connect(NettyConstant.REMOTEIP,NettyConstant.PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="12-3-7、服务端代码"><a href="#12-3-7、服务端代码" class="headerlink" title="12.3.7、服务端代码"></a>12.3.7、服务端代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 初始化线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyMessageDecoder</span>(<span class="number">1024</span>*<span class="number">1024</span>,<span class="number">4</span>,<span class="number">4</span>));</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;MessageEncoder&quot;</span>,<span class="keyword">new</span> <span class="title class_">NettyMessageEncoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;LoginAuthRespHandler&quot;</span>,<span class="keyword">new</span> <span class="title class_">LoginAuthRespHandler</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;HeartBeatRespHandler&quot;</span>,<span class="keyword">new</span> <span class="title class_">HeartBeatRespHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> serverBootstrap.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">NettyServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyServer</span>();</span><br><span class="line">        server.bind(NettyConstant.PORT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-4、运行协议栈结果"><a href="#12-4、运行协议栈结果" class="headerlink" title="12.4、运行协议栈结果"></a>12.4、运行协议栈结果</h4><p><img src="/../assets/blogImg/Netty/12-4-1.png" alt="12-4-1"></p><p><img src="/../assets/blogImg/Netty/12-4-2.png" alt="12-4-2"></p><h3 id="十三、服务端创建"><a href="#十三、服务端创建" class="headerlink" title="十三、服务端创建"></a>十三、服务端创建</h3><h4 id="13-1、服务端创建流程"><a href="#13-1、服务端创建流程" class="headerlink" title="13.1、服务端创建流程"></a>13.1、服务端创建流程</h4><p><img src="/../assets/blogImg/Netty/13-1.png" alt="13-1"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一、Java-的I-O演进之路&quot;&gt;&lt;a href=&quot;#一、Java-的I-O演进之路&quot; class=&quot;headerlink&quot; title=&quot;一、Java 的I&amp;#x2F;O演进之路&quot;&gt;&lt;/a&gt;一、Java 的I&amp;#x2F;O演进之路&lt;/h3&gt;&lt;p&gt;Java1.4之前的早期版本，对I&amp;#x2F;O的支持并不完善，使得开发人员在开发高性能I&amp;#x2F;O程序时，面了巨大的挑战和困难，其主要问题如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有数据缓冲区，I&amp;#x2F;O 性能存在问题；&lt;/li&gt;
&lt;li&gt;没有C或者C++中的Channel概念，只有输入和输出流；&lt;/li&gt;
&lt;li&gt;同步阻塞式 I&amp;#x2F;O 通信（BIO)，通常会导致通信线程被长时间阻塞；&lt;/li&gt;
&lt;li&gt;支持的字符集有限，硬件可移植不好。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://cxinxian.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>抽象语法树的应用样例</title>
    <link href="http://cxinxian.github.io/2021/05/24/java-ast-2/"/>
    <id>http://cxinxian.github.io/2021/05/24/java-ast-2/</id>
    <published>2021-05-24T10:02:41.000Z</published>
    <updated>2021-06-05T00:47:42.160Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章<a href="2021/05/19/java-ast">java抽象语法树（AST）</a>中已经介绍了部分定义语法树的的节点，接下来在这篇将会通过样例代码以及注释介绍如何使用语法树节点来生成setter、getter、toString、hash、equal 等方法。</p><span id="more"></span><p>需要通过注解处理器生成 setter、getter、toString、hash、equal的类如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoC</span> &#123;</span><br><span class="line">    String var1;</span><br><span class="line">    String var2;</span><br><span class="line">    Integer tempInt;</span><br><span class="line">    Double tempDouble;</span><br><span class="line">    DemoA demoA;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法树的访问是通过继承 <code>TreeTranslator</code> ，并且重写了 visitClassDef 方法来实现访问 DemoC 类通过语法节点来访问 DemoC 中的变量。</p><h5 id="setter-方法生成样例"><a href="#setter-方法生成样例" class="headerlink" title="setter 方法生成样例"></a>setter 方法生成样例</h5><p>产生类似于 <code>public void setter(int a)&#123;this.a = a;&#125;  </code>的代码，需要用到的语法树节点分别有 JCModifiers、JCExpression、JCVariableDecl、JCStatement、JCBlock</p><p>定义 public  可以使用 <code>treeMaker.Modifiers(Flags.PUBLIC)</code></p><p>定义 void  返回类型可以这样使用 <code>treeMaker.TypeIdent(TypeTag.VOID)</code></p><p>定义方法名称 这可以 通过 Names 工具来实现，比如 <code>name.fromString(“setA”);</code>方法名中的大小写字母这些细节可以通过字符串截取其中一个字符来实现。</p><p>参数 的定义可以这样<code>treeMaker.VarDef(treeMaker.Modifiers(Flags.PARAMETER),jcVariableDecl.name,jcVariableDecl.vartype,null)</code>来实现。</p><p>最后 <code>this.xxx = xxx;</code> 语句的构建通过 <code>treeMaker.Exec(         treeMaker.Assign(             treeMaker.Select(treeMaker.Ident(names.fromString(&quot;this&quot;)),jcVariableDecl.name),             treeMaker.Ident(param.name)))</code></p><p>详细的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成 Setter 方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jcVariableDecl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> JCTree.JCMethodDecl <span class="title function_">makeSetterMethod</span><span class="params">(JCTree.JCVariableDecl jcVariableDecl)</span>&#123;</span><br><span class="line">    JCTree.<span class="type">JCModifiers</span> <span class="variable">modifiers</span> <span class="operator">=</span> treeMaker.Modifiers(Flags.PUBLIC);</span><br><span class="line">    <span class="comment">// 返回类型</span></span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">returnType</span> <span class="operator">=</span> treeMaker.TypeIdent(TypeTag.VOID);</span><br><span class="line">    <span class="comment">// 方法名称</span></span><br><span class="line">    <span class="type">Name</span> <span class="variable">methodName</span> <span class="operator">=</span> getSetterMethod(jcVariableDecl);</span><br><span class="line">    <span class="comment">// 参数</span></span><br><span class="line">    List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();</span><br><span class="line">    JCTree.<span class="type">JCVariableDecl</span> <span class="variable">param</span> <span class="operator">=</span> treeMaker.VarDef(</span><br><span class="line">        treeMaker.Modifiers(Flags.PARAMETER),</span><br><span class="line">        jcVariableDecl.name,</span><br><span class="line">        jcVariableDecl.vartype,<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//设置形参这一句不能少，不然会编译报错(java.lang.AssertionError: Value of x -1)</span></span><br><span class="line">    param.pos = jcVariableDecl.pos; </span><br><span class="line">    jcVariableDeclList = jcVariableDeclList.append(param);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建语句  //this.xxx = xxx;  setter方法中的赋值语句</span></span><br><span class="line">    JCTree.<span class="type">JCStatement</span> <span class="variable">statement</span> <span class="operator">=</span> treeMaker.Exec(</span><br><span class="line">        treeMaker.Assign(</span><br><span class="line">            treeMaker.Select(treeMaker.Ident(names.fromString(<span class="string">&quot;this&quot;</span>)),jcVariableDecl.name),</span><br><span class="line">            treeMaker.Ident(param.name)));</span><br><span class="line">    List&lt;JCTree.JCStatement&gt; statementList = List.nil();</span><br><span class="line">    statementList = statementList.append(statement);</span><br><span class="line"></span><br><span class="line">    JCTree.<span class="type">JCBlock</span> <span class="variable">jcBlock</span> <span class="operator">=</span> treeMaker.Block(<span class="number">0</span>,statementList);</span><br><span class="line">    <span class="comment">// 泛型参数</span></span><br><span class="line">    List&lt;JCTree.JCTypeParameter&gt; typeParameters = List.nil();</span><br><span class="line">    <span class="comment">// 异常抛出列表</span></span><br><span class="line">    List&lt;JCTree.JCExpression&gt; throwsClauses = List.nil();</span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">defaultValue</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//非自定义注解类中的方法，defaultValue为null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建settter 方法</span></span><br><span class="line">    JCTree.<span class="type">JCMethodDecl</span> <span class="variable">jcMethodDecl</span> <span class="operator">=</span> treeMaker.MethodDef(modifiers,</span><br><span class="line">                                                           methodName,</span><br><span class="line">                                                           returnType,</span><br><span class="line">                                                           typeParameters,</span><br><span class="line">                                                           jcVariableDeclList,</span><br><span class="line">                                                           throwsClauses,</span><br><span class="line">                                                           jcBlock,defaultValue);</span><br><span class="line">    <span class="keyword">return</span> jcMethodDecl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="getter-方法生成样例"><a href="#getter-方法生成样例" class="headerlink" title="getter 方法生成样例"></a>getter 方法生成样例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成Getter 方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jcVariableDecl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> JCTree.JCMethodDecl <span class="title function_">makeGetterMethod</span><span class="params">(JCTree.JCVariableDecl jcVariableDecl)</span>&#123;</span><br><span class="line">    JCTree.<span class="type">JCModifiers</span> <span class="variable">modifiers</span> <span class="operator">=</span> treeMaker.Modifiers(Flags.PUBLIC);</span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">returnType</span> <span class="operator">=</span> jcVariableDecl.vartype;</span><br><span class="line">    <span class="comment">// 方法名</span></span><br><span class="line">    <span class="type">Name</span> <span class="variable">methodName</span> <span class="operator">=</span> getGetterMethod(jcVariableDecl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建语句 this.var</span></span><br><span class="line">    JCTree.<span class="type">JCStatement</span> <span class="variable">statement</span> <span class="operator">=</span> treeMaker.Return(</span><br><span class="line">            treeMaker.Select(</span><br><span class="line">                    treeMaker.Ident(</span><br><span class="line">                            names.fromString(<span class="string">&quot;this&quot;</span>)),jcVariableDecl.name));</span><br><span class="line"></span><br><span class="line">    List&lt;JCTree.JCStatement&gt; statementList = List.nil();</span><br><span class="line">    statementList = statementList.append(statement);</span><br><span class="line">    <span class="comment">// 构建代码块</span></span><br><span class="line">    JCTree.<span class="type">JCBlock</span> <span class="variable">jcBlock</span> <span class="operator">=</span> treeMaker.Block(<span class="number">0</span>,statementList);</span><br><span class="line">    <span class="comment">// 泛型参数列表</span></span><br><span class="line">    List&lt;JCTree.JCTypeParameter&gt; typeParameters = List.nil();</span><br><span class="line">    <span class="comment">// 参数类型</span></span><br><span class="line">    List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();</span><br><span class="line">    <span class="comment">// 异常抛出列表</span></span><br><span class="line">    List&lt;JCTree.JCExpression&gt; throwsClauses  = List.nil();</span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">defaultValue</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//非自定义注解类中的方法，defaultValue为null</span></span><br><span class="line"></span><br><span class="line">    JCTree.<span class="type">JCMethodDecl</span> <span class="variable">jcMethodDecl</span> <span class="operator">=</span> treeMaker.MethodDef(modifiers,</span><br><span class="line">                                                           methodName,</span><br><span class="line">                                                           returnType,</span><br><span class="line">                                                           typeParameters,</span><br><span class="line">                                                           jcVariableDeclList,</span><br><span class="line">                                                           throwsClauses,jcBlock,defaultValue);</span><br><span class="line">    <span class="keyword">return</span> jcMethodDecl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="toString-方法生成"><a href="#toString-方法生成" class="headerlink" title="toString 方法生成"></a>toString 方法生成</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成 toString 方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jcClassDecl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> JCTree.JCMethodDecl <span class="title function_">makeToStringMethod</span><span class="params">(JCTree.JCClassDecl jcClassDecl)</span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;JCTree.JCVariableDecl&gt; vars = List.nil();</span><br><span class="line">    List&lt;JCTree&gt; jcTreeList = jcClassDecl.defs;</span><br><span class="line">    <span class="keyword">for</span> (JCTree jcTree: jcTreeList)&#123;</span><br><span class="line">        <span class="keyword">if</span> (jcTree <span class="keyword">instanceof</span> JCTree.JCVariableDecl)&#123;</span><br><span class="line">            JCTree.<span class="type">JCVariableDecl</span> <span class="variable">var</span> <span class="operator">=</span> (JCTree.JCVariableDecl) jcTree;</span><br><span class="line">            vars = vars.append(<span class="keyword">var</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;JCTree.JCAnnotation&gt; jcAnnotationList = List.nil();</span><br><span class="line">    <span class="comment">// 方法注解</span></span><br><span class="line">    JCTree.<span class="type">JCAnnotation</span> <span class="variable">jcAnnotation</span> <span class="operator">=</span> treeMaker.Annotation(memberAccess(<span class="string">&quot;java.lang.Override&quot;</span>),</span><br><span class="line">                                                            List.nil());</span><br><span class="line">    jcAnnotationList = jcAnnotationList.append(jcAnnotation);</span><br><span class="line">    JCTree.<span class="type">JCModifiers</span> <span class="variable">jcModifiers</span> <span class="operator">=</span> treeMaker.Modifiers(Flags.PUBLIC,jcAnnotationList); <span class="comment">// 方法修饰词</span></span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">returnType</span> <span class="operator">=</span> memberAccess(<span class="string">&quot;java.lang.String&quot;</span>); <span class="comment">// 返回类型</span></span><br><span class="line">    <span class="type">Name</span> <span class="variable">name</span> <span class="operator">=</span> names.fromString(<span class="string">&quot;toString&quot;</span>); <span class="comment">// 方法名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;DemoC&#123;</span></span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">jcExpression</span> <span class="operator">=</span> treeMaker.Literal(jcClassDecl.name + <span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;vars.size(); i++)&#123;</span><br><span class="line">        JCTree.<span class="type">JCVariableDecl</span> <span class="variable">var</span> <span class="operator">=</span> vars.get(i);</span><br><span class="line">        <span class="keyword">if</span> (i!=<span class="number">0</span>)&#123;</span><br><span class="line">            jcExpression = treeMaker.Binary(JCTree.Tag.PLUS,</span><br><span class="line">                                            jcExpression,</span><br><span class="line">                                            treeMaker.Literal(<span class="string">&quot;,&quot;</span> + <span class="keyword">var</span>.name.toString()+<span class="string">&quot;=&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 构建语句  var=</span></span><br><span class="line">            jcExpression = treeMaker.Binary(JCTree.Tag.PLUS,</span><br><span class="line">                                            jcExpression,</span><br><span class="line">                                            treeMaker.Literal(<span class="keyword">var</span>.name.toString()+<span class="string">&quot;=&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">var</span>.vartype.toString().contains(<span class="string">&quot;String&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// var=&#x27;&quot;+</span></span><br><span class="line">            jcExpression = treeMaker.Binary(JCTree.Tag.PLUS,jcExpression,treeMaker.Literal(<span class="string">&quot;&#x27;&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// var=&#x27;&quot;+var</span></span><br><span class="line">        jcExpression = treeMaker.Binary(JCTree.Tag.PLUS,jcExpression,treeMaker.Ident(<span class="keyword">var</span>.name));</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">var</span>.vartype.toString().contains(<span class="string">&quot;String&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// var=&#x27;&quot;+var+&#x27;&quot;</span></span><br><span class="line">            jcExpression = treeMaker.Binary(JCTree.Tag.PLUS,jcExpression,treeMaker.Literal(<span class="string">&quot;&#x27;&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    jcExpression = treeMaker.Binary(JCTree.Tag.PLUS,jcExpression,treeMaker.Literal(<span class="string">&quot;&#125;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    JCTree.<span class="type">JCStatement</span> <span class="variable">jcStatement</span> <span class="operator">=</span> treeMaker.Return(jcExpression);</span><br><span class="line">    List&lt;JCTree.JCStatement&gt; statementList = List.nil();</span><br><span class="line">    statementList = statementList.append(jcStatement);</span><br><span class="line">    JCTree.<span class="type">JCBlock</span> <span class="variable">jcBlock</span> <span class="operator">=</span> treeMaker.Block(<span class="number">0</span>,statementList);</span><br><span class="line">    <span class="comment">// 参数列表</span></span><br><span class="line">    List&lt;JCTree.JCVariableDecl&gt; variableDecls = List.nil();</span><br><span class="line">    <span class="comment">// 形参列表</span></span><br><span class="line">    List&lt;JCTree.JCTypeParameter&gt; jcTypeParameters = List.nil();</span><br><span class="line">    <span class="comment">// 异常列表</span></span><br><span class="line">    List&lt;JCTree.JCExpression&gt; throwableList = List.nil();</span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">defaultValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    JCTree.<span class="type">JCMethodDecl</span> <span class="variable">jcMethodDecl</span> <span class="operator">=</span> treeMaker.MethodDef(jcModifiers,</span><br><span class="line">                                                           name,</span><br><span class="line">                                                           returnType,</span><br><span class="line">                                                           jcTypeParameters,</span><br><span class="line">                                                           variableDecls,</span><br><span class="line">                                                           throwableList,jcBlock,defaultValue);</span><br><span class="line">    <span class="keyword">return</span> jcMethodDecl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="hash-方法生成"><a href="#hash-方法生成" class="headerlink" title="hash 方法生成"></a>hash 方法生成</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成 hash 方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classDecl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> JCTree.JCMethodDecl <span class="title function_">makeHashMethodDecl</span><span class="params">(JCTree.JCClassDecl classDecl)</span>&#123;</span><br><span class="line">    List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();</span><br><span class="line">    List&lt;JCTree&gt; jcTreeList = classDecl.defs;</span><br><span class="line">    <span class="keyword">for</span> (JCTree jcTree : jcTreeList)&#123;</span><br><span class="line">        <span class="keyword">if</span> (jcTree <span class="keyword">instanceof</span> JCTree.JCVariableDecl)&#123;</span><br><span class="line">            JCTree.<span class="type">JCVariableDecl</span> <span class="variable">jcVariableDecl</span> <span class="operator">=</span> (JCTree.JCVariableDecl) jcTree;</span><br><span class="line">            jcVariableDeclList = jcVariableDeclList.append(jcVariableDecl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Override 方法注解</span></span><br><span class="line">    JCTree.<span class="type">JCAnnotation</span> <span class="variable">jcAnnotation</span> <span class="operator">=</span> treeMaker.Annotation(memberAccess(<span class="string">&quot;java.lang.Override&quot;</span>),</span><br><span class="line">                                                            List.nil());</span><br><span class="line">    List&lt;JCTree.JCAnnotation&gt; jcAnnotationList = List.nil();</span><br><span class="line">    jcAnnotationList = jcAnnotationList.append(jcAnnotation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰方法关键字</span></span><br><span class="line">    JCTree.<span class="type">JCModifiers</span> <span class="variable">jcModifiers</span> <span class="operator">=</span> treeMaker.Modifiers(Flags.PUBLIC,jcAnnotationList);</span><br><span class="line">    <span class="comment">// 返回类型</span></span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">returnType</span> <span class="operator">=</span> treeMaker.TypeIdent(TypeTag.INT);</span><br><span class="line">    <span class="comment">// 方法名称</span></span><br><span class="line">    <span class="type">Name</span> <span class="variable">methodName</span> <span class="operator">=</span> names.fromString(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    List&lt;JCTree.JCExpression&gt; throwableList = List.nil();</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">    List&lt;JCTree.JCExpression&gt; var1 = List.nil();</span><br><span class="line">    List&lt;JCTree.JCExpression&gt; var2 = List.nil();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (JCTree.JCVariableDecl jcVariableDecl : jcVariableDeclList)&#123;</span><br><span class="line">        <span class="comment">//var1 = var1.append(typeTranslator(jcVariableDecl.vartype));</span></span><br><span class="line">        var2 = var2.append(treeMaker.Ident(jcVariableDecl.name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">jcExpression</span> <span class="operator">=</span> treeMaker.Apply(var1,</span><br><span class="line">                                                       memberAccess(<span class="string">&quot;java.util.Objects.hash&quot;</span>),var2);</span><br><span class="line">    JCTree.<span class="type">JCStatement</span> <span class="variable">jcStatement</span> <span class="operator">=</span> treeMaker.Return(jcExpression);</span><br><span class="line">    List&lt;JCTree.JCStatement&gt; jcStatementList = List.nil();</span><br><span class="line">    jcStatementList = jcStatementList.append(jcStatement);</span><br><span class="line"></span><br><span class="line">    JCTree.<span class="type">JCBlock</span> <span class="variable">jcBlock</span> <span class="operator">=</span> treeMaker.Block(<span class="number">0</span>,jcStatementList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 泛型变量</span></span><br><span class="line">    List&lt;JCTree.JCTypeParameter&gt; jcTypeParameterList = List.nil();</span><br><span class="line">    <span class="comment">// 变量列表</span></span><br><span class="line">    List&lt;JCTree.JCVariableDecl&gt; variableDeclList = List.nil();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">defaultValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    JCTree.<span class="type">JCMethodDecl</span> <span class="variable">jcMethodDecl</span> <span class="operator">=</span> treeMaker.MethodDef(jcModifiers,</span><br><span class="line">                                                           methodName,</span><br><span class="line">                                                           returnType,</span><br><span class="line">                                                           jcTypeParameterList,</span><br><span class="line">                                                           variableDeclList,</span><br><span class="line">                                                           throwableList,jcBlock,defaultValue);</span><br><span class="line">    <span class="keyword">return</span> jcMethodDecl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="equal-方法生成"><a href="#equal-方法生成" class="headerlink" title="equal 方法生成"></a>equal 方法生成</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成 equal 方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classDecl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> JCTree.JCMethodDecl <span class="title function_">makeEqualsMethod</span><span class="params">(JCTree.JCClassDecl classDecl)</span>&#123;</span><br><span class="line"></span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">extend</span> <span class="operator">=</span>  classDecl.extending;</span><br><span class="line">    <span class="comment">// 提取类中定义的变量</span></span><br><span class="line">    List&lt;JCTree&gt; jcTreeList = classDecl.defs;</span><br><span class="line">    List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();</span><br><span class="line">    <span class="keyword">for</span> (JCTree jcTree : jcTreeList)&#123;</span><br><span class="line">        <span class="keyword">if</span> (jcTree <span class="keyword">instanceof</span> JCTree.JCVariableDecl)&#123;</span><br><span class="line">            JCTree.<span class="type">JCVariableDecl</span> <span class="variable">var</span> <span class="operator">=</span> (JCTree.JCVariableDecl) jcTree;</span><br><span class="line">            jcVariableDeclList = jcVariableDeclList.append(<span class="keyword">var</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法注解</span></span><br><span class="line">    JCTree.<span class="type">JCAnnotation</span> <span class="variable">jcAnnotation</span> <span class="operator">=</span> treeMaker.Annotation(memberAccess(<span class="string">&quot;java.lang.Override&quot;</span>),List.nil());</span><br><span class="line">    List&lt;JCTree.JCAnnotation&gt; jcAnnotationList = List.nil();</span><br><span class="line">    jcAnnotationList = jcAnnotationList.append(jcAnnotation);</span><br><span class="line">    <span class="comment">// 方法关键修饰</span></span><br><span class="line">    JCTree.<span class="type">JCModifiers</span> <span class="variable">jcModifiers</span> <span class="operator">=</span> treeMaker.Modifiers(Flags.PUBLIC,jcAnnotationList);</span><br><span class="line">    <span class="comment">// 返回类型</span></span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">retrunType</span> <span class="operator">=</span> treeMaker.TypeIdent(TypeTag.BOOLEAN);</span><br><span class="line">    <span class="comment">// 方法名称</span></span><br><span class="line">    <span class="type">Name</span> <span class="variable">methodName</span> <span class="operator">=</span> names.fromString(<span class="string">&quot;equals&quot;</span>);</span><br><span class="line">    <span class="comment">// 泛型参数</span></span><br><span class="line">    List&lt;JCTree.JCTypeParameter&gt; jcTypeParameters = List.nil();</span><br><span class="line">    <span class="comment">// 参数列表</span></span><br><span class="line">    List&lt;JCTree.JCVariableDecl&gt; variableDecls = List.nil();</span><br><span class="line">    JCTree.<span class="type">JCVariableDecl</span> <span class="variable">param</span> <span class="operator">=</span> treeMaker.VarDef(treeMaker.Modifiers(Flags.PARAMETER),</span><br><span class="line">            names.fromString(<span class="string">&quot;o&quot;</span>),memberAccess(<span class="string">&quot;java.lang.Object&quot;</span>),<span class="literal">null</span>);</span><br><span class="line">    param.pos = classDecl.pos;</span><br><span class="line">    variableDecls = variableDecls.append(param);</span><br><span class="line">    <span class="comment">// 异常列表</span></span><br><span class="line">    List&lt;JCTree.JCExpression&gt; throwableList = List.nil();</span><br><span class="line">    <span class="comment">// 开始构建方法体</span></span><br><span class="line">    <span class="comment">//if (this == o) return true;</span></span><br><span class="line">    List&lt;JCTree.JCStatement&gt; jcStatements = List.nil();</span><br><span class="line">    JCTree.<span class="type">JCIf</span> <span class="variable">seqzero</span> <span class="operator">=</span> treeMaker.If(treeMaker.Binary(JCTree.Tag.EQ,treeMaker.Ident(names.fromString(<span class="string">&quot;this&quot;</span>)),treeMaker.Ident(names.fromString(<span class="string">&quot;o&quot;</span>)))</span><br><span class="line">            ,treeMaker.Return(treeMaker.Literal(<span class="literal">true</span>)),<span class="literal">null</span>);</span><br><span class="line">    jcStatements = jcStatements.append(seqzero);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (o == null || getClass() != o.getClass()) return false;</span></span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">getClassEqCondition</span> <span class="operator">=</span> treeMaker.Apply(List.nil(),treeMaker.Select(treeMaker.Ident(names.fromString(<span class="string">&quot;this&quot;</span>)),names.fromString(<span class="string">&quot;getClass&quot;</span>)),List.nil());</span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">vargetClassEqCondition</span> <span class="operator">=</span> treeMaker.Apply(List.nil(),treeMaker.Select(treeMaker.Ident(names.fromString(<span class="string">&quot;o&quot;</span>)),names.fromString(<span class="string">&quot;getClass&quot;</span>)),List.nil());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    JCTree.<span class="type">JCIf</span> <span class="variable">seqone</span> <span class="operator">=</span> treeMaker.If(</span><br><span class="line">        treeMaker.Binary(JCTree.Tag.OR,</span><br><span class="line">                         treeMaker.Binary(</span><br><span class="line">                             JCTree.Tag.EQ,</span><br><span class="line">                             treeMaker.Ident(</span><br><span class="line">                                 names.fromString(<span class="string">&quot;o&quot;</span>)),</span><br><span class="line">                             treeMaker.Literal(TypeTag.BOT,<span class="literal">null</span>))</span><br><span class="line">            ,treeMaker.Binary(JCTree.Tag.NE,getClassEqCondition,vargetClassEqCondition))</span><br><span class="line">            ,treeMaker.Return(treeMaker.Literal(<span class="literal">false</span>)),<span class="literal">null</span>);</span><br><span class="line">           </span><br><span class="line">    jcStatements = jcStatements.append(seqone);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanTreeTranslator that = (BeanTreeTranslator) o;</span></span><br><span class="line">    JCTree.<span class="type">JCVariableDecl</span> <span class="variable">jcVariableDecl</span> <span class="operator">=</span> treeMaker.VarDef(</span><br><span class="line">        treeMaker.Modifiers(<span class="number">0</span>),names.fromString(</span><br><span class="line">            toLowerCaseFirstOne(classDecl.name.toString()))</span><br><span class="line">            ,treeMaker.Ident(classDecl.name)</span><br><span class="line">            ,treeMaker.TypeCast(</span><br><span class="line">                treeMaker.Ident(classDecl.name),treeMaker.Ident(names.fromString(<span class="string">&quot;o&quot;</span>))</span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line">    jcStatements = jcStatements.append(jcVariableDecl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return Objects.equals(messager, that.messager) &amp;&amp;</span></span><br><span class="line">    <span class="comment">//                Objects.equals(treeMaker, that.treeMaker) &amp;&amp;</span></span><br><span class="line">    <span class="comment">//                Objects.equals(names, that.names) &amp;&amp;</span></span><br><span class="line">    <span class="comment">//                Objects.equals(tep, that.tep);</span></span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">jcExpression</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (JCTree.JCVariableDecl <span class="keyword">var</span> : jcVariableDeclList)&#123;</span><br><span class="line">        List&lt;JCTree.JCExpression&gt; varType = List.nil();</span><br><span class="line">        List&lt;JCTree.JCExpression&gt; varList = List.nil();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//varType = varType.append(var.vartype);</span></span><br><span class="line">        varList = varList.append(treeMaker.Ident(<span class="keyword">var</span>.name));</span><br><span class="line">        varList = varList.append(</span><br><span class="line">            treeMaker.Select(</span><br><span class="line">                treeMaker.Ident(</span><br><span class="line">                    names.fromString(toLowerCaseFirstOne(classDecl.name.toString()))),<span class="keyword">var</span>.name));</span><br><span class="line">        <span class="comment">// treeMaker.Apply 调用的是 JCMethodInvocation </span></span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">expression</span> <span class="operator">=</span> treeMaker.Apply(</span><br><span class="line">            varType,memberAccess(<span class="string">&quot;java.util.Objects.equals&quot;</span>),varList);</span><br><span class="line">        <span class="keyword">if</span> (jcExpression==<span class="literal">null</span>)&#123;</span><br><span class="line">            jcExpression = expression;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            jcExpression = treeMaker.Binary(JCTree.Tag.AND,jcExpression,expression);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    JCTree.<span class="type">JCStatement</span> <span class="variable">jcStatement</span> <span class="operator">=</span> treeMaker.Return(jcExpression);</span><br><span class="line">    jcStatements = jcStatements.append(jcStatement);</span><br><span class="line">    JCTree.<span class="type">JCBlock</span> <span class="variable">jcBlock</span> <span class="operator">=</span> treeMaker.Block(<span class="number">0</span>,jcStatements);</span><br><span class="line"></span><br><span class="line">    JCTree.<span class="type">JCExpression</span> <span class="variable">defaultValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    JCTree.<span class="type">JCMethodDecl</span> <span class="variable">jcMethodDecl</span> <span class="operator">=</span> treeMaker.MethodDef(jcModifiers,methodName,</span><br><span class="line">                                                           retrunType,jcTypeParameters,</span><br><span class="line">                                                           variableDecls,throwableList,</span><br><span class="line">                                                           jcBlock,defaultValue);</span><br><span class="line">    <span class="keyword">return</span> jcMethodDecl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后整个语法树生成代码的测试样例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.code.Flags;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.code.TypeTag;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.JCTree;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.TreeMaker;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.TreeTranslator;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.List;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Name;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Names;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.Messager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTreeTranslator</span> <span class="keyword">extends</span> <span class="title class_">TreeTranslator</span> &#123;</span><br><span class="line"></span><br><span class="line">    Messager messager;</span><br><span class="line">    TreeMaker treeMaker;</span><br><span class="line">    Names names;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanTreeTranslator</span><span class="params">(TreeMaker treeMaker,Messager messager,Names names)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.treeMaker = treeMaker;</span><br><span class="line">        <span class="built_in">this</span>.messager = messager;</span><br><span class="line">        <span class="built_in">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitBlock</span><span class="params">(JCTree.JCBlock jcBlock)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.visitBlock(jcBlock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitClassDef</span><span class="params">(JCTree.JCClassDecl jcClassDecl)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.visitClassDef(jcClassDecl);</span><br><span class="line">        List&lt;JCTree&gt; jcTreeList = jcClassDecl.defs;</span><br><span class="line">        <span class="keyword">for</span> (JCTree jcTree : jcClassDecl.defs)&#123;</span><br><span class="line">            <span class="keyword">if</span> (jcTree <span class="keyword">instanceof</span> JCTree.JCVariableDecl)&#123;</span><br><span class="line">                JCTree.<span class="type">JCVariableDecl</span> <span class="variable">jcVariableDecl</span> <span class="operator">=</span> (JCTree.JCVariableDecl) jcTree;</span><br><span class="line">                jcClassDecl.defs = jcClassDecl.defs.append(makeGetterMethod(jcVariableDecl));</span><br><span class="line">                jcClassDecl.defs = jcClassDecl.defs.append(makeSetterMethod(jcVariableDecl));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// toString 方法</span></span><br><span class="line">        JCTree.<span class="type">JCMethodDecl</span> <span class="variable">toStringMethod</span> <span class="operator">=</span> makeToStringMethod(jcClassDecl);</span><br><span class="line">        jcClassDecl.defs = jcClassDecl.defs.append(toStringMethod);</span><br><span class="line">        <span class="comment">// hash 方法</span></span><br><span class="line">        JCTree.<span class="type">JCMethodDecl</span> <span class="variable">hashMethod</span> <span class="operator">=</span> makeHashMethodDecl(jcClassDecl);</span><br><span class="line">        jcClassDecl.defs = jcClassDecl.defs.append(hashMethod);</span><br><span class="line">        <span class="comment">// equal 方法</span></span><br><span class="line">        JCTree.<span class="type">JCMethodDecl</span> <span class="variable">equalMethod</span> <span class="operator">=</span> makeEqualsMethod(jcClassDecl);</span><br><span class="line">        jcClassDecl.defs = jcClassDecl.defs.append(equalMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成Getter 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jcVariableDecl</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCMethodDecl <span class="title function_">makeGetterMethod</span><span class="params">(JCTree.JCVariableDecl jcVariableDecl)</span>&#123;</span><br><span class="line">        JCTree.<span class="type">JCModifiers</span> <span class="variable">modifiers</span> <span class="operator">=</span> treeMaker.Modifiers(Flags.PUBLIC);</span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">returnType</span> <span class="operator">=</span> jcVariableDecl.vartype;</span><br><span class="line">        <span class="comment">// 方法名</span></span><br><span class="line">        <span class="type">Name</span> <span class="variable">methodName</span> <span class="operator">=</span> getGetterMethod(jcVariableDecl);</span><br><span class="line">        <span class="comment">// 构建语句</span></span><br><span class="line">        JCTree.<span class="type">JCStatement</span> <span class="variable">statement</span> <span class="operator">=</span> treeMaker.Return(</span><br><span class="line">                treeMaker.Select(</span><br><span class="line">                        treeMaker.Ident(</span><br><span class="line">                                names.fromString(<span class="string">&quot;this&quot;</span>)),jcVariableDecl.name));</span><br><span class="line"></span><br><span class="line">        List&lt;JCTree.JCStatement&gt; statementList = List.nil();</span><br><span class="line">        statementList = statementList.append(statement);</span><br><span class="line">        <span class="comment">// 构建代码块</span></span><br><span class="line">        JCTree.<span class="type">JCBlock</span> <span class="variable">jcBlock</span> <span class="operator">=</span> treeMaker.Block(<span class="number">0</span>,statementList);</span><br><span class="line">        <span class="comment">// 泛型参数列表</span></span><br><span class="line">        List&lt;JCTree.JCTypeParameter&gt; typeParameters = List.nil();</span><br><span class="line">        <span class="comment">// 参数类型</span></span><br><span class="line">        List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();</span><br><span class="line">        <span class="comment">// 异常抛出列表</span></span><br><span class="line">        List&lt;JCTree.JCExpression&gt; throwsClauses  = List.nil();</span><br><span class="line">        <span class="comment">//非自定义注解类中的方法，defaultValue为null</span></span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">defaultValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        JCTree.<span class="type">JCMethodDecl</span> <span class="variable">jcMethodDecl</span> <span class="operator">=</span> treeMaker.MethodDef(modifiers,</span><br><span class="line">                                                               methodName,returnType,typeParameters,</span><br><span class="line">                jcVariableDeclList,throwsClauses,jcBlock,defaultValue);</span><br><span class="line">        <span class="keyword">return</span> jcMethodDecl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成 Setter 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jcVariableDecl</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCMethodDecl <span class="title function_">makeSetterMethod</span><span class="params">(JCTree.JCVariableDecl jcVariableDecl)</span>&#123;</span><br><span class="line">        JCTree.<span class="type">JCModifiers</span> <span class="variable">modifiers</span> <span class="operator">=</span> treeMaker.Modifiers(Flags.PUBLIC);</span><br><span class="line">        <span class="comment">// 返回类型</span></span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">returnType</span> <span class="operator">=</span> treeMaker.TypeIdent(TypeTag.VOID);</span><br><span class="line">        <span class="comment">// 方法名称</span></span><br><span class="line">        <span class="type">Name</span> <span class="variable">methodName</span> <span class="operator">=</span> getSetterMethod(jcVariableDecl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数</span></span><br><span class="line">        List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();</span><br><span class="line">        JCTree.<span class="type">JCVariableDecl</span> <span class="variable">param</span> <span class="operator">=</span> treeMaker.VarDef(treeMaker.Modifiers(Flags.PARAMETER),</span><br><span class="line">                                                       jcVariableDecl.name,</span><br><span class="line">                                                       jcVariableDecl.vartype,<span class="literal">null</span>);</span><br><span class="line">        param.pos = jcVariableDecl.pos; <span class="comment">//设置形参这一句不能少，不然会编译报错(java.lang.AssertionError: Value of x -1)</span></span><br><span class="line">        jcVariableDeclList = jcVariableDeclList.append(param);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建语句  //this.xxx = xxx;  setter方法中的赋值语句</span></span><br><span class="line">        JCTree.<span class="type">JCStatement</span> <span class="variable">statement</span> <span class="operator">=</span> treeMaker.Exec(</span><br><span class="line">                treeMaker.Assign(</span><br><span class="line">                        treeMaker.Select(treeMaker.Ident(</span><br><span class="line">                            names.fromString(<span class="string">&quot;this&quot;</span>)),jcVariableDecl.name),</span><br><span class="line">                        treeMaker.Ident(param.name)));</span><br><span class="line">        List&lt;JCTree.JCStatement&gt; statementList = List.nil();</span><br><span class="line">        statementList = statementList.append(statement);</span><br><span class="line"></span><br><span class="line">        JCTree.<span class="type">JCBlock</span> <span class="variable">jcBlock</span> <span class="operator">=</span> treeMaker.Block(<span class="number">0</span>,statementList);</span><br><span class="line">        <span class="comment">// 泛型参数</span></span><br><span class="line">        List&lt;JCTree.JCTypeParameter&gt; typeParameters = List.nil();</span><br><span class="line">        <span class="comment">// 异常抛出列表</span></span><br><span class="line">        List&lt;JCTree.JCExpression&gt; throwsClauses = List.nil();</span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">defaultValue</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//非自定义注解类中的方法，defaultValue为null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建settter 方法</span></span><br><span class="line">        JCTree.<span class="type">JCMethodDecl</span> <span class="variable">jcMethodDecl</span> <span class="operator">=</span> treeMaker.MethodDef(modifiers,methodName,returnType,</span><br><span class="line">                typeParameters,jcVariableDeclList,throwsClauses,jcBlock,defaultValue);</span><br><span class="line">        <span class="keyword">return</span> jcMethodDecl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成 toString 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jcClassDecl</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCMethodDecl <span class="title function_">makeToStringMethod</span><span class="params">(JCTree.JCClassDecl jcClassDecl)</span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;JCTree.JCVariableDecl&gt; vars = List.nil();</span><br><span class="line">        List&lt;JCTree&gt; jcTreeList = jcClassDecl.defs;</span><br><span class="line">        <span class="keyword">for</span> (JCTree jcTree: jcTreeList)&#123;</span><br><span class="line">            <span class="keyword">if</span> (jcTree <span class="keyword">instanceof</span> JCTree.JCVariableDecl)&#123;</span><br><span class="line">                JCTree.<span class="type">JCVariableDecl</span> <span class="variable">var</span> <span class="operator">=</span> (JCTree.JCVariableDecl) jcTree;</span><br><span class="line">                vars = vars.append(<span class="keyword">var</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;JCTree.JCAnnotation&gt; jcAnnotationList = List.nil();</span><br><span class="line">        <span class="comment">// 方法注解</span></span><br><span class="line">        JCTree.<span class="type">JCAnnotation</span> <span class="variable">jcAnnotation</span> <span class="operator">=</span> treeMaker.Annotation(</span><br><span class="line">            memberAccess(<span class="string">&quot;java.lang.Override&quot;</span>),List.nil());</span><br><span class="line">        jcAnnotationList = jcAnnotationList.append(jcAnnotation);</span><br><span class="line">        JCTree.<span class="type">JCModifiers</span> <span class="variable">jcModifiers</span> <span class="operator">=</span> treeMaker.Modifiers(Flags.PUBLIC,jcAnnotationList); <span class="comment">// 方法修饰词</span></span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">returnType</span> <span class="operator">=</span> memberAccess(<span class="string">&quot;java.lang.String&quot;</span>); <span class="comment">// 返回类型</span></span><br><span class="line">        <span class="type">Name</span> <span class="variable">name</span> <span class="operator">=</span> names.fromString(<span class="string">&quot;toString&quot;</span>); <span class="comment">// 方法名</span></span><br><span class="line"></span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">jcExpression</span> <span class="operator">=</span> treeMaker.Literal(jcClassDecl.name + <span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;vars.size(); i++)&#123;</span><br><span class="line">            JCTree.<span class="type">JCVariableDecl</span> <span class="variable">var</span> <span class="operator">=</span> vars.get(i);</span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">0</span>)&#123;</span><br><span class="line">                jcExpression = treeMaker.Binary(</span><br><span class="line">                    JCTree.Tag.PLUS,jcExpression,treeMaker.Literal(<span class="string">&quot;,&quot;</span> + <span class="keyword">var</span>.name.toString()+<span class="string">&quot;=&quot;</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                jcExpression = treeMaker.Binary(</span><br><span class="line">                    JCTree.Tag.PLUS,jcExpression,treeMaker.Literal(<span class="keyword">var</span>.name.toString()+<span class="string">&quot;=&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">var</span>.vartype.toString().contains(<span class="string">&quot;String&quot;</span>))&#123;</span><br><span class="line">                jcExpression = treeMaker.Binary(JCTree.Tag.PLUS,jcExpression,treeMaker.Literal(<span class="string">&quot;&#x27;&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            jcExpression = treeMaker.Binary(JCTree.Tag.PLUS,jcExpression,treeMaker.Ident(<span class="keyword">var</span>.name));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">var</span>.vartype.toString().contains(<span class="string">&quot;String&quot;</span>))&#123;</span><br><span class="line">                jcExpression = treeMaker.Binary(JCTree.Tag.PLUS,jcExpression,treeMaker.Literal(<span class="string">&quot;&#x27;&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jcExpression = treeMaker.Binary(JCTree.Tag.PLUS,jcExpression,treeMaker.Literal(<span class="string">&quot;&#125;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        JCTree.<span class="type">JCStatement</span> <span class="variable">jcStatement</span> <span class="operator">=</span> treeMaker.Return(jcExpression);</span><br><span class="line">        List&lt;JCTree.JCStatement&gt; statementList = List.nil();</span><br><span class="line">        statementList = statementList.append(jcStatement);</span><br><span class="line">        JCTree.<span class="type">JCBlock</span> <span class="variable">jcBlock</span> <span class="operator">=</span> treeMaker.Block(<span class="number">0</span>,statementList);</span><br><span class="line">        <span class="comment">// 参数列表</span></span><br><span class="line">        List&lt;JCTree.JCVariableDecl&gt; variableDecls = List.nil();</span><br><span class="line">        <span class="comment">// 形参列表</span></span><br><span class="line">        List&lt;JCTree.JCTypeParameter&gt; jcTypeParameters = List.nil();</span><br><span class="line">        <span class="comment">// 异常列表</span></span><br><span class="line">        List&lt;JCTree.JCExpression&gt; throwableList = List.nil();</span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">defaultValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        JCTree.<span class="type">JCMethodDecl</span> <span class="variable">jcMethodDecl</span> <span class="operator">=</span> treeMaker.MethodDef(jcModifiers,</span><br><span class="line">                                                               name,returnType,</span><br><span class="line">                                                               jcTypeParameters,</span><br><span class="line">                                                               variableDecls,</span><br><span class="line">                                                               throwableList,jcBlock,defaultValue);</span><br><span class="line">        <span class="keyword">return</span> jcMethodDecl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成 hash 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classDecl</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCMethodDecl <span class="title function_">makeHashMethodDecl</span><span class="params">(JCTree.JCClassDecl classDecl)</span>&#123;</span><br><span class="line">        List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();</span><br><span class="line">        List&lt;JCTree&gt; jcTreeList = classDecl.defs;</span><br><span class="line">        <span class="keyword">for</span> (JCTree jcTree : jcTreeList)&#123;</span><br><span class="line">            <span class="keyword">if</span> (jcTree <span class="keyword">instanceof</span> JCTree.JCVariableDecl)&#123;</span><br><span class="line">                JCTree.<span class="type">JCVariableDecl</span> <span class="variable">jcVariableDecl</span> <span class="operator">=</span> (JCTree.JCVariableDecl) jcTree;</span><br><span class="line">                jcVariableDeclList = jcVariableDeclList.append(jcVariableDecl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Override 方法注解</span></span><br><span class="line">        JCTree.<span class="type">JCAnnotation</span> <span class="variable">jcAnnotation</span> <span class="operator">=</span> treeMaker.Annotation(</span><br><span class="line">            memberAccess(<span class="string">&quot;java.lang.Override&quot;</span>),List.nil());</span><br><span class="line">        List&lt;JCTree.JCAnnotation&gt; jcAnnotationList = List.nil();</span><br><span class="line">        jcAnnotationList = jcAnnotationList.append(jcAnnotation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修饰方法关键字</span></span><br><span class="line">        JCTree.<span class="type">JCModifiers</span> <span class="variable">jcModifiers</span> <span class="operator">=</span> treeMaker.Modifiers(Flags.PUBLIC,jcAnnotationList);</span><br><span class="line">        <span class="comment">// 返回类型</span></span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">returnType</span> <span class="operator">=</span> treeMaker.TypeIdent(TypeTag.INT);</span><br><span class="line">        <span class="comment">// 方法名称</span></span><br><span class="line">        <span class="type">Name</span> <span class="variable">methodName</span> <span class="operator">=</span> names.fromString(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        List&lt;JCTree.JCExpression&gt; throwableList = List.nil();</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">        List&lt;JCTree.JCExpression&gt; var1 = List.nil();</span><br><span class="line">        List&lt;JCTree.JCExpression&gt; var2 = List.nil();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (JCTree.JCVariableDecl jcVariableDecl : jcVariableDeclList)&#123;</span><br><span class="line">            <span class="comment">//var1 = var1.append(typeTranslator(jcVariableDecl.vartype));</span></span><br><span class="line">            var2 = var2.append(treeMaker.Ident(jcVariableDecl.name));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">jcExpression</span> <span class="operator">=</span> treeMaker.Apply(var1,</span><br><span class="line">                                                           memberAccess(<span class="string">&quot;java.util.Objects.hash&quot;</span>),</span><br><span class="line">                                                           var2);</span><br><span class="line">        JCTree.<span class="type">JCStatement</span> <span class="variable">jcStatement</span> <span class="operator">=</span> treeMaker.Return(jcExpression);</span><br><span class="line">        List&lt;JCTree.JCStatement&gt; jcStatementList = List.nil();</span><br><span class="line">        jcStatementList = jcStatementList.append(jcStatement);</span><br><span class="line"></span><br><span class="line">        JCTree.<span class="type">JCBlock</span> <span class="variable">jcBlock</span> <span class="operator">=</span> treeMaker.Block(<span class="number">0</span>,jcStatementList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 泛型变量</span></span><br><span class="line">        List&lt;JCTree.JCTypeParameter&gt; jcTypeParameterList = List.nil();</span><br><span class="line">        <span class="comment">// 变量列表</span></span><br><span class="line">        List&lt;JCTree.JCVariableDecl&gt; variableDeclList = List.nil();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">defaultValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        JCTree.<span class="type">JCMethodDecl</span> <span class="variable">jcMethodDecl</span> <span class="operator">=</span> treeMaker.MethodDef(jcModifiers,</span><br><span class="line">                                                               methodName,</span><br><span class="line">                                                               returnType,jcTypeParameterList,</span><br><span class="line">                variableDeclList,throwableList,jcBlock,defaultValue);</span><br><span class="line">        <span class="keyword">return</span> jcMethodDecl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成 equal 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classDecl</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCMethodDecl <span class="title function_">makeEqualsMethod</span><span class="params">(JCTree.JCClassDecl classDecl)</span>&#123;</span><br><span class="line"></span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">extend</span> <span class="operator">=</span>  classDecl.extending;</span><br><span class="line">        <span class="comment">// 提取类中定义的变量</span></span><br><span class="line">        List&lt;JCTree&gt; jcTreeList = classDecl.defs;</span><br><span class="line">        List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();</span><br><span class="line">        <span class="keyword">for</span> (JCTree jcTree : jcTreeList)&#123;</span><br><span class="line">            <span class="keyword">if</span> (jcTree <span class="keyword">instanceof</span> JCTree.JCVariableDecl)&#123;</span><br><span class="line">                JCTree.<span class="type">JCVariableDecl</span> <span class="variable">var</span> <span class="operator">=</span> (JCTree.JCVariableDecl) jcTree;</span><br><span class="line">                jcVariableDeclList = jcVariableDeclList.append(<span class="keyword">var</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 方法注解</span></span><br><span class="line">        JCTree.<span class="type">JCAnnotation</span> <span class="variable">jcAnnotation</span> <span class="operator">=</span> treeMaker.Annotation(</span><br><span class="line">            memberAccess(<span class="string">&quot;java.lang.Override&quot;</span>),List.nil());</span><br><span class="line">        List&lt;JCTree.JCAnnotation&gt; jcAnnotationList = List.nil();</span><br><span class="line">        jcAnnotationList = jcAnnotationList.append(jcAnnotation);</span><br><span class="line">        <span class="comment">// 方法关键修饰</span></span><br><span class="line">        JCTree.<span class="type">JCModifiers</span> <span class="variable">jcModifiers</span> <span class="operator">=</span> treeMaker.Modifiers(Flags.PUBLIC,jcAnnotationList);</span><br><span class="line">        <span class="comment">// 返回类型</span></span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">retrunType</span> <span class="operator">=</span> treeMaker.TypeIdent(TypeTag.BOOLEAN);</span><br><span class="line">        <span class="comment">// 方法名称</span></span><br><span class="line">        <span class="type">Name</span> <span class="variable">methodName</span> <span class="operator">=</span> names.fromString(<span class="string">&quot;equals&quot;</span>);</span><br><span class="line">        <span class="comment">// 泛型参数</span></span><br><span class="line">        List&lt;JCTree.JCTypeParameter&gt; jcTypeParameters = List.nil();</span><br><span class="line">        <span class="comment">// 参数列表</span></span><br><span class="line">        List&lt;JCTree.JCVariableDecl&gt; variableDecls = List.nil();</span><br><span class="line">        JCTree.<span class="type">JCVariableDecl</span> <span class="variable">param</span> <span class="operator">=</span> treeMaker.VarDef(treeMaker.Modifiers(Flags.PARAMETER),</span><br><span class="line">                names.fromString(<span class="string">&quot;o&quot;</span>),memberAccess(<span class="string">&quot;java.lang.Object&quot;</span>),<span class="literal">null</span>);</span><br><span class="line">        param.pos = classDecl.pos;</span><br><span class="line">        variableDecls = variableDecls.append(param);</span><br><span class="line">        <span class="comment">// 异常列表</span></span><br><span class="line">        List&lt;JCTree.JCExpression&gt; throwableList = List.nil();</span><br><span class="line">        <span class="comment">// 开始构建方法体</span></span><br><span class="line">        <span class="comment">//if (this == o) return true;</span></span><br><span class="line">        List&lt;JCTree.JCStatement&gt; jcStatements = List.nil();</span><br><span class="line">        JCTree.<span class="type">JCIf</span> <span class="variable">seqzero</span> <span class="operator">=</span> treeMaker.If(treeMaker.Binary(</span><br><span class="line">            JCTree.Tag.EQ,</span><br><span class="line">            treeMaker.Ident(names.fromString(<span class="string">&quot;this&quot;</span>)),</span><br><span class="line">            treeMaker.Ident(names.fromString(<span class="string">&quot;o&quot;</span>)))</span><br><span class="line">                ,treeMaker.Return(treeMaker.Literal(<span class="literal">true</span>)),<span class="literal">null</span>);</span><br><span class="line">        jcStatements = jcStatements.append(seqzero);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if (o == null || getClass() != o.getClass()) return false;</span></span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">getClassEqCondition</span> <span class="operator">=</span> treeMaker.Apply(List.nil(),</span><br><span class="line">                                                                  treeMaker.Select(</span><br><span class="line">                                                                      treeMaker.Ident</span><br><span class="line">                                                                      (names.fromString(<span class="string">&quot;this&quot;</span>)),</span><br><span class="line">                                                                      names.fromString(<span class="string">&quot;getClass&quot;</span>)),</span><br><span class="line">                                                                  List.nil());</span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">vargetClassEqCondition</span> <span class="operator">=</span> treeMaker.Apply(List.nil(),</span><br><span class="line">                                                                     treeMaker.Select(</span><br><span class="line">                                                                         treeMaker.Ident(</span><br><span class="line">                                                                             names.fromString(<span class="string">&quot;o&quot;</span>)),</span><br><span class="line">                                                                         names.fromString(<span class="string">&quot;getClass&quot;</span>)),</span><br><span class="line">                                                                     List.nil());</span><br><span class="line"></span><br><span class="line">        JCTree.<span class="type">JCIf</span> <span class="variable">seqone</span> <span class="operator">=</span> treeMaker.If(treeMaker.Binary(JCTree.Tag.OR</span><br><span class="line">                ,treeMaker.Binary(JCTree.Tag.EQ,</span><br><span class="line">                                  treeMaker.Ident(</span><br><span class="line">                                      names.fromString(<span class="string">&quot;o&quot;</span>)),treeMaker.Literal(TypeTag.BOT,<span class="literal">null</span>))</span><br><span class="line">                ,treeMaker.Binary(JCTree.Tag.NE,getClassEqCondition,vargetClassEqCondition))</span><br><span class="line">                ,treeMaker.Return(treeMaker.Literal(<span class="literal">false</span>)),<span class="literal">null</span>);</span><br><span class="line">               </span><br><span class="line">        jcStatements = jcStatements.append(seqone);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// BeanTreeTranslator that = (BeanTreeTranslator) o;</span></span><br><span class="line">        JCTree.<span class="type">JCVariableDecl</span> <span class="variable">jcVariableDecl</span> <span class="operator">=</span> treeMaker.VarDef(treeMaker.Modifiers(<span class="number">0</span>),</span><br><span class="line">                                                                names.fromString(</span><br><span class="line">                                                                    toLowerCaseFirstOne(</span><br><span class="line">                                                                        classDecl.name.toString()))</span><br><span class="line">                ,treeMaker.Ident(classDecl.name)</span><br><span class="line">                ,treeMaker.TypeCast(treeMaker.Ident(classDecl.name),</span><br><span class="line">                                    treeMaker.Ident(names.fromString(<span class="string">&quot;o&quot;</span>))) );</span><br><span class="line">        jcStatements = jcStatements.append(jcVariableDecl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return Objects.equals(messager, that.messager) &amp;&amp;</span></span><br><span class="line">        <span class="comment">//                Objects.equals(treeMaker, that.treeMaker) &amp;&amp;</span></span><br><span class="line">        <span class="comment">//                Objects.equals(names, that.names) &amp;&amp;</span></span><br><span class="line">        <span class="comment">//                Objects.equals(tep, that.tep);</span></span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">jcExpression</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (JCTree.JCVariableDecl <span class="keyword">var</span> : jcVariableDeclList)&#123;</span><br><span class="line">            List&lt;JCTree.JCExpression&gt; varType = List.nil();</span><br><span class="line">            List&lt;JCTree.JCExpression&gt; varList = List.nil();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//varType = varType.append(var.vartype);</span></span><br><span class="line">            varList = varList.append(treeMaker.Ident(<span class="keyword">var</span>.name));</span><br><span class="line">            varList = varList.append(treeMaker.Select(</span><br><span class="line">                treeMaker.Ident(names.fromString(</span><br><span class="line">                    toLowerCaseFirstOne(classDecl.name.toString()))),<span class="keyword">var</span>.name));</span><br><span class="line">            JCTree.<span class="type">JCExpression</span> <span class="variable">expression</span> <span class="operator">=</span> treeMaker.Apply(varType,</span><br><span class="line">                                                             memberAccess(<span class="string">&quot;java.util.Objects.equals&quot;</span>),</span><br><span class="line">                                                             varList);</span><br><span class="line">            <span class="keyword">if</span> (jcExpression==<span class="literal">null</span>)&#123;</span><br><span class="line">                jcExpression = expression;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                jcExpression = treeMaker.Binary(JCTree.Tag.AND,jcExpression,expression);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        JCTree.<span class="type">JCStatement</span> <span class="variable">jcStatement</span> <span class="operator">=</span> treeMaker.Return(jcExpression);</span><br><span class="line">        jcStatements = jcStatements.append(jcStatement);</span><br><span class="line">        JCTree.<span class="type">JCBlock</span> <span class="variable">jcBlock</span> <span class="operator">=</span> treeMaker.Block(<span class="number">0</span>,jcStatements);</span><br><span class="line"></span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">defaultValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        JCTree.<span class="type">JCMethodDecl</span> <span class="variable">jcMethodDecl</span> <span class="operator">=</span> treeMaker.MethodDef(jcModifiers,methodName,</span><br><span class="line">                                                               retrunType,</span><br><span class="line">                                                               jcTypeParameters,</span><br><span class="line">                                                               variableDecls,</span><br><span class="line">                                                               throwableList,jcBlock,defaultValue);</span><br><span class="line">        <span class="keyword">return</span> jcMethodDecl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入一个类的全路径名，获取对应类的JCIdent</span></span><br><span class="line">    <span class="keyword">private</span> JCTree.JCExpression <span class="title function_">memberAccess</span><span class="params">(String components)</span> &#123;</span><br><span class="line">        String[] componentArray = components.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        JCTree.<span class="type">JCExpression</span> <span class="variable">expr</span> <span class="operator">=</span> treeMaker.Ident(names.fromString(componentArray[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; componentArray.length; i++) &#123;</span><br><span class="line">            expr = treeMaker.Select(expr, names.fromString(componentArray[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> expr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//装箱</span></span><br><span class="line">    <span class="keyword">private</span> JCTree.JCExpression <span class="title function_">typeTranslator</span><span class="params">(JCTree.JCExpression type)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.toString().equals(<span class="string">&quot;int&quot;</span>))&#123;</span><br><span class="line">            type = memberAccess(<span class="string">&quot;java.lang.Integer&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type.toString().equals(<span class="string">&quot;long&quot;</span>))&#123;</span><br><span class="line">            type = memberAccess(<span class="string">&quot;java.lang.Long&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.toString().equals(<span class="string">&quot;short&quot;</span>))&#123;</span><br><span class="line">            type = memberAccess(<span class="string">&quot;java.lang.Short&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.toString().equals(<span class="string">&quot;double&quot;</span>))&#123;</span><br><span class="line">            type = memberAccess(<span class="string">&quot;java.lang.Double&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.toString().equals(<span class="string">&quot;boolean&quot;</span>))&#123;</span><br><span class="line">            type = memberAccess(<span class="string">&quot;java.lang.Boolean&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.toString().equals(<span class="string">&quot;float&quot;</span>))&#123;</span><br><span class="line">            type = memberAccess(<span class="string">&quot;java.lang.Float&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.toString().equals(<span class="string">&quot;char&quot;</span>))&#123;</span><br><span class="line">            type = memberAccess(<span class="string">&quot;java.lang.Character&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.toString().equals(<span class="string">&quot;byte&quot;</span>))&#123;</span><br><span class="line">            type = memberAccess(<span class="string">&quot;java.lang.Byte&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首字母转小写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toLowerCaseFirstOne</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Character.isLowerCase(s.charAt(<span class="number">0</span>)))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">StringBuilder</span>()).append(Character.toLowerCase(s.charAt(<span class="number">0</span>)))</span><br><span class="line">            .append(s.substring(<span class="number">1</span>)).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据变量名称生成 getXxx 方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jcVariableDecl</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Name <span class="title function_">getGetterMethod</span><span class="params">(JCTree.JCVariableDecl jcVariableDecl)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">varName</span> <span class="operator">=</span> jcVariableDecl.name.toString();</span><br><span class="line">        <span class="type">Name</span> <span class="variable">methodName</span> <span class="operator">=</span> names.fromString(<span class="string">&quot;get&quot;</span>+varName.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase()+</span><br><span class="line">                                           varName.substring(<span class="number">1</span>,varName.length()));</span><br><span class="line">        <span class="keyword">return</span> methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据变量名称生成 setXxx 方法名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jcVariableDecl</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Name <span class="title function_">getSetterMethod</span><span class="params">(JCTree.JCVariableDecl jcVariableDecl)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">varName</span> <span class="operator">=</span> jcVariableDecl.name.toString();</span><br><span class="line">        <span class="type">Name</span> <span class="variable">methodName</span> <span class="operator">=</span> names.fromString(<span class="string">&quot;set&quot;</span>+varName.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase()+</span><br><span class="line">                                           varName.substring(<span class="number">1</span>,varName.length()));</span><br><span class="line">        <span class="keyword">return</span> methodName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的编译生成的字节码结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoC</span> &#123;</span><br><span class="line">    String var1;</span><br><span class="line">    String var2;</span><br><span class="line">    Integer tempInt;</span><br><span class="line">    Double tempDouble;</span><br><span class="line">    DemoA demoA;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoC</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getVar1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar1</span><span class="params">(String var1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.var1 = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getVar2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.var2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar2</span><span class="params">(String var2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.var2 = var2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getTempInt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.tempInt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTempInt</span><span class="params">(Integer tempInt)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tempInt = tempInt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getTempDouble</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.tempDouble;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTempDouble</span><span class="params">(Double tempDouble)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tempDouble = tempDouble;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DemoA <span class="title function_">getDemoA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.demoA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDemoA</span><span class="params">(DemoA demoA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.demoA = demoA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTemp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTemp</span><span class="params">(<span class="type">int</span> temp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temp = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DemoC&#123;var1=&#x27;&quot;</span> + <span class="built_in">this</span>.var1 + <span class="string">&quot;&#x27;&quot;</span> + <span class="string">&quot;,var2=&quot;</span> + <span class="string">&quot;&#x27;&quot;</span> + <span class="built_in">this</span>.var2 + <span class="string">&quot;&#x27;&quot;</span> + <span class="string">&quot;,tempInt=&quot;</span> + <span class="built_in">this</span>.tempInt + <span class="string">&quot;,tempDouble=&quot;</span> + <span class="built_in">this</span>.tempDouble + <span class="string">&quot;,demoA=&quot;</span> + <span class="built_in">this</span>.demoA + <span class="string">&quot;,temp=&quot;</span> + <span class="built_in">this</span>.temp + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="built_in">this</span>.var1, <span class="built_in">this</span>.var2, <span class="built_in">this</span>.tempInt, <span class="built_in">this</span>.tempDouble, <span class="built_in">this</span>.demoA, <span class="built_in">this</span>.temp&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.getClass() == o.getClass()) &#123;</span><br><span class="line">            <span class="type">DemoC</span> <span class="variable">demoC</span> <span class="operator">=</span> (DemoC)o;</span><br><span class="line">            <span class="keyword">return</span> Objects.equals(<span class="built_in">this</span>.var1, demoC.var1) &amp;&amp; Objects.equals(<span class="built_in">this</span>.var2, demoC.var2) &amp;&amp; Objects.equals(<span class="built_in">this</span>.tempInt, demoC.tempInt) &amp;&amp; Objects.equals(<span class="built_in">this</span>.tempDouble, demoC.tempDouble) &amp;&amp; Objects.equals(<span class="built_in">this</span>.demoA, demoC.demoA) &amp;&amp; Objects.equals(<span class="built_in">this</span>.temp, demoC.temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一篇文章&lt;a href=&quot;2021/05/19/java-ast&quot;&gt;java抽象语法树（AST）&lt;/a&gt;中已经介绍了部分定义语法树的的节点，接下来在这篇将会通过样例代码以及注释介绍如何使用语法树节点来生成setter、getter、toString、hash、equal 等方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://cxinxian.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java抽象语法树（AST）</title>
    <link href="http://cxinxian.github.io/2021/05/19/java-ast/"/>
    <id>http://cxinxian.github.io/2021/05/19/java-ast/</id>
    <published>2021-05-19T08:31:45.000Z</published>
    <updated>2021-06-05T00:47:55.454Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章<a href="2021/01/28/java-processor">java自定义编译时注解器</a>中讲述到了有关自定义注解器的使用，接来在这里将会讲述的是如何通过语法树表示所想要的代码结构，并通过编译处理器生成相应的字节码。</p><span id="more"></span><h3 id="Java-编译处理流程"><a href="#Java-编译处理流程" class="headerlink" title="Java 编译处理流程"></a>Java 编译处理流程</h3><ol><li>源文件在指定的命令行下被读取，解析为语法树。对应外部可见的定义会被记录到编译器的符号表中（符合表如：LineNumberTable 记录行号、LocalVariableTable 记录变量定义、Exception table 记录异常定义 、StackMapTable ）</li><li>注解处理器编译处理注解。</li><li>语法分析器根据已解析创建的语法树分析并生成字节码，在语法树分析期间，当前所引用到的其他类也将会的的解析。</li></ol><h3 id="一、抽象语法树（Abstract-Syntax-Tree）"><a href="#一、抽象语法树（Abstract-Syntax-Tree）" class="headerlink" title="一、抽象语法树（Abstract Syntax Tree）"></a>一、抽象语法树（Abstract Syntax Tree）</h3><p>在计算机科学中，<strong>抽象语法树</strong>（<strong>A</strong>bstract <strong>S</strong>yntax <strong>T</strong>ree，AST），或简称<strong>语法树</strong>（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p><p>抽象语法树由JCTree 内部类（如：JCCompilationUnit、JCImport、JCClassDecl、JCMethodDecl、JCVariableDecl 等等）作为语法节点构成。语法树的节点可以是 包名、修饰符、类、接口、异常、方法、变量、返回值等。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">var</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的语法树如下图：</p><p><img src="/assets/blogImg/java-ast/java-ast-pic1.png" alt="图1"></p><p>JCTree 类中提供了 <code>accept()</code> 方法来范围语法树中的所有语法节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract void accept(JCTree.Visitor var1);</span><br></pre></td></tr></table></figure><p><code>accept</code> 方法接收一个JCTree的内部类 <code>Visitor</code> 作为参数，Visitor 提供了一系列访问语法树各个语法节点的方法。在获取到响应的语法节点后，我们可以对语法节点进行增删改操作。</p><p><code>Visitor</code> 的子类有 TreeScanner(可以扫描语法树的所有节点) 和 TreeTranslator（扫描语法树所有节点并且可以将节点进行转换）</p><h5 id="JCCompilationUnit"><a href="#JCCompilationUnit" class="headerlink" title="JCCompilationUnit"></a>JCCompilationUnit</h5><p>​Everything in one source file is kept in a TopLevel structure. 在语法树中作为每一个原文件的顶级结构，包含有 JCPackageDecl、JCImport、JCClassDecl 等信息。</p><h5 id="JCClassDecl-类定义"><a href="#JCClassDecl-类定义" class="headerlink" title="JCClassDecl 类定义"></a>JCClassDecl 类定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCClassDecl</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCStatement <span class="keyword">implements</span> <span class="title class_">ClassTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCModifiers mods;<span class="comment">// 类访问修饰符，如 public、private、final</span></span><br><span class="line">    <span class="keyword">public</span> Name name;<span class="comment">// 类名称</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;JCTree.JCTypeParameter&gt; typarams;<span class="comment">// 泛型参数列表</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression extending;<span class="comment">// 继承的父类</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;JCTree.JCExpression&gt; implementing;<span class="comment">// 实现的接口列表</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;JCTree&gt; defs;<span class="comment">// 成员变量、方法</span></span><br><span class="line">    <span class="keyword">public</span> ClassSymbol sym;<span class="comment">// 包名+类名</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JCMethodDecl-方法定义"><a href="#JCMethodDecl-方法定义" class="headerlink" title="JCMethodDecl 方法定义"></a>JCMethodDecl 方法定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCMethodDecl</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span> <span class="keyword">implements</span> <span class="title class_">MethodTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCModifiers mods;<span class="comment">// 方法访问修饰符 public、private、static、final</span></span><br><span class="line">    <span class="keyword">public</span> Name name;<span class="comment">// 方法名称</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression restype;<span class="comment">// 返回类型</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;JCTree.JCTypeParameter&gt; typarams;<span class="comment">// 泛型参数列表</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCVariableDecl recvparam;<span class="comment">// </span></span><br><span class="line">    <span class="keyword">public</span> List&lt;JCTree.JCVariableDecl&gt; params;<span class="comment">// 方法接收的参数列表</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;JCTree.JCExpression&gt; thrown;<span class="comment">// 方法异常 列表</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCBlock body;<span class="comment">// 方法他</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression defaultValue;<span class="comment">//注解类的方法需要的defaultValue</span></span><br><span class="line">    <span class="keyword">public</span> MethodSymbol sym;<span class="comment">// //方法名+ （参数类型），如：setName(java.lang.String)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JCModifiers-访问修饰定义"><a href="#JCModifiers-访问修饰定义" class="headerlink" title="JCModifiers 访问修饰定义"></a>JCModifiers 访问修饰定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCModifiers</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span> <span class="keyword">implements</span> <span class="title class_">ModifiersTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> flags; <span class="comment">// 访问修饰标记 public、private、static、final</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;JCTree.JCAnnotation&gt; annotations;<span class="comment">//注解列表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Flags</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PUBLIC</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRIVATE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROTECTED</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STATIC</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FINAL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SYNCHRONIZED</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VOLATILE</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSIENT</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NATIVE</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例子 如要表示 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>;</span><br><span class="line">treeMaker.Modifiers(Flags.PUBLIC + Flags.STATIC + Flags.FINAL);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="JCVariableDecl-变量的定义"><a href="#JCVariableDecl-变量的定义" class="headerlink" title="JCVariableDecl 变量的定义"></a>JCVariableDecl 变量的定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCVariableDecl</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCStatement <span class="keyword">implements</span> <span class="title class_">VariableTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCModifiers mods;<span class="comment">// 方法访问修饰符</span></span><br><span class="line">    <span class="keyword">public</span> Name name;<span class="comment">// 变量名称</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression nameexpr;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression vartype;<span class="comment">// 变量类型</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression init;<span class="comment">// 变量初始化值</span></span><br><span class="line">    <span class="keyword">public</span> VarSymbol sym;<span class="comment">// 变量名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="comment">// 定义变量 :</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">treeMaker.VarDef(</span><br><span class="line">    treeMaker.Modifiers(Flags.PUBLIC + Flags.STATIC + Flags.FINAL),</span><br><span class="line">    names.from(<span class="string">&quot;i&quot;</span>),</span><br><span class="line">    treeMaker.TypeIdent(TypeTag.INT),</span><br><span class="line">    treeMaker.Literal(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="JCIdent-标识符表达式，可以表示类、变量引用或者方法。"><a href="#JCIdent-标识符表达式，可以表示类、变量引用或者方法。" class="headerlink" title="JCIdent  标识符表达式，可以表示类、变量引用或者方法。"></a>JCIdent  标识符表达式，可以表示类、变量引用或者方法。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCIdent</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCExpression <span class="keyword">implements</span> <span class="title class_">IdentifierTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Name name;  <span class="comment">//标识符的名字</span></span><br><span class="line">    <span class="keyword">public</span> Symbol sym; <span class="comment">//代表类时为包名+类名，代表其他类型数据时为null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 样例 获取变量 x</span></span><br><span class="line">treeMaker.Ident(names.fromString(<span class="string">&quot;x&quot;</span>))))</span><br></pre></td></tr></table></figure><h5 id="JCIf-if语句定义"><a href="#JCIf-if语句定义" class="headerlink" title="JCIf   if语句定义"></a>JCIf   if语句定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCIf</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCStatement <span class="keyword">implements</span> <span class="title class_">IfTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression cond;  <span class="comment">// 条件判断语句 </span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCStatement thenpart; <span class="comment">// if </span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCStatement elsepart; <span class="comment">// else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JCAssign-赋值语句"><a href="#JCAssign-赋值语句" class="headerlink" title="JCAssign  赋值语句"></a>JCAssign  赋值语句</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCAssign</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCExpression <span class="keyword">implements</span> <span class="title class_">AssignmentTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression lhs;  <span class="comment">// 赋值语句左边表达式</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression rhs;  <span class="comment">// 赋值语句右边表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JCAssignOp"><a href="#JCAssignOp" class="headerlink" title="JCAssignOp"></a>JCAssignOp</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCAssignOp</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCExpression <span class="keyword">implements</span> <span class="title class_">CompoundAssignmentTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> JCTree.Tag opcode; <span class="comment">// 操作符</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression lhs;<span class="comment">// 赋值语句左边表达式</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression rhs;<span class="comment">// 赋值语句右边表达式</span></span><br><span class="line">    <span class="keyword">public</span> Symbol operator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --&gt; opcode可取值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">      BITOR_ASG(BITOR),                <span class="comment">// |=</span></span><br><span class="line">      BITXOR_ASG(BITXOR),              <span class="comment">// ^=</span></span><br><span class="line">      BITAND_ASG(BITAND),              <span class="comment">// &amp;=</span></span><br><span class="line"></span><br><span class="line">      SL_ASG(SL),                      <span class="comment">// &lt;&lt;=</span></span><br><span class="line">      SR_ASG(SR),                      <span class="comment">// &gt;&gt;=</span></span><br><span class="line">      USR_ASG(USR),                    <span class="comment">// &gt;&gt;&gt;=</span></span><br><span class="line">      PLUS_ASG(PLUS),                  <span class="comment">// +=</span></span><br><span class="line">      MINUS_ASG(MINUS),                <span class="comment">// -=</span></span><br><span class="line">      MUL_ASG(MUL),                    <span class="comment">// *=</span></span><br><span class="line">      DIV_ASG(DIV),                    <span class="comment">// /=</span></span><br><span class="line">      MOD_ASG(MOD),                    <span class="comment">// %=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JCBinary-二元操作符"><a href="#JCBinary-二元操作符" class="headerlink" title="JCBinary  二元操作符"></a>JCBinary  二元操作符</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCBinary</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCExpression <span class="keyword">implements</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> JCTree.Tag opcode;<span class="comment">// 操作符</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression lhs;<span class="comment">// 赋值语句左边表达式</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression rhs;<span class="comment">// 赋值语句右边表达式</span></span><br><span class="line">    <span class="keyword">public</span> Symbol operator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --&gt; 二元运算符opcode可取值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">        OR,                              <span class="comment">// ||</span></span><br><span class="line">        AND,                             <span class="comment">// &amp;&amp;</span></span><br><span class="line">        BITOR,                           <span class="comment">// |</span></span><br><span class="line">        BITXOR,                          <span class="comment">// ^</span></span><br><span class="line">        BITAND,                          <span class="comment">// &amp;</span></span><br><span class="line">        EQ,                              <span class="comment">// ==</span></span><br><span class="line">        NE,                              <span class="comment">// !=</span></span><br><span class="line">        LT,                              <span class="comment">// &lt;</span></span><br><span class="line">        GT,                              <span class="comment">// &gt;</span></span><br><span class="line">        LE,                              <span class="comment">// &lt;=</span></span><br><span class="line">        GE,                              <span class="comment">// &gt;=</span></span><br><span class="line">        SL,                              <span class="comment">// &lt;&lt;</span></span><br><span class="line">        SR,                              <span class="comment">// &gt;&gt;</span></span><br><span class="line">        USR,                             <span class="comment">// &gt;&gt;&gt;</span></span><br><span class="line">        PLUS,                            <span class="comment">// +</span></span><br><span class="line">        MINUS,                           <span class="comment">// -</span></span><br><span class="line">        MUL,                             <span class="comment">// *</span></span><br><span class="line">        DIV,                             <span class="comment">// /</span></span><br><span class="line">        MOD,                             <span class="comment">// %</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="JCReturn-返回语句"><a href="#JCReturn-返回语句" class="headerlink" title="JCReturn  返回语句"></a>JCReturn  返回语句</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCReturn</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCStatement <span class="keyword">implements</span> <span class="title class_">ReturnTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression expr;   <span class="comment">//返回语句的结果字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JCLiteral-字面量表达式"><a href="#JCLiteral-字面量表达式" class="headerlink" title="JCLiteral  字面量表达式"></a>JCLiteral  字面量表达式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCLiteral</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCExpression <span class="keyword">implements</span> <span class="title class_">LiteralTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TypeTag typetag;<span class="comment">//常量的类型</span></span><br><span class="line">    <span class="keyword">public</span> Object value;<span class="comment">//常量值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --&gt; typetag 常量类型取值 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TypeTag</span> &#123;</span><br><span class="line">    BYTE(<span class="number">1</span>, <span class="number">125</span>, <span class="literal">true</span>),<span class="comment">// byte 类型</span></span><br><span class="line">    CHAR(<span class="number">2</span>, <span class="number">122</span>, <span class="literal">true</span>),<span class="comment">// char 类型</span></span><br><span class="line">    SHORT(<span class="number">4</span>, <span class="number">124</span>, <span class="literal">true</span>),<span class="comment">// short 类型</span></span><br><span class="line">    LONG(<span class="number">16</span>, <span class="number">112</span>, <span class="literal">true</span>),<span class="comment">// long 类型</span></span><br><span class="line">    FLOAT(<span class="number">32</span>, <span class="number">96</span>, <span class="literal">true</span>),<span class="comment">// float 类型</span></span><br><span class="line">    INT(<span class="number">8</span>, <span class="number">120</span>, <span class="literal">true</span>),<span class="comment">// int 类型</span></span><br><span class="line">    DOUBLE(<span class="number">64</span>, <span class="number">64</span>, <span class="literal">true</span>),<span class="comment">// double 类型</span></span><br><span class="line">    BOOLEAN(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>),<span class="comment">// boolean 类型</span></span><br><span class="line">    VOID,<span class="comment">// void</span></span><br><span class="line">    CLASS,<span class="comment">// class </span></span><br><span class="line">    ARRAY,<span class="comment">// array 数组</span></span><br><span class="line">    METHOD,<span class="comment">// method 方法</span></span><br><span class="line">    PACKAGE,<span class="comment">// package 包</span></span><br><span class="line">    TYPEVAR,</span><br><span class="line">    WILDCARD,</span><br><span class="line">    FORALL,</span><br><span class="line">    DEFERRED,</span><br><span class="line">    BOT,</span><br><span class="line">    NONE,</span><br><span class="line">    ERROR,</span><br><span class="line">    UNKNOWN,</span><br><span class="line">    UNDETVAR,</span><br><span class="line">    UNINITIALIZED_THIS,</span><br><span class="line">    UNINITIALIZED_OBJECT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 样例</span></span><br><span class="line">treeMaker.Literal(TypeTag.BOT,<span class="literal">null</span>)  <span class="comment">//  表示  null</span></span><br></pre></td></tr></table></figure><h5 id="JCFieldAccess-其他类的变量、方法的访问表达式"><a href="#JCFieldAccess-其他类的变量、方法的访问表达式" class="headerlink" title="JCFieldAccess   其他类的变量、方法的访问表达式"></a>JCFieldAccess   其他类的变量、方法的访问表达式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCFieldAccess</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCExpression <span class="keyword">implements</span> <span class="title class_">MemberSelectTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression selected; <span class="comment">//类访问表达式</span></span><br><span class="line">    <span class="keyword">public</span> Name name;<span class="comment">// 变量名、方法名</span></span><br><span class="line">    <span class="keyword">public</span> Symbol sym;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JCMethodInvocation-方法调用表达式"><a href="#JCMethodInvocation-方法调用表达式" class="headerlink" title="JCMethodInvocation   方法调用表达式"></a>JCMethodInvocation   方法调用表达式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCMethodInvocation</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCPolyExpression <span class="keyword">implements</span> <span class="title class_">MethodInvocationTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;JCTree.JCExpression&gt; typeargs;<span class="comment">// 调用方法参数类型列表</span></span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression meth;<span class="comment">// 方法的调用语句</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;JCTree.JCExpression&gt; args;<span class="comment">// 参数列表</span></span><br><span class="line">    <span class="keyword">public</span> Type varargsElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JCSkip"><a href="#JCSkip" class="headerlink" title="JCSkip"></a>JCSkip</h5><p>空操作，即一个无效的分号 “;”</p><h5 id="JCUnary-一元运算表达式"><a href="#JCUnary-一元运算表达式" class="headerlink" title="JCUnary  一元运算表达式"></a>JCUnary  一元运算表达式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCUnary</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCExpression <span class="keyword">implements</span> <span class="title class_">UnaryTree</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> JCTree.Tag opcode;<span class="comment">//操作运算符</span></span><br><span class="line">        <span class="keyword">public</span> JCTree.JCExpression arg;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">  POS,                             <span class="comment">// +</span></span><br><span class="line">  NEG,                             <span class="comment">// -</span></span><br><span class="line">  NOT,                             <span class="comment">// !</span></span><br><span class="line">  COMPL,                           <span class="comment">// ~</span></span><br><span class="line">  PREINC,                          <span class="comment">// ++ _；例子：++i</span></span><br><span class="line">  PREDEC,                          <span class="comment">// -- _； 例子：--i</span></span><br><span class="line">  POSTINC,                         <span class="comment">// _ ++; 例子：i++</span></span><br><span class="line">  POSTDEC,                         <span class="comment">// _ --; 例子：i--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--&gt;例子：i++;</span><br><span class="line">treeMaker.Unary(JCTree.Tag.POSTINC, treeMaker.Ident(names.fromString(<span class="string">&quot;i&quot;</span>)));</span><br></pre></td></tr></table></figure><h5 id="JCBlock-代码块-定义"><a href="#JCBlock-代码块-定义" class="headerlink" title="JCBlock 代码块 定义"></a>JCBlock 代码块 定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCBlock</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCStatement <span class="keyword">implements</span> <span class="title class_">BlockTree</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> flags;</span><br><span class="line">        <span class="keyword">public</span> List&lt;JCTree.JCStatement&gt; stats;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">endpos</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line">List&lt;JCTree.JCStatement&gt; jcStatements = List.nil();</span><br><span class="line">treeMaker.Block(<span class="number">0</span>,jcStatements);</span><br></pre></td></tr></table></figure><h5 id="JCForLoop-for-循环代码块定义"><a href="#JCForLoop-for-循环代码块定义" class="headerlink" title="JCForLoop    for 循环代码块定义"></a>JCForLoop    for 循环代码块定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCForLoop</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCStatement <span class="keyword">implements</span> <span class="title class_">ForLoopTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;JCTree.JCStatement&gt; init;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression cond;</span><br><span class="line">    <span class="keyword">public</span> List&lt;JCTree.JCExpressionStatement&gt; step;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCStatement body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JCDoWhileLoop-do…while-循环代码块定义"><a href="#JCDoWhileLoop-do…while-循环代码块定义" class="headerlink" title="JCDoWhileLoop  do…while 循环代码块定义"></a>JCDoWhileLoop  do…while 循环代码块定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCDoWhileLoop</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCStatement <span class="keyword">implements</span> <span class="title class_">DoWhileLoopTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCStatement body;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression cond;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JCWhileLoop-while-循环代码块定义"><a href="#JCWhileLoop-while-循环代码块定义" class="headerlink" title="JCWhileLoop    while 循环代码块定义"></a>JCWhileLoop    while 循环代码块定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCWhileLoop</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCStatement <span class="keyword">implements</span> <span class="title class_">WhileLoopTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression cond;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCStatement body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JCEnhancedForLoop-增强for-循环定义"><a href="#JCEnhancedForLoop-增强for-循环定义" class="headerlink" title="JCEnhancedForLoop  增强for 循环定义"></a>JCEnhancedForLoop  增强for 循环定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCWhileLoop</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCStatement <span class="keyword">implements</span> <span class="title class_">WhileLoopTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression cond;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCStatement body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JCSynchronized-同步锁定义"><a href="#JCSynchronized-同步锁定义" class="headerlink" title="JCSynchronized 同步锁定义"></a>JCSynchronized 同步锁定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JCSynchronized</span> <span class="keyword">extends</span> <span class="title class_">JCTree</span>.JCStatement <span class="keyword">implements</span> <span class="title class_">SynchronizedTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCExpression lock;</span><br><span class="line">    <span class="keyword">public</span> JCTree.JCBlock body;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 样例 synchronized()&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>样例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建同步代码块</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gen</span><span class="params">()</span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        JCTree.<span class="type">JCStatement</span> <span class="variable">jcStatement</span> <span class="operator">=</span> treeMaker.Exec(</span><br><span class="line">                treeMaker.Apply(List.nil(),treeMaker.Select(</span><br><span class="line">                        treeMaker.Select(</span><br><span class="line">                                treeMaker.Ident(</span><br><span class="line">                                        names.fromString(<span class="string">&quot;System&quot;</span>)</span><br><span class="line">                                ),</span><br><span class="line">                                names.fromString(<span class="string">&quot;out&quot;</span>)</span><br><span class="line">                        ),</span><br><span class="line">                        names.fromString(<span class="string">&quot;println&quot;</span>)</span><br><span class="line">                ),List.of(treeMaker.Literal(<span class="string">&quot;Hello, world!!!&quot;</span>)))</span><br><span class="line">        );</span><br><span class="line">List&lt;JCTree.JCStatement&gt; statementList = List.nil();</span><br><span class="line">        <span class="comment">// &#123;System.out.println(&quot;Hello, world!!!&quot;);&#125;</span></span><br><span class="line">JCTree.<span class="type">JCBlock</span> <span class="variable">jcBlock</span> <span class="operator">=</span> treeMaker.Block(<span class="number">0</span>,statementList);</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// syschroninzed(demoA)</span></span><br><span class="line">   JCTree.<span class="type">JCExpression</span> <span class="variable">SynjcExpression</span> <span class="operator">=</span> treeMaker.Ident(names.fromString(<span class="string">&quot;demoA&quot;</span>));</span><br><span class="line">   JCTree.<span class="type">JCSynchronized</span> <span class="variable">jcSynchronized</span> <span class="operator">=</span> treeMaker.Synchronized(SynjcExpression,jcBlock);</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终结果为：</span></span><br><span class="line"><span class="keyword">synchronized</span>(demoA) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, world!!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html">http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html</a></p><p><a href="https://www.cnblogs.com/wade-luffy/p/6050331.html">https://www.cnblogs.com/wade-luffy/p/6050331.html</a></p><p><a href="https://www.jianshu.com/p/ff8ec920f5b9">https://www.jianshu.com/p/ff8ec920f5b9</a></p><p><a href="https://www.jianshu.com/p/5df7f77611dc">https://www.jianshu.com/p/5df7f77611dc</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一篇文章&lt;a href=&quot;2021/01/28/java-processor&quot;&gt;java自定义编译时注解器&lt;/a&gt;中讲述到了有关自定义注解器的使用，接来在这里将会讲述的是如何通过语法树表示所想要的代码结构，并通过编译处理器生成相应的字节码。&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://cxinxian.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java自定义编译时注解器</title>
    <link href="http://cxinxian.github.io/2021/01/28/java-processor/"/>
    <id>http://cxinxian.github.io/2021/01/28/java-processor/</id>
    <published>2021-01-28T02:04:42.000Z</published>
    <updated>2021-06-05T00:48:41.662Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、注解器"><a href="#一、注解器" class="headerlink" title="一、注解器"></a>一、注解器</h4><p>java 注解编译处理器，主要作用是针对特定的注解进行相应的处理。根据个人观察目前主要多用于代码生成、代码审查。在安卓开发中，常用的Butterknife、Dagger2、Room等以及一些组件化的框架都都会看到编译注解处理器的身影。而在java后端的开发中 Lombok 也是有使用到边缘处理器的。</p><span id="more"></span><p>关于注解的定义及分类的大概信息如下图，图片来源于 <a href="https://blog.csdn.net/asd54090/article/details/80920667">https://blog.csdn.net/asd54090/article/details/80920667</a>  ， 感谢前辈大佬的整理。</p><p><img src="/assets/blogImg/java-processor/1.jpg" alt="图1"></p><h4 id="二、认识AbstractProcessor"><a href="#二、认识AbstractProcessor" class="headerlink" title="二、认识AbstractProcessor"></a>二、认识AbstractProcessor</h4><p>注解处理器（Annotation Processor） 是javac 的一个工具，主要是在编译时扫描和处理由注解。那么我们要处理特定的注解，自然是上不了注解处理器，想要自定义注解处理器处理特定的逻辑和代码，那么就应该继承 <code>AbstractProcessor</code> 这个抽象类，并实现 <code>process</code>方法。</p><p><code>AbstractProcessor </code> 类的主要几个方法如下：</p><ul><li><p><code>init(ProcessingEnvironment env)</code> ：由注解工具调用，并传入 <code>ProcessingEnvironment </code> 参数，<code>ProcessingEnvironment </code> 提供很多工具类<code>Messager</code>、<code>Types</code>、<code>Elements</code> 、<code>Filer</code> 等等。</p></li><li><p><code>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</code> ：每个处理器的核心处理业务都在这里得到执行，可以实现代码扫描、评估、注释代码处理，生成java文件。通过参数<code>RoundEnvironment</code>的 <code>getElementsAnnotatedWith</code> 可以获取到特定注解的元素。</p></li><li><p><code>getSupportedSourceVersion()</code>：主要用来指定处理器支持处理的Java版本，通常使用<code>SourceVersion.latestSupported()</code> 作为返回值。当然如果自定义注解类使用了<code>@SupportedSourceVersion</code> 注解，可以不用重写此方法。</p><p>注意：如果使用<code>@SupportedSourceVersion</code> 注解，需要考虑，这个注解是 java 6 才引入的</p></li><li><p><code>getSupportedAnnotationTypes()</code> : 主要是用来设置当前注解处理器支持处理的注解，如果不指定需要处理的注解，则 <code>process</code> 方法将不会得到执行。该方法返回的是 <code>Set&lt;String&gt;</code> 集合，包含支持注解的合法全称。</p><p>注意：该方法也可以使用<code>@SupportedAnnotationTypes</code> 注解来代替。</p></li></ul><h4 id="三、自定义-Annotation-Processor"><a href="#三、自定义-Annotation-Processor" class="headerlink" title="三、自定义 Annotation Processor"></a>三、自定义 Annotation Processor</h4><p>实现自定义注解大概分为以下这几个步骤:</p><p>step1、定义注解；</p><p>step2、继承 <strong>AbstractProcessor</strong> 类并实现抽象方法 <code>process</code> 和重新上面介绍到的另外几个方法;</p><p>step3、编写关键的业务代码逻辑，主要在逻辑应写在 <code>process</code> 方法中；比如解析语法树，编辑修改、增加语法树等等</p><p>（关于语法树，本次不做记录和解释，后面再新的篇幅另做介绍。）</p><p>新建工程，maven 依赖如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;auto-service&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;<span class="number">1.0</span>-rc2&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.sun&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;tools&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;<span class="number">1.8</span>&lt;/version&gt;</span><br><span class="line">     &lt;scope&gt;system&lt;/scope&gt;</span><br><span class="line">     &lt;systemPath&gt;$&#123;java.home&#125;/../lib/tools.jar&lt;/systemPath&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"> &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><ul><li>AutoService 会自动在META-INF文件夹下生成Processor配置信息文件，该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF&#x2F;services&#x2F;里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定，方便快捷。</li></ul><p>如果不依赖 <code>auto-service</code> 时，则需要在 <code>META-INF\services</code>  文件夹下手动创建 <code>javax.annotation.processing.Processor</code> 文件。并且保存自定义注解器的包路径，如：<code>com.godc.XAnnotionProcessor</code></p><ul><li>tools 依赖包是jdk 自带的工具包，语法树相关的都会用到该依赖。比如：JCTree、TreeMaker</li></ul><p>首先定义一个注解，比如一个方法注解，在注解的方法中添加日志打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.godc.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Plog &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义处理器类如下</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.godc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.godc.annotation.Inject;</span><br><span class="line"><span class="keyword">import</span> com.godc.annotation.InjectParams;</span><br><span class="line"><span class="keyword">import</span> com.godc.annotation.Plog;</span><br><span class="line"><span class="keyword">import</span> com.godc.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> com.google.auto.service.AutoService;</span><br><span class="line"><span class="keyword">import</span> com.sun.source.util.Trees;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.model.JavacElements;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.processing.JavacProcessingEnvironment;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.JCTree;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.TreeMaker;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Context;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Names;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.Element;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.ElementKind;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.TypeElement;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MyAnnotionProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> chenxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/2/18 17:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AutoService(Processor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotionProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Trees trees;</span><br><span class="line">    Names names;</span><br><span class="line">    TreeMaker treeMaker;</span><br><span class="line">    JavacElements javacElements;</span><br><span class="line">    Messager messager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前注解处理器需要处理的注解</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;&gt; ANNOTATIONS = Arrays.asList(</span><br><span class="line">            Inject.class</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init 方法由注解工具的构造方法调用，并传入 ProcessingEnvironment  参数</span></span><br><span class="line"><span class="comment">     * 该参数提供了很多工具类，比如 Elements， Filer， Messager， Types，TreMaker，Names</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> processingEnv</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.init(processingEnv);</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> ((JavacProcessingEnvironment)processingEnv).getContext();</span><br><span class="line">        messager = processingEnv.getMessager();</span><br><span class="line">        trees = Trees.instance(processingEnv);</span><br><span class="line">        names = Names.instance(context);</span><br><span class="line">        javacElements = ((JavacProcessingEnvironment) processingEnv).getElementUtils();</span><br><span class="line">        treeMaker = TreeMaker.instance(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法虽我们也是需要实现。</span></span><br><span class="line"><span class="comment">     * 因为该方法的作用是明确指定我们要处理哪些注解的，</span></span><br><span class="line"><span class="comment">     * 所以你要在这里指明，你需要处理的注解的全称。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 返回值是一个字符串的集合，包含着本处理器想要处理的注解类型的合法全称。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">getSupportedAnnotationTypes</span><span class="params">()</span> &#123;</span><br><span class="line">        Set&lt;String&gt; supportAnnotationTypes = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotation : ANNOTATIONS)&#123;</span><br><span class="line">            supportAnnotationTypes.add(annotation.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> supportAnnotationTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主要用来指定处理器支持处理的Java版本，通常使用 SourceVersion.latestSupported()`</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SourceVersion <span class="title function_">getSupportedSourceVersion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SourceVersion.latestSupported();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个处理器的核心处理业务都在这里得到执行，可以实现代码扫描、评估、注释代码处理，生成java文件。</span></span><br><span class="line"><span class="comment">     * 通过参数`RoundEnvironment`的 `getElementsAnnotatedWith` 可以获取到特定注解的元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotations</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> roundEnv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;</span><br><span class="line">        Set&lt;? <span class="keyword">extends</span> <span class="title class_">Element</span>&gt; elementSet = roundEnv.getElementsAnnotatedWith(Inject.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element element : elementSet)&#123;</span><br><span class="line">            JCTree.<span class="type">JCMethodDecl</span> <span class="variable">jcMethodDecl</span> <span class="operator">=</span> (JCTree.JCMethodDecl) javacElements.getTree(element);</span><br><span class="line"></span><br><span class="line">            treeMaker.pos = jcMethodDecl.pos;</span><br><span class="line">            jcMethodDecl.body = treeMaker.Block(<span class="number">1</span>, com.sun.tools.javac.util.List.of(</span><br><span class="line">                    treeMaker.Exec(</span><br><span class="line">                            treeMaker.Apply(com.sun.tools.javac.util.List.nil(),treeMaker.Select(</span><br><span class="line">                                    treeMaker.Select(</span><br><span class="line">                                            treeMaker.Ident(</span><br><span class="line">                                                    javacElements.getName(<span class="string">&quot;System&quot;</span>)</span><br><span class="line">                                            ),</span><br><span class="line">                                            javacElements.getName(<span class="string">&quot;out&quot;</span>)</span><br><span class="line">                                    ),</span><br><span class="line">                                    javacElements.getName(<span class="string">&quot;println&quot;</span>)</span><br><span class="line">                            ),com.sun.tools.javac.util.List.of(treeMaker.Literal(<span class="string">&quot;Hello, world!!!&quot;</span>)))</span><br><span class="line">                    ),</span><br><span class="line">                    jcMethodDecl.body</span><br><span class="line">            ));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写测试方法，并使用注解，编译项目就会得到如下效果</p><p><img src="/assets/blogImg/java-processor/2.jpg" alt="图2"></p><h4 id="四、调试注解器"><a href="#四、调试注解器" class="headerlink" title="四、调试注解器"></a>四、调试注解器</h4><p>在 IDEA中调试编译注解器还是挺方便的，IDEA作为客户端，JVM作为服务端。主要三个步骤：</p><ol><li>在注解器中打断点</li><li>在IDEA （Edit Configurations）中配置远程调试 （如下图3）</li><li>在 terminal 控制台输入 <code>mvnDebug clean package</code>，打开maven 远程调试服务监听 8000 端口了</li><li>点击debug 按钮 启动远程调试</li></ol><p><img src="/assets/blogImg/java-processor/pic3.jpg" alt="图3"></p><p>在此次的测试中，项目结构如下图：</p><p><code>mprocessor</code> 为注解器模块，存放注解、注解器的实现，代码生成</p><p><code>testprocessor</code> 为测试模块，依赖 注解器模块 做测试</p><p><img src="/assets/blogImg/java-processor/pic4.png" alt="图4"></p><h4 id="资源来源："><a href="#资源来源：" class="headerlink" title="资源来源："></a>资源来源：</h4><p><a href="https://blog.csdn.net/asd54090/article/details/80920667">https://blog.csdn.net/asd54090/article/details/80920667</a></p><p><a href="https://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html">https://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html</a></p><p><a href="https://blog.csdn.net/dap769815768/article/details/90448451">https://blog.csdn.net/dap769815768/article/details/90448451</a></p><p><a href="https://www.jianshu.com/p/68fcbc154c2f">https://www.jianshu.com/p/68fcbc154c2f</a></p><p><a href="https://www.jianshu.com/p/d0dd91c7c560">https://www.jianshu.com/p/d0dd91c7c560</a></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;一、注解器&quot;&gt;&lt;a href=&quot;#一、注解器&quot; class=&quot;headerlink&quot; title=&quot;一、注解器&quot;&gt;&lt;/a&gt;一、注解器&lt;/h4&gt;&lt;p&gt;java 注解编译处理器，主要作用是针对特定的注解进行相应的处理。根据个人观察目前主要多用于代码生成、代码审查。在安卓开发中，常用的Butterknife、Dagger2、Room等以及一些组件化的框架都都会看到编译注解处理器的身影。而在java后端的开发中 Lombok 也是有使用到边缘处理器的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://cxinxian.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>关于yuv的学习理解</title>
    <link href="http://cxinxian.github.io/2021/01/25/about-yuv/"/>
    <id>http://cxinxian.github.io/2021/01/25/about-yuv/</id>
    <published>2021-01-25T14:08:45.000Z</published>
    <updated>2022-02-28T02:13:18.962Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>&emsp;在Android视频或者拍摄图片开发中，因为不了解yuv，所以在写视频demo时，手机预览的界面可能存在旋转 90&#x2F;180&#x2F;270 度的问题。大部分后置摄像头是旋转了90度，</p><p>&emsp;前置摄像头旋转270了度。如果要看到正常角度的预览界面，我们则需要对摄像头进行旋转一定的角度，而且旋转的角度只能是 0&#x2F;90&#x2F;180&#x2F;270。</p><p>&emsp;关于摄像头的旋转和开发打算放在下一篇文章记录，而这一次有更加重要的内容要记录。即使我们设置了正确的预览界面，当按下快门或者拍摄视频的那一刻，</p><p>&emsp;摄像头记录下的数据(默认为NV21数据格式，是YUV的一种数据格式)，可能并不是我们真正想要的。记录的照片或者视频的角度可能会存在问题，可能是旋转了 90&#x2F;180&#x2F;270 度。而我们要想获取到正确的角度，那么需要用 YUV 对数据进行转换或者旋转，才能得到我们希望的角度。</p><span id="more"></span><h4 id="一、YUV与RGB"><a href="#一、YUV与RGB" class="headerlink" title="一、YUV与RGB"></a>一、YUV与RGB</h4><ul><li><p><strong>YUV</strong>  </p><p>&emsp;是视频应用程序中使用的一类像素格式。</p><p>&emsp;亮度信号通常被称作Y，色度信号通常是由两个相互独立的的信号组成，不同的颜色系统有不同的格式，两种不同的色度信号经常被称作U和V 或者 Cb和 Cr 或者 Pb和Pr。这是由于不同颜色系统的编码格式不一样所产生的，实际上是相同的概念。色度信号主要作用是描述影像色彩及饱和度，用于指定像素的颜色。</p><p>&emsp;主要用于电视系统以及模拟视频领域，它将亮度（luma）信息（Y）与色彩(chroma)信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。</p></li><li><p><strong>RGB</strong></p><p>&emsp;是用于表示图像和视频的颜色模型。RGB代表<em>红色</em>，<em>绿色</em>和<em>蓝色</em>分量。</p></li></ul><p>YUV 的格式有两种，分别是 <code>planar</code> 和 <code>packed</code></p><ul><li><strong>planar</strong> （平面格式）先连续存储所以像素点的Y，紧接着存储所有像素点的U，最后是存储所有像素点的V。<ul><li>属于planer 的有 NV12、NV21、YV12、I420 等等，列举的这几个主要是YUV4:2:0采样，当然也包含其他采样方式。</li></ul></li><li><strong>packed</strong>  （打包格式）是每个像素点的Y、U、V是连续交叉存储的。<ul><li>属于packed的有 YUYV、UYVY、VYUY等，这几个主要是YUV4:2:2采样</li></ul></li></ul><p>在Android 平台下使用相机默认格式是NV21，属于YUV420sp</p><h4 id="二、YUV的-4-4-4-、4-2-2、4-2-0采样模式"><a href="#二、YUV的-4-4-4-、4-2-2、4-2-0采样模式" class="headerlink" title="二、YUV的 4:4:4 、4:2:2、4:2:0采样模式"></a>二、YUV的 4:4:4 、4:2:2、4:2:0采样模式</h4><p>据研究表明人眼对亮度的分辨相对于色彩色度的分辨更加敏锐，容易察觉。那么在存储图像信息时，采用不同的采样方式可以有效的减少媒体信息的内存空间和降低带宽资源的占用。</p><p><img src="/assets/blogImg/about-yuv/yuv-format.jpg" alt="图1"></p><p>通常地 <code>YUV a:b:c</code> 的意思是表示每4个像素采样点Y采样了a次，U采样了b次，V采样了c次。</p><p>如上图所示，每一个小格表示一个像素，那么在这4中不同的采样方式中像素点和对应的亮度、色度采集信息大概可以总结为如下：</p><ul><li><p><code>YUV4:4:4</code>采样方式生成的图像中，每4个采样的像素点都会对应4点亮度Y、4点U(或者Cb)、4点V(或者Cr)，即亮度分辨率和色度分辨率相等；一帧数据量为：<code>width * height * 3byte</code></p></li><li><p><code>YUV4:2:2</code>采样方式，即每4个采样像素点对应有4点Y采样，2点U、2点V。即在色度采样上，个一个采样点才会有色度信息，会丢弃一半色度信息。亮度和色度在水平方向比值 2:1，在垂直方向1:1。一帧的数据量为： <code>widht * heitht * 2byte</code></p></li><li><p><code>YUV4:2:0</code>采样，并不是只有Y、U或者V 采样，而是在行扫描线上，只有一种色度采样，其在存储中亮度和色度的采样比为2:1。也就是说，如果第一行YUV采样为4:2:0, 那么下一行是 4:0:2, 如此类推。从亮度、色度采样分布情况来看，每4个采样像素点在纵向和横向扫描线上都丢掉一半的色度采样信息。一帧的数据量为：<code>width * height * 1.5byte</code></p><p>其中<code>YUV4:2:0</code>分为两种：<code>YUV420P和YUV420SP</code></p><ul><li><code>YUV420P</code>又叫<code>plane平面模式</code>，Y、U、V 分别存储在不同的平面，也就有三个平面。它是标准格式<code>YUV4:2:0</code> ，又分为：<code>YV12</code> 和 <code>YU12</code></li><li><code>YUV420sp</code> 是一种<code>tow-plane模式</code>，即 Y与 UV分别存储在两个不同的平面，先是Y一个平面，然后UV（CbCr）在同一个平面里交替存储。子格式分为：<code>NV12</code>  和 <code>NV21</code></li></ul><p>最后总结如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YUV 4:4:4采样，每一个Y对应一组UV分量,一个YUV占8+8+8 = 24bits 3个字节。</span><br><span class="line">YUV 4:2:2采样，每两个Y共用一组UV分量,一个YUV占8+4+4 = 16bits 2个字节。</span><br><span class="line">YUV 4:2:0采样，每四个Y共用一组UV分量,一个YUV占8+2+2 = 12bits 1.5个字节。</span><br></pre></td></tr></table></figure></li></ul><h4 id="三、YUV的存储格式"><a href="#三、YUV的存储格式" class="headerlink" title="三、YUV的存储格式"></a>三、YUV的存储格式</h4><p>基于不同采样方式的码流存储方式如下：</p><ul><li><strong>NV12、NV21格式：</strong></li></ul><p><img src="/assets/blogImg/about-yuv/nv12-nv21.jpg" alt="nv12-nv21"></p><p>&emsp;&emsp;NV12和NV21同属于YUV4:2:0 采样，是一种tow-plane模式，Y和UV分为两个Plane,UV交错存储。如图所示，其采样基本上遵循YUV4:2:0方式，即对于像素点Y<sub>00</sub>Y<sub>01</sub>Y<sub>10</sub>Y<sub>11</sub>，其对应色度值 UV(Cb,Cr) 为U<sub>00</sub>V<sub>00</sub>，二者的区别在于 NV12 是 UV(Cb，Cr) 交替存储，NV21是VU（Cb,Cr）交错存储。IOS应用的是NV12, 而Android应用的是NV21。</p><ul><li><p><strong>YV12、YU12格式：</strong></p><p><img src="/assets/blogImg/about-yuv/yv12-yu12.jpg" alt="yv12-yu12"></p><p>&emsp;&emsp;YV12、YU12码流格式属于YUV4:2:0，是plane模式，其中Y、U、V分量分别打包，依次存储。同样也是每4个像素点共享一对UV，即如图所示：Y<sub>00</sub>Y<sub>01</sub>Y<sub>10</sub>Y<sub>11</sub>，其对应色度值 UV(Cb,Cr) 为U<sub>00</sub>V<sub>00</sub></p></li><li><p><strong>I420格式：</strong></p><p><img src="/assets/blogImg/about-yuv/i420.jpg" alt="i420"></p><p>&emsp;&emsp;I420码流格式也是属于YUV4:2:0， Y、U、V采样数据分量分别打包，依次存储在不同的平面，对于Y<sub>00</sub>Y<sub>01</sub>Y<sub>10</sub>Y<sub>11</sub> 元素，共享的色度值元素为U<sub>00</sub>V<sub>00</sub></p></li><li><p><strong>YUYV格式：</strong></p><p><img src="/assets/blogImg/about-yuv/yuyv.jpg" alt="yv12-yu12"></p><p>&emsp;&emsp;YUYV是YUV4:2:2采样存储格式中的一种，是packed 打包格式，其中Y、U、V交替存储；相邻的两个Y 共享相邻的两个U、V色度采样，也即Y<sub>00</sub>Y<sub>01</sub> 共享 U<sub>00</sub>V<sub>00</sub></p></li><li><p><strong>UYVY、VYUY格式：</strong></p><p><img src="/assets/blogImg/about-yuv/uyvy-vyuy.jpg" alt="yv12-yu12"></p><p>&emsp;&emsp;图示为UYVY格式，同样的，也是YUV4:2:2采样存储格式中的一种，与YUYV不同的是UV分别排列在Y的前方。</p></li></ul><h4 id="四、YUV和RGB转换"><a href="#四、YUV和RGB转换" class="headerlink" title="四、YUV和RGB转换"></a>四、YUV和RGB转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">YUV and RGB</span><br><span class="line">YUV-&gt;RGB</span><br><span class="line">Y&#x27;= 0.299*R&#x27; + 0.587*G&#x27; + 0.114*B&#x27;</span><br><span class="line">U&#x27;= -0.147*R&#x27; - 0.289*G&#x27; + 0.436*B&#x27; = 0.492*(B&#x27;- Y&#x27;)</span><br><span class="line">V&#x27;= 0.615*R&#x27; - 0.515*G&#x27; - 0.100*B&#x27; = 0.877*(R&#x27;- Y&#x27;)</span><br><span class="line">RGB-&gt;YUV</span><br><span class="line">R&#x27; = Y&#x27; + 1.140*V&#x27;</span><br><span class="line">G&#x27; = Y&#x27; - 0.394*U&#x27; - 0.581*V&#x27;</span><br><span class="line">B&#x27; = Y&#x27; + 2.032*U&#x27;</span><br><span class="line">##################################################</span><br><span class="line">YCbCr and RGB</span><br><span class="line">YCbCr-&gt;RGB</span><br><span class="line">Y’ = 0.257*R&#x27; + 0.504*G&#x27; + 0.098*B&#x27; + 16</span><br><span class="line">Cb&#x27; = -0.148*R&#x27; - 0.291*G&#x27; + 0.439*B&#x27; + 128</span><br><span class="line">Cr&#x27; = 0.439*R&#x27; - 0.368*G&#x27; - 0.071*B&#x27; + 128</span><br><span class="line">RGB-&gt;YCbCr</span><br><span class="line">R&#x27; = 1.164*(Y’-16) + 1.596*(Cr&#x27;-128)</span><br><span class="line">G&#x27; = 1.164*(Y’-16) - 0.813*(Cr&#x27;-128) - 0.392*(Cb&#x27;-128)</span><br><span class="line">B&#x27; = 1.164*(Y’-16) + 2.017*(Cb&#x27;-128)</span><br></pre></td></tr></table></figure><h4 id="五、YUV旋转"><a href="#五、YUV旋转" class="headerlink" title="五、YUV旋转"></a>五、YUV旋转</h4><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://wiki.videolan.org/YUV/">https://wiki.videolan.org/YUV/</a></p><p><a href="https://wiki.videolan.org/RGB/">https://wiki.videolan.org/RGB/</a></p><p><a href="https://www.fourcc.org/yuv.php">https://www.fourcc.org/yuv.php</a></p><p><a href="https://www.cnblogs.com/sddai/p/10302979.html">https://www.cnblogs.com/sddai/p/10302979.html</a></p><p><a href="https://blog.csdn.net/iva_brother/article/details/84036877">https://blog.csdn.net/iva_brother/article/details/84036877</a></p><p><a href="https://zhuanlan.zhihu.com/p/85620611">https://zhuanlan.zhihu.com/p/85620611</a></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;&amp;emsp;在Android视频或者拍摄图片开发中，因为不了解yuv，所以在写视频demo时，手机预览的界面可能存在旋转 90&amp;#x2F;180&amp;#x2F;270 度的问题。大部分后置摄像头是旋转了90度，&lt;/p&gt;
&lt;p&gt;&amp;emsp;前置摄像头旋转270了度。如果要看到正常角度的预览界面，我们则需要对摄像头进行旋转一定的角度，而且旋转的角度只能是 0&amp;#x2F;90&amp;#x2F;180&amp;#x2F;270。&lt;/p&gt;
&lt;p&gt;&amp;emsp;关于摄像头的旋转和开发打算放在下一篇文章记录，而这一次有更加重要的内容要记录。即使我们设置了正确的预览界面，当按下快门或者拍摄视频的那一刻，&lt;/p&gt;
&lt;p&gt;&amp;emsp;摄像头记录下的数据(默认为NV21数据格式，是YUV的一种数据格式)，可能并不是我们真正想要的。记录的照片或者视频的角度可能会存在问题，可能是旋转了 90&amp;#x2F;180&amp;#x2F;270 度。而我们要想获取到正确的角度，那么需要用 YUV 对数据进行转换或者旋转，才能得到我们希望的角度。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://cxinxian.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存模型（JMM）</title>
    <link href="http://cxinxian.github.io/2020/12/14/java/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://cxinxian.github.io/2020/12/14/java/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-12-14T13:19:32.000Z</published>
    <updated>2025-02-21T13:13:01.672Z</updated>
    
    <content type="html"><![CDATA[<p>我们常说的JVM 内存模型指的是 JVM 的内存分区；而 Java 内存模型是一种虚拟机规范。</p><p>Java 虚拟机规范中定义了 Java 内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各个平台下都能达到一致的并发效果，JMM 规范了 Java 虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p><span id="more"></span><p>Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处变量与 Java 编程时所说的变量不一样，指包括了实例字段，静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。</p><p><img src="/../assets/blogImg/java/jmm-01.jpg" alt="jmm-01"> </p><p><img src="/../assets/blogImg/java/jmm-02.jpg" alt="jmm-02"></p><p>Java内存模型（不仅仅是JVM内存分区）：调用栈和本地变量存放在线程栈上，对象存放在堆上。</p><ul><li>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。</li><li>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。</li><li>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量仍然存放在线程栈上，即使这些方法所属的对象存放在堆上。</li><li>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</li><li>静态成员变量跟随着类定义一起也存放在堆上。</li><li>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个成员变量的私有拷贝。</li></ul><hr><h2 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h2><p>现代硬件内存模型与Java内存模型有一些不同，理解内存模型架构以及Java内存模型如何与它协同工作也是非常重要的。</p><p>现代计算机硬件架构的简单图示：</p><p><img src="/../assets/blogImg/java/jmm-04.jpg" alt="jmm-04"></p><ul><li><strong>多CPU</strong>：一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并发）执行。</li><li><strong>CPU寄存器</strong>：每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。</li><li><strong>高速缓存cache</strong>：由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。每个CPU可能有一个CPU缓存层，一些CPU还有多层缓存。在某一时刻，一个或者多个缓存行（cache lines）可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。</li><li><strong>内存</strong>：一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多。</li><li><strong>运作原理</strong>：通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。</li></ul><p><strong>一些问题</strong></p><blockquote><p><strong>缓存一致性问题</strong>：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题：缓存一致性（CacheCoherence）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol，等等：</p><p><strong>指令重排序问题</strong>：为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化</p></blockquote><h2 id="Java-内存模型与硬件内存架构之间的桥接"><a href="#Java-内存模型与硬件内存架构之间的桥接" class="headerlink" title="Java 内存模型与硬件内存架构之间的桥接"></a>Java 内存模型与硬件内存架构之间的桥接</h2><p>Java 内存模型规定了**所有变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。**不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示</p><p><img src="/../assets/blogImg/java/jmm-03.jpg" alt="jmm-03"></p><p>Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示：</p><p><img src="/../assets/blogImg/java/jmm-05.jpg" alt="jmm-05"></p><p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：</p><ul><li>线程之间的共享变量存储在主内存（Main Memory）中</li><li>每个线程都有一个私有的本地内存（Local Memory），本地内存是JMM的一个抽象概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。本地内存中存储了该线程以读&#x2F;写共享变量的拷贝副本。</li><li>从更低的层次来说，主内存就是硬件的内存，而为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</li><li>Java内存模型中的线程的工作内存（working memory）是cpu的寄存器和高速缓存的抽象描述。而JVM的静态内存储模型（JVM内存模型）只是一种对内存的物理划分而已，它只局限在内存，而且只局限在JVM的内存。</li></ul><p><img src="/../assets/blogImg/java/jmm-06.jpg" alt="jmm-06"></p><h2 id="JMM-模型下线程的交互操作"><a href="#JMM-模型下线程的交互操作" class="headerlink" title="JMM 模型下线程的交互操作"></a>JMM 模型下线程的交互操作</h2><p>于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p><ul><li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li><li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li></ul><p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。</p><p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p><ul><li>不允许read和load、store和write操作之一单独出现</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li></ul><h2 id="Java-内存模型解决的问题"><a href="#Java-内存模型解决的问题" class="headerlink" title="Java 内存模型解决的问题"></a>Java 内存模型解决的问题</h2><p>当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题。Java内存模型建立所围绕的问题：在多线程并发过程中，<strong>如何处理多线程读同步问题与可见性（多线程缓存与指令重排序）、多线程写同步问题与原子性（多线程竞争race condition）</strong></p><h3 id="1、多线程读同步与可见性"><a href="#1、多线程读同步与可见性" class="headerlink" title="1、多线程读同步与可见性"></a>1、多线程读同步与可见性</h3><h4 id="1-1、可见性"><a href="#1-1、可见性" class="headerlink" title="1.1、可见性"></a>1.1、可见性</h4><p><strong>可见性（共享对象可见性）</strong>：线程对共享变量修改的可见性。当一个线程修改了共享变量的值，其他线程能够立刻得知这个修改。</p><p>解决内存可见性问题可以使用：</p><ul><li><strong>volatile关键字</strong>：volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去，或者在每次使用volatile变量前都立即从主内存刷新</li><li><strong>synchronized关键字</strong>：同步快的可见性是由“如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值”、“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）”这两条规则获得的。</li><li><strong>final关键字</strong>：final关键字的可见性是指，被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去，那么在其他线程就能看见final字段的值（无须同步）</li></ul><h4 id="1-2、指令重排序"><a href="#1-2、指令重排序" class="headerlink" title="1.2、指令重排序"></a>1.2、指令重排序</h4><p>在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>从Java源代码到最终实际执行的指令序列，会经过下面三种重排序：</p><p><img src="/../assets/blogImg/java/jmm-07.png" alt="jmm-07"></p><p>为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java内存模型把内存屏障分为LoadLoad、LoadStore、StoreLoad和StoreStore四种</p><p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性：</p><ul><li>volatile关键字本身就包含了禁止指令重排序的语义</li><li>synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</li></ul><h3 id="2、多线程写同步与原子性"><a href="#2、多线程写同步与原子性" class="headerlink" title="2、多线程写同步与原子性"></a>2、多线程写同步与原子性</h3><p>如果两个或者更多的线程共享一个对象，多个线程在这个共享对象上更新变量，就有可能发生race conditions。</p><p><strong>使用原子性保证多线程写同步问题：</strong></p><p>**原子性：**指一个操作是按原子的方式执行的。要么该操作不被执行；要么以原子方式执行，即执行过程中不会被其它线程中断。</p><p>资料来源：</p><p><a href="https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html">https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/29881777">https://zhuanlan.zhihu.com/p/29881777</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们常说的JVM 内存模型指的是 JVM 的内存分区；而 Java 内存模型是一种虚拟机规范。&lt;/p&gt;
&lt;p&gt;Java 虚拟机规范中定义了 Java 内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各个平台下都能达到一致的并发效果，JMM 规范了 Java 虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://cxinxian.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Volatile 原理</title>
    <link href="http://cxinxian.github.io/2020/12/14/java/Volatile/"/>
    <id>http://cxinxian.github.io/2020/12/14/java/Volatile/</id>
    <published>2020-12-14T06:01:09.000Z</published>
    <updated>2025-02-21T13:13:14.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h2><p>内存可见性：线程对共享变量修改的可见性。当一个线程修改了共享变量的值，其他线程能够立刻得知这个修改。</p><span id="more"></span><p><strong>volatile 可以保证线程可见性且提供了一定的有序性，但是无法保证原子性</strong>。在 JVM 底层 volatile 是采用 “内存屏障” 来实现的。</p><p>观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入 volatile 关键字时，会多出一个 lock 前缀指令，lock 前缀指令实际上相当于一个内存屏障，内存屏障提供以下3个功能：</p><ul><li>确保指令重排序时不会把其后面的指令排序到内存屏障之前的位置，也不会把前面的指令排序到内存屏障的后面；即在执行到内存屏障这句指令时，在他前面的操作已经全部完成；</li><li>它会强制将对缓存的修改操作立即回写到主存中</li><li>如果是写操作，他会导致其他CPU 中对应的缓存行无效。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;内存可见性&quot;&gt;&lt;a href=&quot;#内存可见性&quot; class=&quot;headerlink&quot; title=&quot;内存可见性&quot;&gt;&lt;/a&gt;内存可见性&lt;/h2&gt;&lt;p&gt;内存可见性：线程对共享变量修改的可见性。当一个线程修改了共享变量的值，其他线程能够立刻得知这个修改。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://cxinxian.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>了解 final 关键字的特性、使用方法以及原理</title>
    <link href="http://cxinxian.github.io/2020/12/12/java/final%20%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://cxinxian.github.io/2020/12/12/java/final%20%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-12-12T13:32:45.000Z</published>
    <updated>2025-02-21T13:13:06.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="final-使用"><a href="#final-使用" class="headerlink" title="final 使用"></a>final 使用</h2><p>final 变量有<strong>成员变量</strong> 和 <strong>本地变量（方法内的局部变量）</strong>，在类成员中 final 经常和static 一起使用，作为类常量使用。其中类常量必须在声明时初始化，final 成员常量可以在构造函数初始化。</p><span id="more"></span><p><strong>修饰类常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修饰基本数据类型变量和引用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] j = <span class="keyword">new</span> &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] k = <span class="keyword">new</span> &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// j = k; 会报错</span></span><br><span class="line">    j[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// i = 2; 会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>final 修饰方法表示该方法不能被子类方法重写</strong>，将方法声明为 final，在编译时就已经静态绑定，不需要在运行是动态绑定。final 方法调用时使用的是 <code>invokespecial</code> 指令。</p><p><strong>final 修饰类</strong></p><p>final 类不能被继承，final 类中的方法默认也会是final 类型，java 中的String 类和 Integer 类都是 final 类型。</p><hr><p><strong>final关键字知识点</strong></p><ol><li>final 成员变量必须在声明时初始化或者在构造器中初始化，否则就会报编译错误。final 变量一旦被初始化后不能再次赋值。</li><li>本地变量必须在声明时赋值。因为没有初始化的过程</li><li>在匿名类中所有变量都必须是final 变量</li><li>final方法不能被重写, final类不能被继承</li><li>接口中声明的所有变量本身是final的。类似于匿名类</li><li>final和abstract这两个关键字是反相关的，final类就不可能是abstract的。</li><li>final方法在编译阶段绑定，称为静态绑定(static binding)。</li><li>将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。</li></ol><p><strong>final 方法的好处</strong></p><ol><li>提高了性能，JVM在常量池中会缓存final变量</li><li>final变量在多线程中并发安全，无需额外的同步开销</li><li>final方法是静态编译的，提高了调用速度</li><li>final类创建的对象是只可读的，在多线程可以安全共享</li></ol><h2 id="final-关键字的最佳实践"><a href="#final-关键字的最佳实践" class="headerlink" title="final 关键字的最佳实践"></a>final 关键字的最佳实践</h2><p>对于 final 修饰的常量、或者一些基本变量来说，值不能变，但是修饰的引用，标识的是这个引用不能被改变，而引用内的变量是可以被改变的。</p><p><strong>关于空白final</strong></p><p>final 修饰变量有三种：静态变量、实例变量和局部变量，分别表示三种类型常量。</p><p>另，final 变量定义时，可以先声明，而不给初值，这种变量称为 final 空白，无论什么情况，编译器都确保空白final 在使用前必须被初始化。</p><p>final 空白在 final 关键字的使用上提供了更大的灵活性，为此，一个类中 final 数据成员就可以实现根据依对象而有所不同。</p><p><strong>final 内存分配</strong></p><p>一般地调用一个函数除了函数本身的执行时间之外，还需要额外的时间去寻找这个函数（类内部有一个函数签名和函数地址的映射表）。所以减少函数调用次数就等于降低了性能消耗。</p><p>final 修饰的函数会被编译器优化，优化的结果减少了函数的调用次数。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;g&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)&#123;</span><br><span class="line">             func(); </span><br><span class="line">        &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//经过编译器优化之后，这个类变成了相当于这样写： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;g&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)  &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;g&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>编译器直接将func 的函数体内嵌到了调用函数的地方，这样就可以节省了很多函数调用。</p><p>不过，函数体太长的话，用 final 可能适得其反，因为经过编译器内嵌之后代码长度增加，于是就是增加了 jvm 解释字节码的时间。</p><p>在使用final修饰方法的时候，编译器会将被final修饰过的方法插入到调用者代码处，提高运行速度和效率，但被final修饰的方法体不能过大，编译器可能会放弃内联，但究竟多大的方法会放弃，还没有测试计算过。</p><p><strong>使用final修饰变量会让变量的值不能被改变吗；</strong></p><blockquote><p>final关键字只能保证变量本身不能被赋与新值，而不能保证变量的内部结构不被修改。</p></blockquote><p><strong>如何保证应用内部数据不被修改</strong></p><blockquote><p>降低访问级别，把引用设为private。这样的话，就解决了引用在外部被修改的不安全性，但也产生了另一个问题，那就是这个引用要被外部使用的。 </p></blockquote><h3 id="final方法的三条规则"><a href="#final方法的三条规则" class="headerlink" title="final方法的三条规则"></a>final方法的三条规则</h3><p>规则1：final修饰的方法不可以被重写。</p><p>规则2：final修饰的方法仅仅是不能重写，但它完全可以被重载。</p><p>规则3：父类中private final方法，子类可以重新定义，这种情况不是重写。</p><h2 id="final-和-jvm-的关系"><a href="#final-和-jvm-的关系" class="headerlink" title="final 和 jvm 的关系"></a>final 和 jvm 的关系</h2><p>对于final 域，编译器和处理器要遵守两个重排序规则：</p><ol><li>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>初次读一个包含 final 域的对象引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</li></ol><p>下面，通过一些示例代码来分别说明这两个规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalExample</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">static</span> FinalExample obj;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalExample</span><span class="params">()</span>&#123;<span class="comment">// 构造函数</span></span><br><span class="line">        i = <span class="number">1</span>;<span class="comment">// 写普通域</span></span><br><span class="line">        j = <span class="number">2</span>;<span class="comment">// 写 final 域</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span>&#123;<span class="comment">// 写线程 A 执行</span></span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">FinalExample</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span>&#123;<span class="comment">// 读线程 B执行</span></span><br><span class="line">        <span class="type">FinalExample</span> <span class="variable">object</span> <span class="operator">=</span> obj;<span class="comment">// 读对象引用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> object.i;<span class="comment">// 读普通域</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> object.j;<span class="comment">// 读 final 域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里假设一个线程 A 执行 writer() 方法，随后另一个线程 B 执行 reader() 方法。下面我们通过这两个线程的交互来说明这两个规则。</p><p><strong>写 final 域的重排序</strong></p><p>写 final 域的重排序规则禁止把 final 域的写重排序到构造函数之外。这个规则的实现包含下面 2 个方面：</p><ul><li>JMM 禁止编译器把 final 域的写重排序到构造函数之外。</li><li>编译器会在 final 域的写之后，构造函数 return 之前，插入一个 <code>StoreSotre</code> 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。</li></ul><p>现在分析 writer() 方法。writer() 方法只包含一行代码：finalExample &#x3D; new FinalExample()。这行代码包含两个步骤：</p><ol><li>构造一个 FinalExample 类型的对象；</li><li>把这个对象的引用赋值给引用变量 obj。</li></ol><p>假设 线程 B读对象引用与读对象成员域之间没有重排序（下面分析需要用到这个假设），下图是一种可能的执行时序：</p><p><img src="/../assets/blogImg/java/java-basics-final-01.jpg" alt="java-basics-final-01"></p><p>在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程B 错误的读取了普通变量 i 初始化之前的值。而写 final 域的操作，被写 final 域的重排序规则 “限定” 在了构造函数之内，读线程 B 正确的读取了 final 变量初始化之后的值。</p><p>写 final 域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而普通域不具有这个保障。以上图为例，在线程 B “看到” 对象引用 obj 时，很可能 obj 对象还没有构造</p><p>完成（对普通域 i 的写操作被重排序到构造函数外，此时初始值 2 还没有写入普通域 i）。</p><hr><p><strong>读 final 域的重排序规则</strong></p><p>读 final 域的重排序规则如下：</p><ul><li>在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意：这个规则仅仅针对处理器）。编译器会在 读 final 域操作的前面插入一个 LoadLoad 屏障。</li></ul><p>初次读对象引用与初次读该对象包含的 final 域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，大多处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如 alpha 处理器），这个规则就是专门用来针对这种处理器。</p><p>reader() 方法包含三个操作：</p><ol><li>初次读引用变量 obj；</li><li>初次读引用变量 obj 指向对象的普通域 j。</li><li>初次读引用变量 obj 指向对象的 final 域 i。</li></ol><p>假设写线程 A 没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，下面是一种可能的执行时序：</p><p><img src="/../assets/blogImg/java/java-basics-final-02.jpg" alt="java-basics-final-02.jpg"></p><p>在上图中，读对象的普通域的操作被处理器重排序到都对象引用之前。读普通域是，该域还没有被写线程 A 写入，这是一个错误的读取操作。而读 final 域的重排序规则会把读对象 final 域的操作 “限定” 在读对象引用之后，此时该 final 域已经被 A 线程初始化过了，这是一个正确的读取操作。</p><p>读取 final 域的重排序规则可以确保：在读一个对象的 final 域之前，一定会先读包含这个 final 域的对象引用。在这个实例程序中，如果该引用不为 null，那么引用对象的 final 域一定已经被 A 线程初始化过了。</p><hr><p><strong>如果 final 域是引用类型</strong></p><p>上面我们看到的 final 域是基础数据类型，下面让我们看看如果 final 域是引用类型，将会有什么效果？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalReferenceExample</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] intArray;                     <span class="comment">//final 是引用类型 </span></span><br><span class="line">    <span class="keyword">static</span> FinalReferenceExample obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalReferenceExample</span> <span class="params">()</span> &#123;        <span class="comment">// 构造函数 </span></span><br><span class="line">        intArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];              <span class="comment">//1</span></span><br><span class="line">        intArray[<span class="number">0</span>] = <span class="number">1</span>;                   <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writerOne</span> <span class="params">()</span> &#123;          <span class="comment">// 写线程 A 执行 </span></span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">FinalReferenceExample</span> ();  <span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writerTwo</span> <span class="params">()</span> &#123;          <span class="comment">// 写线程 B 执行 </span></span><br><span class="line">        obj.intArray[<span class="number">0</span>] = <span class="number">2</span>;                 <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reader</span> <span class="params">()</span> &#123;              <span class="comment">// 读线程 C 执行 </span></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;                    <span class="comment">//5</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> obj.intArray[<span class="number">0</span>];       <span class="comment">//6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 final 域为一个引用类型，它引用一个 int 型的数组对象。对于引用类型，写 final 域的重排序规则对编译器核处理器增加了如下约束：</p><ol><li>在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量这两个操作之间不能重排序。</li></ol><p>对上面的例程，我们假设首先线程 A 执行 writerOne() 方法，执行完后线程 B 执行 writerTow() 方法，执行完后，线程 C 执行reader() 方法。下面是一种可能的执行时序：</p><p><img src="/../assets/blogImg/java/java-basics-final-03.jpg" alt="java-basics-final-03.jpg"></p><p>在上图中，</p><ol><li>是对 final 域的写入</li><li>是对这个 final 域引用的对象的成员域的写入</li><li>是把被构造的对象的引用赋值给某个引用变量。</li></ol><p>这里除了前面提到的 1不能和 3 重排序外，2和3也不能重排序。</p><p>JMM 可以确保线程 C 至少能看到写线程 A 在构造函数中对 final 引用对象的成员域的写入。即 C 至少能看到数组下标 0 的值为 1。而线程 B 对数组元素的写入，读线程 C 可能看得到，也可能看不到。JMM 不保证线程 B 的写入对线程 C 可见，因为写线程 B 和读线程 C 之间存在数据竞争，此时的执行结果不可预知。</p><p>如果想要确保读线程 C 看到写线程 B 对数组元素的写入，写线程 B 和读线程 C 之间需要使用同步原语（lock 或 volatile）来确保内存可见性。</p><p>资料来源</p><p><a href="https://www.cnblogs.com/AliCoder/p/11594960.html">https://www.cnblogs.com/AliCoder/p/11594960.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;final-使用&quot;&gt;&lt;a href=&quot;#final-使用&quot; class=&quot;headerlink&quot; title=&quot;final 使用&quot;&gt;&lt;/a&gt;final 使用&lt;/h2&gt;&lt;p&gt;final 变量有&lt;strong&gt;成员变量&lt;/strong&gt; 和 &lt;strong&gt;本地变量（方法内的局部变量）&lt;/strong&gt;，在类成员中 final 经常和static 一起使用，作为类常量使用。其中类常量必须在声明时初始化，final 成员常量可以在构造函数初始化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://cxinxian.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java CAS</title>
    <link href="http://cxinxian.github.io/2020/05/28/Java-CAS/"/>
    <id>http://cxinxian.github.io/2020/05/28/Java-CAS/</id>
    <published>2020-05-28T14:35:48.000Z</published>
    <updated>2021-06-05T00:48:19.626Z</updated>
    
    <content type="html"><![CDATA[<p>  本文主要是对于Java CAS 的学习整理加深记忆。<br>  有时候，很多知识都停留在印象中的大概了解，或者认识了名称，知道xxx名字概念的存在，<br>  或者曾经在xxx博客中看到过。对于学习这件事，如果只停留在看、思考的过程。即使有所有收获，没有真正的去实践，<br>  相信过不了多久也会遗之脑后。好记性不如烂笔头，至少也应该以文字记录自己的思考、实践过程作为输出，这样学习过程更为完美。</p><span id="more"></span><h3 id="一、什么是CAS？"><a href="#一、什么是CAS？" class="headerlink" title="一、什么是CAS？"></a>一、什么是CAS？</h3><p>CAS 全称是 Compare And Swap 意思是比较 并且 交换。CAS 其实就是乐观锁的一种实现方式，首先假设数据没有被修改，所以每次去操作数据时没有上锁。<br>在 Java 中 java.util.concurrent.atomic包的原子操作类就是使用 CAS 实现的。下面以AtomicInteger的部分代码片段来看，当需要更新变量值时，<br>会检查有没有冲突，如果存在冲突，则会重试，直到更新成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、CAS-的操作是怎样的？"><a href="#二、CAS-的操作是怎样的？" class="headerlink" title="二、CAS 的操作是怎样的？"></a>二、CAS 的操作是怎样的？</h3><p>CAS 的操作中包含有三个操作数，分别是：</p><pre><code>V--内存值A--需要进行比较的原预期值B--拟写入的新值</code></pre><p>更新变量时，会对 V内存值 与 A预期值 进行比较，如果相等 则把 V内存值 修改为 B新值</p><p>举一个栗子：<br>    最初内存值V &#x3D; 10<br>    1. 对线程1 ：来说 A预期值&#x3D;10 ， B拟更新值&#x3D;11；<br>        2. 此时存在线程2 抢先一步修改 V值&#x3D;11<br>        3. 线程1 要提交更新 V值，会比较内存值V 和 预期值B 是否相等，如果相等则提交更新，否则 更新失败，然后重试（也就是自旋）直到成功为止。<br>           因为线程2 抢先更新了 内存值V&#x3D;11, 线程1 进行 内存值V 与 预期值A 比较 发现 V!&#x3D;A  线程1提交修改失败。<br>        4. 线程1 自旋 重新获取到内存值V&#x3D;11，此时预期值A&#x3D;11, 新值B&#x3D;12，因为没有其他线程争抢改变内存值V，比较Compare 相等 更新SWAP 成功。此时内存值V&#x3D;12</p><p>与 <strong>Synchronized</strong> 对比来看，Synchronized属于悲观锁，一开始悲观的认为程序并发很严重，需要严格的防控，避免出现线程不安全问题出现。<br>而 <strong>CAS</strong> 则是乐观锁，乐观认为程序并发并不严重，可以让线程尝试不断的获取内存值比较并且更新。</p><h3 id="三、CAS缺点"><a href="#三、CAS缺点" class="headerlink" title="三、CAS缺点"></a>三、CAS缺点</h3><ul><li><p>CPU 开销大<br>  在并发较高的情况下，多个线程同时尝试争抢更新同一个资源，而又一直不成功，一直在不停的自旋，这样不停的重复，就会给CPU带来非常大的开销。</p></li><li><p>只能保证一个共享变量的原子操作，不能保证代码块的原子性操作。</p></li><li><p>ABA问题<br>比如两个线程   </p><ol><li>线程1 查询V&#x3D;a  与预期值 A&#x3D;a比较</li><li>线程2 查询V&#x3D;a  与预期值 A&#x3D;a 比较 相等 更新V&#x3D;b</li><li>线程2 查询V&#x3D;b  与预期值 A&#x3D;b 比较 相等 更新V&#x3D;a</li><li>线程1 与预期值 A&#x3D;a 比较 相等 更新V&#x3D;b</li></ol><p>从上面2、3步骤来看，V的值经历了 a-&gt;b b-&gt;a 的赋值过程。这就是著名的ABA问题。</p></li></ul><hr><p>  <em><strong>有可能出现的场景：</strong></em><br>    比如后台取款减少金额、转账收款增加金额分别在两个不同的线程。<br>    甲账户余额100，提现取款金额50<br>    线程1 内存值V&#x3D;100   预期值A&#x3D;100   拟更新值B&#x3D;50<br>    假设甲误操作多了一次，重复点击提现，又发起了一次提现请求 后台新增加一个 线程2<br>    线程2 内存值V&#x3D;100   预期值A&#x3D;100   拟更新值B&#x3D;50<br>    由于某种原因 线程2 被阻塞block 了，线程1 更新内存值V&#x3D;50 此时 乙向甲的账号转账 50<br>    线程3 内存值V&#x3D;50    预期值A&#x3D;50    拟更新值B&#x3D;100<br>    线程3执行完成后， 内存值V&#x3D;100， 此时线程2从block 中恢复过来，比较 V&#x3D;A 然后更新内存值V&#x3D;50<br>    最后甲的账户余额 &#x3D; (100-50+50-50)  而实际上应该是 &#x3D;(100-50+50)</p><hr><p>  看到一个很有意思的解答是，A的女朋友出轨了，然后又回到A的身边，那么这个女朋友还是A的女朋友吗？哈哈哈。</p><p>  模拟出现ABA代码如下<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span>&#123;</span><br><span class="line">      <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">10</span>);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              atomicInteger.compareAndSet(<span class="number">10</span>,<span class="number">11</span>);</span><br><span class="line">              atomicInteger.compareAndSet(<span class="number">11</span>,<span class="number">10</span>);</span><br><span class="line">              System.out.println(<span class="string">&quot;t2 atomicInteger value is :&quot;</span>+atomicInteger.get());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">              atomicInteger.compareAndSet(<span class="number">10</span>,<span class="number">11</span>);</span><br><span class="line">              System.out.println(<span class="string">&quot;t2 atomicInteger value is :&quot;</span>+atomicInteger.get());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><strong>那么如何避免出现ABA问题呢？</strong><br>在java.util.concurrent.atomic包下，提供了带有版本和标记的的原子引用类 <strong>AtomicStampedReference、AtomicMarkableReference</strong><br>可以通过版本控制来确保CAS操作中内存值的正确性。<br>使用如下:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span>&#123;</span><br><span class="line">    AtomicStampedReference&lt;Integer&gt; atomicInteger = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;Integer&gt;(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">10</span>,<span class="number">11</span>,atomicInteger.getStamp(),atomicInteger.getStamp()+<span class="number">1</span>);</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">11</span>,<span class="number">10</span>,atomicInteger.getStamp(),atomicInteger.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 atomicInteger value is :&quot;</span>+atomicInteger.getReference());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicInteger.getStamp();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 compareAndSet:&quot;</span>+atomicInteger.compareAndSet(<span class="number">10</span>,<span class="number">11</span>,stamp,stamp+<span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 atomicInteger value is :&quot;</span>+atomicInteger.getReference());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="四、CAS与Synchronized的使用情景："><a href="#四、CAS与Synchronized的使用情景：" class="headerlink" title="四、CAS与Synchronized的使用情景："></a>四、CAS与Synchronized的使用情景：</h3><ol><li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；<br>而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li><li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li></ol><p>想要获取更多关于CAS的信息，推荐 <a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2">https://zh.wikipedia.org/wiki/%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;  本文主要是对于Java CAS 的学习整理加深记忆。&lt;br&gt;  有时候，很多知识都停留在印象中的大概了解，或者认识了名称，知道xxx名字概念的存在，&lt;br&gt;  或者曾经在xxx博客中看到过。对于学习这件事，如果只停留在看、思考的过程。即使有所有收获，没有真正的去实践，&lt;br&gt;  相信过不了多久也会遗之脑后。好记性不如烂笔头，至少也应该以文字记录自己的思考、实践过程作为输出，这样学习过程更为完美。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://cxinxian.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>jstat 的使用</title>
    <link href="http://cxinxian.github.io/2020/05/25/jvm-chapter-1/"/>
    <id>http://cxinxian.github.io/2020/05/25/jvm-chapter-1/</id>
    <published>2020-05-25T13:24:44.000Z</published>
    <updated>2025-02-21T14:08:52.297Z</updated>
    
    <content type="html"><![CDATA[<p>  在JVM 分析中，jstat 是一个不可缺少的工具。全称是“Java Virtual Machine statistics monitoring tool”，位于java的bin<br>  目录下，主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。<br>  是一款轻量级的jvm工具。</p><span id="more"></span><p>  如果配置好JDK 环境后，在命令行中输入<code>jsata</code> 会显示出如下的语法结构。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">invalid argument count</span><br><span class="line">Usage: jstat -help|-options</span><br><span class="line">       jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br></pre></td></tr></table></figure></p><h3 id="1-参数解析"><a href="#1-参数解析" class="headerlink" title="1.参数解析"></a>1.参数解析</h3><ul><li>-t： 可以在打印的列加上Timestamp列，用于显示系统运行的时间；</li><li>-h： 可以在周期性数据数据的时候，可以在指定输出多少行以后输出一次表头；</li><li>vmid： Virtual Machine ID（ 进程的 pid）；</li><li>interval： 采样时间间隔，单位为毫秒 （可指定单位，比如1秒：<code>jstat -gc 1000 1s</code>）；</li><li>count： 采样次数，用于指定输出多少次记录（如果指定了 interval 不指定count 则会一直打印下去）。</li></ul><h3 id="2-options-参数："><a href="#2-options-参数：" class="headerlink" title="2.options 参数："></a>2.options 参数：</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jstat -option</span><br><span class="line">-class                查看class loader 类装载和数量、总空间以及类装载耗费时间等数据</span><br><span class="line">-compiler             查看JIT编译器编译过的方法和耗时信息信息</span><br><span class="line">-gc                   查看Java 堆状况，Eden区、两个survivor区、老年代、元空间、已用空间、gc耗时等信息</span><br><span class="line">-gccapacity           与 -gc 作用基本一样，查看不同的generations（新生代、老生代、永久代）相应的heap容量信息，</span><br><span class="line">                      主要关注各区使用到的最大、最小空间</span><br><span class="line">-gccause              与gcutil作用一样，查看gc的情况，额外输出上次引起gc的原因</span><br><span class="line">-gcmetacapacity       显示 metaspace(元空间)的大小</span><br><span class="line">-gcnew                查看新生代的gc情况</span><br><span class="line">-gcnewcapacity        查看新生代gc时heap的容量信息</span><br><span class="line">-gcold                查看老生代的gc情况</span><br><span class="line">-gcoldcapacity        查看老生代gc时heap容量信息</span><br><span class="line">-gcutil               查看heap的gc情况，主要关注已使用空间占总空间的百分比</span><br><span class="line">-printcompilation     查看JIT编译器编译的方法信息</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-options-参数解析"><a href="#3-options-参数解析" class="headerlink" title="3.options 参数解析"></a>3.options 参数解析</h3><ul><li><p><strong>jstat -class &lt;pid&gt;</strong><br>&lt;pid&gt; 代表进程id 可通过 jps 查看 比如<code>jps -l</code><br>监视类装载、卸载数量、总空间以及耗费的时间</p><ul><li>Loaded        : 加载class的数量</li><li>Bytes         : class字节大小</li><li>Unloaded      : 未加载class的数量</li><li>Bytes         : 未加载class的字节大小</li><li>Time          : 加载时间</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -class 5644</span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time</span><br><span class="line">69059 133660.9     4974  6488.3     735.78</span><br></pre></td></tr></table></figure></li><li><p><strong>jstat -compiler &lt;pid&gt;</strong><br>输出JIT编译过的方法数量耗时等</p><ul><li>Compiled              编译数量</li><li>Failed                编译失败数量</li><li>Invalid               无效数量</li><li>Time                  编译耗时</li><li>FailedType            失败类型</li><li>FailedMethod          失败方法的全限定名</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -compiler 5644</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">77919     12       0   698.76          1 com/intellij/psi/impl/JavaClassSupersImpl getSuperClassSubstitutor</span><br></pre></td></tr></table></figure></li><li><p><strong><span id="mark_gc">jstat -gc &lt;pid&gt;</span></strong><br>垃圾回收堆的行为统计，常见用用法比如<code>jstat -gc h3 5644 1s</code> 表示意思是：<br>每隔1s 输出一次进程id为5644 的gc 信息，h3：每隔三行输出一次title</p></li></ul><table><thead><tr><th>type</th><th>解析</th></tr></thead><tbody><tr><td>S0C</td><td>survivor0区的总容量</td></tr><tr><td>S1C</td><td>survivor1区的总容量</td></tr><tr><td>S0U</td><td>survivor0区已使用的容量</td></tr><tr><td>S1U</td><td>survivor1区已使用的容量</td></tr><tr><td>EC</td><td>Eden区(新生代)的总容量</td></tr><tr><td>EU</td><td>Eden区的已使用总容量</td></tr><tr><td>OC</td><td>olden去的总容量</td></tr><tr><td>OU</td><td>olden去已使用的容量</td></tr><tr><td>MC</td><td>metaspace(元空间)的总容量</td></tr><tr><td>MU</td><td>metaspace(元空间)已使用的容量</td></tr><tr><td>CCSC</td><td>压缩类空间的总容量</td></tr><tr><td>CCSU</td><td>压缩类空间已使用的容量</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中gc次数</td></tr><tr><td>YGCT</td><td>从应用程序启动到采样时年轻代中gc耗时(s)</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时old代(全gc)gc次数</td></tr><tr><td>FGCT</td><td>从应用程序启动到采样时old代(全gc)gc所用时间(s)</td></tr><tr><td>GCT</td><td>从应用程序启动到采样时gc用的总时间(s)</td></tr></tbody></table><p>  作用效果如下：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc -h3 5644 1s</span><br><span class="line">S0C    S1C    S0U    S1U     EC       EU       OC       OU       MC     MU    CCSC   CCSU   YGC    YGCT   FGC    FGCT  GCT</span><br><span class="line">20800.0 20800.0 14749.4 0.0  166720.0 164712.4 416376.0 266881.8  391032.0 361566.7 52148.0 46069.5  1012  15.257  38   7.222  22.478</span><br><span class="line">20800.0 20800.0  0.0  3788.4 166720.0  2843.0  416376.0 266881.8  391032.0 361606.6 52148.0 46078.1  1013  15.264  38   7.222  22.486</span><br><span class="line">20800.0 20800.0  0.0  3788.4 166720.0  7655.8  416376.0 266881.8  391032.0 361606.6 52148.0 46078.1  1013  15.264  38   7.222  22.486</span><br><span class="line">S0C    S1C    S0U    S1U     EC       EU       OC       OU       MC     MU    CCSC   CCSU   YGC    YGCT   FGC    FGCT  GCT</span><br><span class="line">20800.0 20800.0  0.0  3788.4 166720.0 12492.6  416376.0 266881.8  391032.0 361606.6 52148.0 46078.1  1013  15.264  38   7.222  22.486</span><br><span class="line">20800.0 20800.0  0.0  3788.4 166720.0 17402.9  416376.0 266881.8  391032.0 361606.6 52148.0 46078.1  1013  15.264  38   7.222  22.486</span><br><span class="line">20800.0 20800.0  0.0  3788.4 166720.0 22221.0  416376.0 266881.8  391032.0 361606.6 52148.0 46078.1  1013  15.264  38   7.222  22.486</span><br><span class="line">S0C    S1C    S0U    S1U     EC       EU       OC       OU       MC     MU    CCSC   CCSU   YGC    YGCT   FGC    FGCT  GCT</span><br></pre></td></tr></table></figure></p><ul><li><p><strong><span id="mark_gccapacity">jstat -gccapacity &lt;pid&gt;</span></strong><br>输出显示 新生代、老年代、元空间、压缩类空间的大小容量</p><ul><li>NGCMN     <em>：新生代最小容量</em></li><li>NGCMX     <em>：新生代最大容量</em></li><li>NGC       <em>：当前新生代容量</em></li><li>S0C       <em>：第一个幸存区大小</em></li><li>S1C       <em>：第二个幸存区的大小</em></li><li>EC        <em>：伊甸园区的大小</em></li><li>OGCMN     <em>：老年代最小容量</em></li><li>OGCMX     <em>：老年代最大容量</em></li><li>OGC       <em>：老年代容量大小</em></li><li>OC        <em>；当前老年代空间容量大小</em></li><li>MCMN      <em>；最小元数据容量</em></li><li>MCMX      <em>：最大元数据容量</em></li><li>MC        <em>：当前元数据空间大小</em></li><li>CCSMN     <em>：最小压缩类空间大小</em></li><li>CCSMX     <em>：最大压缩类空间大小</em></li><li>CCSC      <em>：当前压缩类空间大小</em></li><li>YGC       <em>：年轻代gc次数</em></li><li>FGC       <em>：老年代GC次数</em></li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gccapacity 5960</span><br><span class="line"> NGCMN    NGCMX     NGC     S0C   S1C      EC     OGCMN    OGCMX     OGC    OC    MCMN     MCMX     MC   CCSMN  CCSMX  CCSC    YGC    FGC</span><br><span class="line"> 43648.0 256000.0 165056.0 16448.0 16448.0 132160.0  87424.0  512000.0  329960.0  329960.0  0.0 1320960.0 313844.0 0.0 1048576.0  42800.0    344    21</span><br></pre></td></tr></table></figure></li><li><p><strong>jstat -gcutil &lt;pid&gt;</strong><br> 输出显示 gc 新生代，老年代、元空间、压缩类空间已使用空间占总空间的百分比</p><ul><li>S0     <em>：新生代survior space 0区已使用空间容量占比</em></li><li>S1     <em>：新生代survior space 1区已使用空间容量占比</em></li><li>E      <em>：新生代已使用空间容量占比</em></li><li>O      <em>：老年代已使用空间容量占比</em></li><li>M      <em>：元空间已使用空间容量占比</em></li><li>CCS    <em>：压缩类空间已使用空间容量占比</em></li><li>YGC    <em>：从应用启动到采样发生Yang GC 次数</em></li><li>YGCT   <em>：从应用启动到采样发生Yang GC 次数耗时</em></li><li>FGC    <em>：从应用启动到采样发生Full GC 次数</em></li><li>FGCT   <em>：从应用启动到采样发生Yang GC 次数耗时</em></li><li>GCT    <em>：从应用启动到采样，发生GC 总耗时</em></li></ul></li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil 5960 1s 5</span><br><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">66.74   0.00  98.54  52.43  92.63  88.42    470    5.920    27    4.296   10.216</span><br><span class="line">66.74   0.00 100.00  52.43  92.63  88.42    470    5.920    27    4.296   10.216</span><br><span class="line">0.00  61.97   3.62  52.43  92.64  88.43    471    5.927    27    4.296   10.224</span><br></pre></td></tr></table></figure><p>分析：<br>1、从第二行到第三行之间发生了一次新生代的gc，耗时为0.008s，新生代的使用率由100% 下降到 3.62%，其中新生代中的对象没有提升到老生代，而压缩类空间则由88.42% 增加到88.43%。<br>2、幸存区s0 的使用率由 66.74% 下降到 61.97%</p><ul><li><strong>jstat -gccause &lt;pid&gt;</strong><br>作用于 <code>-gcutil</code> 一样，只是比它多两个统计输出数据，分别是<ul><li>LGCC  <em>：最近垃圾回收原因</em></li><li>GCC   <em>：当前垃圾回收原因</em></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gccause 5960</span><br><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC</span><br><span class="line">26.00   0.00  67.43  75.54  93.04  88.84    428    5.133    23    1.580    6.713 Allocation Failure   No GC</span><br></pre></td></tr></table></figure><ul><li><p><strong>jstat -gcmetacapacity &lt;pid&gt;</strong><br>显示对应pid 的元空间的容量信息，相对 <code>jstat -gccapacity &lt;pid&gt;</code> 来说，<br><code>jstat -gcmetacapacity &lt;pid&gt;</code> 只是关注于元空间的容量信息，对应的title 解析可参照上面 <a href="#mark_gccapacity">jstat -gccapacity <pid></a>中的解析。<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcmetacapacity 5960</span><br><span class="line"> MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT</span><br><span class="line"> 0.0  1347584.0   343668.0        0.0  1048576.0    46256.0   450    26    3.647    9.224</span><br></pre></td></tr></table></figure></li><li><p><strong>jstat -gcnew &lt;pid&gt;</strong><br>查看新生代gc情况，相关字段解析上面<a href="#mark_gc">jstat -gc</a> 已有解析，而其中差异的字段解析如下：</p><ul><li>S0U   <em>： survivor space 0 utilization</em></li><li>TT    <em>： tenuring threshold 阀值， 用于控制对象在新生代存活的最大次数</em></li><li>MTT   <em>：对象在新生代存活的最大次数</em></li><li>DSS   <em>：desired survivor Size 期望的幸存区大小</em></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcnew 5960</span><br><span class="line">S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</span><br><span class="line">16448.0 16448.0    0.0 1444.8  6   6 8224.0 132160.0 114328.5    457    5.657</span><br></pre></td></tr></table></figure></li><li><p><strong>jstat -gcoldcapacity &lt;pid&gt;</strong><br>查看老年代空间容量信息</p><ul><li>OGC： old generation capacity 老生代空间大小(kb)</li><li>OGCMN：最小OGC</li><li>OGCMX： 最大OGC</li><li>OC： old space capacity</li><li>FGC： Full  GC</li><li>OGC： old generation capacity</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcoldcapacity -h3 12628 1s</span><br><span class="line">OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</span><br><span class="line">87552.0    478208.0     87552.0     87552.0     3     0    0.000    0.012</span><br><span class="line">87552.0    478208.0     87552.0     87552.0     3     0    0.000    0.012</span><br><span class="line">87552.0    478208.0     87552.0     87552.0     3     0    0.000    0.012</span><br></pre></td></tr></table></figure><p>分析：<br>采样期间，没有经历gc,老年代容量OGC：87552 kb， 当前老年代空间容量：87552 kb，而老年代最大容量为：478208kb<br>说明还有上升空间</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;  在JVM 分析中，jstat 是一个不可缺少的工具。全称是“Java Virtual Machine statistics monitoring tool”，位于java的bin&lt;br&gt;  目录下，主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。&lt;br&gt;  是一款轻量级的jvm工具。&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://cxinxian.github.io/tags/java/"/>
    
    <category term="jvm" scheme="http://cxinxian.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized 学习笔记</title>
    <link href="http://cxinxian.github.io/2020/03/01/java/Synchronized/"/>
    <id>http://cxinxian.github.io/2020/03/01/java/Synchronized/</id>
    <published>2020-03-01T09:33:25.000Z</published>
    <updated>2025-02-21T13:13:10.633Z</updated>
    
    <content type="html"><![CDATA[<p>在并发编程中<strong>synchronized</strong>是不可或缺的关键字，在Java SE 1.6之前都是重量级锁，后来为了减少获得锁和释放锁带来的性能消耗引入偏向锁和轻量级锁，以及锁的存储结构和升级过程。</p><span id="more"></span><h4 id="一、synchronized-加锁的三种方式"><a href="#一、synchronized-加锁的三种方式" class="headerlink" title="一、synchronized 加锁的三种方式"></a>一、synchronized 加锁的三种方式</h4><ol><li>修饰实例方法，作用于当前实例，进入同步代码前需要获得当前实例锁</li><li>修饰静态类，作用于当前类对象加锁，进入同步前要获得当前类对象的锁</li><li>修饰代码块，指定实例对象作为锁对象，对给定的锁对象加锁，进入同步代码块前要获得给的的对象锁</li></ol><h4 id="二、synchronized括号后的对象"><a href="#二、synchronized括号后的对象" class="headerlink" title="二、synchronized括号后的对象"></a>二、synchronized括号后的对象</h4><p><strong>synchronized</strong> 括号后面的对象是一把锁，在Java中任意一个对象都可以成为锁。简单来说，我们把Object比喻是一个key，拥有这个Key的线程才能执行这个方法。拿到key 以后在执行方法的过程中，这个key是随身携带而且唯一，如果其他线程想访问当前方法或者代码块，因为没有key所以不能访问只能在门口等着，等之前的线程释放key。因此<strong>synchronized</strong>锁定的对象必须为同一个对象，如果是不同的对象，意味着不同的房间钥匙，对于访问者没有任何影响。</p><h4 id="三、synchronized-的字节指令"><a href="#三、synchronized-的字节指令" class="headerlink" title="三、synchronized 的字节指令"></a>三、synchronized 的字节指令</h4><p>使用 <code>javap -v</code> 命令可以查看对应代码的字节指令，其中同步代码块的实现使用了 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，对应地隐式执行Lock 和 UnLock 操作，用于保证原子性。其中<code>monitorenter</code> 指令位于同步代码块的开始位置，而<code>monitorexit</code> 指令则位于同步代码块的结束位置，它们是成对存在对应的。</p><p>两个指令是排他的，本质是对一个对象的监视器（monitor）的获取与释放。线程代码执行到 <code>monitorenter</code> 指令时，会尝试获取对应的monitor所有权，也就是尝试获取对象的锁，而 <code>monitorexit</code> 就是释放monitor 的所有权。</p><h4 id="四、对象在内存中的布局"><a href="#四、对象在内存中的布局" class="headerlink" title="四、对象在内存中的布局"></a>四、对象在内存中的布局</h4><p>在Hotspot 虚拟机中，对象在内存中的存储布局分为三部分：</p><ol><li>对象头（Header）,包含对象标记和类元信息，是实现<strong>Synchronized</strong>的锁对象基础。synchronized 使用的锁对象存储在Java对象头里，它是轻量级锁和偏向锁的关键。</li><li>实例数据（Instance Data)，</li><li>对齐填充（Padding)</li></ol><h4 id="五、Mark-Word"><a href="#五、Mark-Word" class="headerlink" title="五、Mark Word"></a>五、Mark Word</h4><p>Mark Word（对象标记）用于存储对象自身运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标记、线程持有的锁、偏向锁ID、偏向时间戳等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4个字节，也就是32bit)</p><p><img src="/../assets/blogImg/java/synchronized.png" alt="synchronized"></p><h4 id="六、Monitor"><a href="#六、Monitor" class="headerlink" title="六、Monitor"></a>六、Monitor</h4><ol><li>Monitor 是一种用来实现同步的工具</li><li>与每个Java对象相关联，所有的Java对象天生携带monitor</li><li>Monitor是实现 Synchronized(内置锁)的基础</li></ol><p>对象的监视器（monitor）有ObjectMonitor对象实现（C++)</p><h4 id="七、锁升级的过程"><a href="#七、锁升级的过程" class="headerlink" title="七、锁升级的过程"></a>七、锁升级的过程</h4><p>锁概念：</p><ol><li><p>**自旋锁（CAS）：**让不满足条件的线程等待一会看能不能获得锁，通过占用处理器的时间来避免线程切换带来的开销。自旋等待的时间或次数是有一个限度的，如果自旋超过了定义的时间仍然没有获取到锁，则该线程应该被挂起。在 JDK1.6 之后，引入了自适应自旋锁，自适应意味着自旋的次数不是固定不变的，而是根据前一次在同一个锁上自旋的时间以及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p></li><li><p><strong>偏向锁</strong>：大多数情况下，锁总是由同一个线程多次获得。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，偏向锁是一个可重入的锁。如果锁对象头的 <strong>Mark Word</strong> 里存储着指向当前线程的偏向锁，无需重新进行 CAS 操作来加锁和解锁。当有其他线程尝试竞争偏向锁时，持有偏向锁的线程（不处于活动状态）才会释放锁。偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定进而升级为轻量级锁。</p></li><li><p><strong>轻量级锁</strong>：减少无实际竞争情况下，使用重量级锁产生的性能消耗。JVM 会先在当前线程的栈帧中创建用于存储锁记录的空间 <strong>LockRecord</strong>，将对象头中的 Mark Word 复制到 <strong>LockRecord</strong> 中，并将 <strong>LockRecord</strong> 中的 <strong>Owner</strong> 指针指向锁对象。然后线程会尝试使用 CAS 将对象头中的 <strong>Mark Word</strong> 替换为指向锁记录的指针，成功则当前线程获取到锁，失败则表示其他线程竞争锁，当前线程则会尝试使用自旋的方式获取锁。自旋超过一定的次数，或者线程间竞争激烈，则锁会膨胀升级为重量级锁。</p></li><li><p><strong>重量级锁</strong>：通过对象内部监视器（monitor）实现，其中 monitor 的本质是依赖于底层操作系统的 <strong>Mutex Lock</strong> 实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。线程竞争不用自旋，不会消耗 CPU。但是线程会进入阻塞等待被其他线程唤醒，响应时间缓慢。</p><p><img src="/../assets/blogImg/java/synchronized2.png" alt="synchronized"></p></li></ol><h4 id="Synchronized-结合-Java-Object-对象中的-wait-notify-notifyAll"><a href="#Synchronized-结合-Java-Object-对象中的-wait-notify-notifyAll" class="headerlink" title="Synchronized 结合 Java Object 对象中的 wait,notify,notifyAll"></a>Synchronized 结合 Java Object 对象中的 wait,notify,notifyAll</h4><p>一般被 synchronized 阻塞的线程的唤醒时机取决于获得锁线什么时候执行完同步代码块并且释放锁。那么要如何做到显式控制呢？这时我们需要借助一个信号机制：Object 对象中，提供了 wait&#x2F;notify&#x2F;notifyall，可以控制线程的状态。</p><h5 id="wait-notify-notifyall-基本概念"><a href="#wait-notify-notifyall-基本概念" class="headerlink" title="wait&#x2F;notify&#x2F;notifyall 基本概念"></a>wait&#x2F;notify&#x2F;notifyall 基本概念</h5><p><strong>wait</strong>：表示持有对象锁的线程 A 准备释放对象锁权限，释放 cpu 资源并进入等待状态。</p><p><strong>notify</strong>：表示持有对象锁的线程 A 准备释放对象锁权限，通知 jvm 唤醒某个竞争该对象锁的线程 X。线程 A synchronized 代码执行结束并且释放了锁之后，线程 X 直接获得对象锁权限，其他竞争线程继续等待（即使线程 X 同步完毕，释放锁对象，其他竞争线程仍然等待，直至有新的 notify，notifyAll 被调用）。</p><p><strong>notifyAll</strong>：notifyAll 和 notify 的区别在于，notifyAll 会唤醒所有竞争同一个对象锁的所有线程，当已经获得锁的线程 A 释放锁之后，所有被唤醒的线程都有可能获得对象锁权限。</p><blockquote><p>面试题：wait&#x2F;notify&#x2F;notifyAll 为什么需要在 synchronized 里面？</p><ol><li>wait 方法的语义有两个，一个是释放当前的对象锁、另一个是使得当前线程进入阻塞队列，而这些操作都和监视器是相关，所以 wait 必须要获得一个监视器锁</li><li>对于 notify 来说也是一样，它是唤醒一个线程，既然要去唤醒，首先得知道它在哪里？所以就必须要找到这个对象获取到这个对象的锁，然后到这个对象的等待队列中去唤醒一个线程。</li><li>每个对象可能有多个线程调用 wait 方法，所以需要有一个等待队列存储这些阻塞线程。这个等待队列应该与这个对象绑定，在调用 wait 和notify 方法时也会存在线程安全问题所以需要一个锁来保证线程安全。</li></ol></blockquote><h4 id="wait-notify-的基本原理"><a href="#wait-notify-的基本原理" class="headerlink" title="wait&#x2F;notify 的基本原理"></a>wait&#x2F;notify 的基本原理</h4><p><img src="/../assets/blogImg/java/synchronized3.png" alt="synchronized3"></p><p>资料：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzM2OTQ5Mg==&mid=2247484280&idx=1&sn=8de305338c5ab348c3e2a784084e4306&chksm=eb660483dc118d95e9bcde15a01103f818ed2fd399989f36dc2d57740a305e91cf986d4f5a64&scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzI3NzM2OTQ5Mg==&amp;mid=2247484280&amp;idx=1&amp;sn=8de305338c5ab348c3e2a784084e4306&amp;chksm=eb660483dc118d95e9bcde15a01103f818ed2fd399989f36dc2d57740a305e91cf986d4f5a64&amp;scene=21#wechat_redirect</a></p><p><a href="https://blog.csdn.net/baidu_38083619/article/details/82527461">https://blog.csdn.net/baidu_38083619/article/details/82527461</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在并发编程中&lt;strong&gt;synchronized&lt;/strong&gt;是不可或缺的关键字，在Java SE 1.6之前都是重量级锁，后来为了减少获得锁和释放锁带来的性能消耗引入偏向锁和轻量级锁，以及锁的存储结构和升级过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://cxinxian.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android 系统的启动</title>
    <link href="http://cxinxian.github.io/2019/10/06/Android/framework/Android%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"/>
    <id>http://cxinxian.github.io/2019/10/06/Android/framework/Android%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/</id>
    <published>2019-10-06T07:05:11.000Z</published>
    <updated>2025-02-22T07:50:54.053Z</updated>
    
    <content type="html"><![CDATA[<p>对于问题：说一说Android 系统的启动：</p><p>这道题的考察内容包括：</p><ul><li>Android 有哪些主要的系统进程？</li><li>这些系统进程是怎么启动的？</li><li>进程启动之后主要做了些什么事？</li></ul><span id="more"></span><h3 id="一、系统进程："><a href="#一、系统进程：" class="headerlink" title="一、系统进程："></a>一、系统进程：</h3><p>通过系统配置文件<code>init.rc</code>可以看到系统进程都有哪些。</p><blockquote><p>service zygote &#x2F;system&#x2F;bin&#x2F;app_process ..</p><p>service servicemanager &#x2F;system&#x2F;bin&#x2F;servicemanager …</p><p>service surfaceflinger &#x2F;system&#x2F;bin&#x2F;surfaceflinger ..</p><p>service media &#x2F;system&#x2F;bin&#x2F;mediaserver ..</p><p>……</p></blockquote><h3 id="二、Zygote-是怎么启动的？"><a href="#二、Zygote-是怎么启动的？" class="headerlink" title="二、Zygote 是怎么启动的？"></a>二、Zygote 是怎么启动的？</h3><ul><li>init 进程fork出zygote进程</li><li>启动虚拟机，注册 jni 函数</li><li>预加载系统资源</li><li>启动SystemServer</li><li>进入 Socket Loop</li></ul><h3 id="三、SystemServer-是怎么启动的？"><a href="#三、SystemServer-是怎么启动的？" class="headerlink" title="三、SystemServer 是怎么启动的？"></a>三、SystemServer 是怎么启动的？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">startSystemServer</span><span class="params">(...)</span>&#123;</span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="string">&quot;com.android.server.SystemServer&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> Zygote.forkSystemServer(...);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        handleSystemServerProcess(parseArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">handleSystemServerProcess</span><span class="params">(Arguments parsedArgs)</span>&#123;</span><br><span class="line">    RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,parsedArgs.remainingArgs, ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span>  <span class="title function_">zygoteInit</span><span class="params">(String[] argv, ...)</span>&#123;</span><br><span class="line">    commonInit(); <span class="comment">// 常规初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主要用于启动 binder 机制，并且启动binder 线程</span></span><br><span class="line">    <span class="comment">// 因为接下来 SystemServer很多系统服务要跟别的进程通信，比如别的应用进程，SystemManager 通信</span></span><br><span class="line">    nativeZygoteInit(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主要调用 Java 类 SystemServer 的main 函数</span></span><br><span class="line">    applicationInit(argv, ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要调用 Java 类的入口函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">applicationInit</span><span class="params">(...)</span>&#123;</span><br><span class="line">    invoikeStaticMain(args,...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SystemServer</span>().run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SystemServer 的 run 函数主要代码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1、 为主线创建 looper</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    <span class="comment">// 2、加载共享库</span></span><br><span class="line">    System.loadLibrary(<span class="string">&quot;android_servers&quot;</span>);</span><br><span class="line">    <span class="comment">// 3、创建上下文</span></span><br><span class="line">    createSystemContext();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    startBootstrapServices();</span><br><span class="line">    startCoreServices();</span><br><span class="line">    startOtherServices();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 loop 循环</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">virtual <span class="keyword">void</span> <span class="title function_">onZygoteInit</span><span class="params">()</span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    proc -&gt; startThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统服务是怎么启动的?</p><ul><li><p>系统服务怎么发布，让应用程序可见?</p><ul><li>通过 <code>publishBinderService(name,IBinder) </code>方法发布，最终调用的为：<code>ServiceMannager.addService(name,service, allowlsolated)</code>，也就是最终把要发布系统服务的binder注册到 ServiceManager 里面</li></ul></li><li><p>系统服务跑在什么线程?</p><ul><li><p>工作线程：</p><p>1、有的线程跑在其独有的工作线程中，如 AMS、PMS、PackageManagerService</p><p> 2、有的跑在大家共用的工作线程，如 DisplayThread、FgThread、IoThread、UiThread</p></li><li><p>binder 线程</p></li></ul></li></ul><p>怎么解决系统服务启动的互相依赖？</p><ul><li>分批启动：基础的服务先启动如 AMS、PMS、PKMS，很多Service都依赖这几个Server, 所以先启动，上层的Service 可以放后边</li><li>分阶段启动：分成不同的阶段启动，没到一个阶段，就通知当前已经启动的Server, 告诉它们现在什么阶段，那些资源可以用，然后做一些这个阶段可以做的初始化。</li></ul><h3 id="桌面启动"><a href="#桌面启动" class="headerlink" title="桌面启动"></a>桌面启动</h3><p>在 AMS 服务就绪时，会调 systemReady 函数，在函数里面会去调 startHomeActivityLocked 函数启动桌面。桌面可以看做一个系统级应用，启动桌面的Activity  Launcher.java 类， 在 Launcher 类的 onCreate 中会启动 LoaderTask , LoaderTask 会去先 PackageManagerService 查询所有已经安装的应用，最后把查询到的应用以应用图标显示到桌面。</p><p><img src="/../../assets/blogImg/Android/framework/android-start/android-start-01.png" alt="android-start-01"></p><p>总结：</p><p>对于问题： 说说Android 系统的启动流程？</p><p>可以分为以下三个小问题：</p><ul><li>zygote 是怎么启动的? 进程启动之后又干了什么，之后怎么进入socket loop 循环，等着创建应用进程</li><li>systemServer 是怎么启动的？启动之后又做了什么事。</li><li>系统服务是怎么启动的？桌面怎么启动的。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于问题：说一说Android 系统的启动：&lt;/p&gt;
&lt;p&gt;这道题的考察内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Android 有哪些主要的系统进程？&lt;/li&gt;
&lt;li&gt;这些系统进程是怎么启动的？&lt;/li&gt;
&lt;li&gt;进程启动之后主要做了些什么事？&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://cxinxian.github.io/tags/Android/"/>
    
    <category term="Android framework" scheme="http://cxinxian.github.io/tags/Android-framework/"/>
    
  </entry>
  
  <entry>
    <title>关于 mmap</title>
    <link href="http://cxinxian.github.io/2019/10/03/Android/framework/mmap/"/>
    <id>http://cxinxian.github.io/2019/10/03/Android/framework/mmap/</id>
    <published>2019-10-03T09:23:41.000Z</published>
    <updated>2025-02-22T07:50:51.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mmap-的基础概念"><a href="#mmap-的基础概念" class="headerlink" title="mmap 的基础概念"></a>mmap 的基础概念</h2><p>mmap 是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用 read，write 等系统调用函数。相反，内核空间这段区域的修改也直接反映用户空间，从而实现不同进程间的文件共享。如下图所示：</p><span id="more"></span><p><img src="/../../assets/blogImg/Android/framework/mmap/mmap-01.png" alt="mmap-01"></p><p>由上图可以看出，进程的虚拟地址空间，由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。图中的 text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。而为内存映射服务的地址空间处在堆栈之间的空余部分。</p><p>linux 内核使用 vm_area_struct 结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个 vm_area_struct 结构来分别表示不同类型的虚拟内存区域。各个 vm_area_struct 结构使用链表或者树形结构链接，方便进程快速访问，如下图：</p><p><img src="/../../assets/blogImg/Android/framework/mmap/mmap-02.png" alt="mmap-02"></p><p>vm_area_struct 结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个 vm_ops 指针，其内部可引出所有针对这个区域可以使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作需要用的信息，都可以从 vm_area_struct 中获得。mmap 函数就是要创建一个新的 vm_area_struct 结构，并将其与文件的物理磁盘地址相连。</p><h2 id="mmap-内存映射原理"><a href="#mmap-内存映射原理" class="headerlink" title="mmap 内存映射原理"></a>mmap 内存映射原理</h2><p>mmap 内存映射的实现过程，总的来说可以分为三个阶段：</p><h3 id="一、进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域"><a href="#一、进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域" class="headerlink" title="一、进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域"></a>一、进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</h3><p>1、进程在用户空间调用库函数 mmap，原型：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset)</p><p>2、在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续虚拟地址</p><p>3、为此虚拟区分配一个 vm_area_struct 结构，接着对这个结构的各个域进行初始化</p><p>4、将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中</p><h3 id="二、调用内核空间的系统调用函数-mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系"><a href="#二、调用内核空间的系统调用函数-mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系" class="headerlink" title="二、调用内核空间的系统调用函数 mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系"></a>二、调用内核空间的系统调用函数 mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</h3><p>5、为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核 “已打开文件集” 中改文件的文件结构体（struct_file），每个文件结构体维护着和这个已打开文件相关各项信息。</p><p>6、通过该文件的文件结构体，链接到 file_operations 模块，调用内核函数 mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。</p><p>7、内核 mmap 函数通过虚拟文件系统 inode 模块定位到文件磁盘物理地址。</p><p>8、通过 remap_pfn_range 函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。</p><h3 id="三、进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝"><a href="#三、进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝" class="headerlink" title="三、进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝"></a>三、进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝</h3><p>注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据拷贝到主存。真正的文件读取是当进程发起读或写操作时。</p><p>9、进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p><p>10、缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</p><p>11、调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用 nopage 函数把所缺的页从磁盘装入到主存中。</p><p>12、之后进程即可对这片主存进行读或写操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p><p>注：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用 msync() 来强制同步，这样所写的内容就能立即保存到文件里了。</p><h2 id="mmap-和常规文件操作的区别"><a href="#mmap-和常规文件操作的区别" class="headerlink" title="mmap 和常规文件操作的区别"></a>mmap 和常规文件操作的区别</h2><p>1、进程发起读文件请求。</p><p>2、内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的 inode。</p><p>3、inode 在 address_space 上查找要请求的文件页是否已经缓存在页缓存中。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</p><p>总结来说，常规文件操作为了提高读写效率和包含磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也一样，待写入的 buffer 在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。</p><p>而使用 mmsp 操作文件中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时，发现内存中并无数据而引起的缺页异常过程，可以通过已经建立好的因映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。</p><p>总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而 mmap 操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。说白了， mmap 的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此 mmap 效率更高。</p><h2 id="mmap-优点"><a href="#mmap-优点" class="headerlink" title="mmap 优点"></a>mmap 优点</h2><p>mmap 优点共有以下几点：</p><p>1、对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代 I&#x2F;O 读写，提高了文件读取效率。</p><p>2、实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。</p><p>3、提供进程间共享内存及相互通讯的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。</p><p>同时，如果进程 A 和 进程B 都映射了 区域C ，当 A 第一次读取C 时，通过缺页从磁盘复制文件页到内存中；但当 B 再度 C 的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。</p><p>4、可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足，但是进一步会造成大量的文件 I&#x2F;O 操作，极大影响效率。这个问题可以通过 mmap 映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap 都可以发挥其功效。</p><p>资料来源</p><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html">https://www.cnblogs.com/huxiao-tee/p/4660352.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;mmap-的基础概念&quot;&gt;&lt;a href=&quot;#mmap-的基础概念&quot; class=&quot;headerlink&quot; title=&quot;mmap 的基础概念&quot;&gt;&lt;/a&gt;mmap 的基础概念&lt;/h2&gt;&lt;p&gt;mmap 是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用 read，write 等系统调用函数。相反，内核空间这段区域的修改也直接反映用户空间，从而实现不同进程间的文件共享。如下图所示：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://cxinxian.github.io/tags/Android/"/>
    
    <category term="Android framework" scheme="http://cxinxian.github.io/tags/Android-framework/"/>
    
  </entry>
  
  <entry>
    <title>ZygoteInit-SystemServer的启动</title>
    <link href="http://cxinxian.github.io/2019/09/28/Android/framework/RuntimeInit-ZygoteInit-SystemServer/"/>
    <id>http://cxinxian.github.io/2019/09/28/Android/framework/RuntimeInit-ZygoteInit-SystemServer/</id>
    <published>2019-09-28T05:35:51.000Z</published>
    <updated>2025-02-22T07:50:33.516Z</updated>
    
    <content type="html"><![CDATA[<p>android 系统大致可以分为四层，由下往上分别为：</p><ul><li>Linux kernel 内核层，android 系统版本基于的Linux 内核版本不尽相同</li><li>Libraries 层，这一层提供动态链接库（也叫共享库）、Android 运行时库、Dalvik 虚拟机等。从编程语言来看，这一层大部分都是 C或C++ 写的，所以也可以简单把这一层看成 Native 层</li><li>Framework 层，这一层大部分都是 Java 语言编写。它是 Android 平台上 Java 世界的基石。</li><li>Application 层，和用户直接交互的就是这些应用程序，他们都是 Java 开发。</li></ul><span id="more"></span><p><img src="/../../assets/blogImg/Android/framework/zygoteinit/android_framework.jpg" alt="android_framework"></p><p>通过上面架构图可以可知，Android Runtime 处于Linux 和 framework 层之间，而 Java  的运行环境依赖于 Java 虚拟机，所以 AndroidRuntime 对于 android 系统非常重要。Init 进程是 Linux 环境下非常重要的一个进程，而 Zygote 进程的运行又需要依赖 Java 环境，并且在 Java 环境下其他应用进程都需要 Zygote 进程 frok出来，所以在 init 启动 Zygote 进程之后，初始化 Zygote 进程之前，会先进行 AndroidRuntime 的启动和环境准备。</p><h2 id="init-进程"><a href="#init-进程" class="headerlink" title="init 进程"></a>init 进程</h2><p>init 是 Linux 系统中用户空间的第一个重要的进程，在android 系统中， 它的进程号是 1。init 程序并不是一个源文件组成的，而是由一组源代码的目标文件链接而成，这些文件目录位置为：<code>/system/core/init/</code></p><p>主要负责：</p><ol><li>文件系统的挂载，如 <code>/sys、/dev、/proc</code> 等目录</li><li>初始化属性，提供 property service(属性服务) 管理  Android 系统中的属性</li><li>处理配置文件命令（加载、解析）（主要是 init.rc 脚本文件)</li><li>性能分析和执行其他进程。</li></ol><p>init 进程的入口是 <code>init.c</code> 文件的 main 函数，主要工作：</p><ol><li>文件系统挂载、klog 初始化、初始化信号量。</li><li>加载并解析 init.rc 以及 与硬件平台相关的配置文件（如 init.xxx.rc)，在此阶段，也会解析 service。</li><li>执行各个阶段的动作，创建 zygote 的工作就是在其中某个阶段完成。</li><li>调用 property_init 初始化属性相关的资源，并通过 property_start_service 启动属性服务。</li><li>init 进入一个无限循环，然后等待响应。</li></ol><h2 id="ZygoteInit-启动流程"><a href="#ZygoteInit-启动流程" class="headerlink" title="ZygoteInit 启动流程"></a>ZygoteInit 启动流程</h2><p>zygote 本身是一个与启动、内核等无关 Native 的应用程序,它是 Java 世界的开创者。它是由 init 进程在解析 init.rc 文件中的配置创建的。zygote 最初的名字叫 “app_process”，这个名字是在 Android.mk 文件中指定，在运行中，app_process 通过 linux 下的 pctrl 系统调用将自己的名字换成了 zygote</p><p>在 Java 中，不同虚拟机实例会为不同的应用分配不同的内存。如果 Android 应用要尽可能快地启动，但如果 Android 系统为每一个应用启动不同的 Dalvik 虚拟机实例，就会消耗大量的内存以及空间。因此，为了克服这个问题，Android 系统创造了 “Zygote”。 zygote 让 Dalvik 虚拟机共享代码、低内存占用以及最小的启动时间成为可能。</p><p>zygote 进程由 init 进程 fork 而来， 在init.rc 里面指定启动参数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#init.rc</span><br><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br></pre></td></tr></table></figure><p>zygote 的原型 app_process 对应源文件为：<code>app_main.cpp</code>，其中入口是main 函数，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// AppRuntime 继承自 AndroidRuntime</span></span><br><span class="line">    AppRuntime runtime;</span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (niceName &amp;&amp; *niceName) &#123;</span><br><span class="line">        <span class="built_in">setArgv0</span>(argv0, niceName);</span><br><span class="line">        <span class="comment">// 设置进程名称</span></span><br><span class="line">        <span class="built_in">set_process_name</span>(niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runtime.mParentDir = parentDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123; <span class="comment">// 如果 zygote变量有值并等于 ‘--Zygote’,那么调用 runtime.start()函数的参数为 “com.android.internal.os.ZygoteInit”</span></span><br><span class="line">        runtime.<span class="built_in">start</span>(<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>,</span><br><span class="line">                startSystemServer ? <span class="string">&quot;start-system-server&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        <span class="comment">// Remainder of args get passed to startup class main()</span></span><br><span class="line">        runtime.mClassName = className;</span><br><span class="line">        runtime.mArgC = argc - i;</span><br><span class="line">        runtime.mArgV = argv + i;</span><br><span class="line">        runtime.<span class="built_in">start</span>(<span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>,</span><br><span class="line">                application ? <span class="string">&quot;application&quot;</span> : <span class="string">&quot;tool&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">app_usage</span>();</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AppRuntime-分析"><a href="#AppRuntime-分析" class="headerlink" title="AppRuntime 分析"></a>AppRuntime 分析</h3><p>AppRuntime 是从 AndroidRuntime 类派生的，AppRuntime 声明和实现在 app_main.cpp 中，重载了 onStarted，onZygoteInit 和 onExit 函数。其中 AndroidRuntime:: start(const char* className, const bool startSystemServer) 函数做了几件事情：</p><ol><li>创建虚拟机 startVm</li><li>注册 JNI 函数 startReg</li><li>通过 JNI 调用 Java 函数，进入 Java 世界 <code>env-&gt;CallStaticVoidMethod</code></li></ol><p>代码如下 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*className, <span class="type">const</span> <span class="type">bool</span> startSystemServer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//className的值是&quot;com.android.internal.os.ZygoteInit&quot;</span></span><br><span class="line">    <span class="comment">//startSystemServer的值是true</span></span><br><span class="line">    <span class="type">char</span>*slashClassName = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>*cp;</span><br><span class="line">   JNIEnv* env;</span><br><span class="line">    <span class="built_in">blockSigpipe</span>();<span class="comment">//处理SIGPIPE信号</span></span><br><span class="line">     ......</span><br><span class="line"> </span><br><span class="line">    constchar* rootDir = <span class="built_in">getenv</span>(<span class="string">&quot;ANDROID_ROOT&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (rootDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//如果环境变量中没有ANDROID_ROOT,则新增该变量，并设置值为“/system&quot;</span></span><br><span class="line">       rootDir = “/system<span class="string">&quot;;</span></span><br><span class="line"><span class="string">        ......</span></span><br><span class="line"><span class="string">       setenv(&quot;</span>ANDROID_ROOT<span class="string">&quot;, rootDir, 1);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    //① 创建虚拟机</span></span><br><span class="line"><span class="string">    if(startVm(&amp;mJavaVM, &amp;env) != 0)</span></span><br><span class="line"><span class="string">        goto bail;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">     //②注册JNI函数</span></span><br><span class="line"><span class="string">    if(startReg(env) &lt; 0) &#123;</span></span><br><span class="line"><span class="string">        goto bail;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    jclassstringClass;</span></span><br><span class="line"><span class="string">   jobjectArray strArray;</span></span><br><span class="line"><span class="string">   jstring classNameStr;</span></span><br><span class="line"><span class="string">   jstring startSystemServerStr;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">   stringClass = env-&gt;FindClass(&quot;</span>java/lang/String<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    //创建一个有两个元素的String数组，即Java代码 String strArray[] = new String[2]</span></span><br><span class="line"><span class="string">   strArray = env-&gt;NewObjectArray(2, stringClass, NULL);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  classNameStr = env-&gt;NewStringUTF(className);</span></span><br><span class="line"><span class="string">   //设置第一个元素为&quot;</span>com.android.internal.os.ZygoteInit<span class="string">&quot;</span></span><br><span class="line"><span class="string">   env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);</span></span><br><span class="line"><span class="string">   startSystemServerStr = env-&gt;NewStringUTF(startSystemServer ?</span></span><br><span class="line"><span class="string">                                                &quot;</span><span class="literal">true</span><span class="string">&quot; : &quot;</span><span class="literal">false</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string">   //设置第二个元素为&quot;</span><span class="literal">true</span><span class="string">&quot;，注意这两个元素都是String类型，即字符串。</span></span><br><span class="line"><span class="string">   env-&gt;SetObjectArrayElement(strArray, 1, startSystemServerStr);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    jclassstartClass;</span></span><br><span class="line"><span class="string">   jmethodID startMeth;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">   slashClassName = strdup(className);</span></span><br><span class="line"><span class="string">   /*</span></span><br><span class="line"><span class="string">     将字符串“com.android.internal.os.ZygoteInit”中的“. ”换成“/”，</span></span><br><span class="line"><span class="string">     这样就变成了“com/android/internal/os/ZygoteInit”,这个名字符合JNI规范，</span></span><br><span class="line"><span class="string">     我们可将其简称为ZygoteInit类。</span></span><br><span class="line"><span class="string">   */</span></span><br><span class="line"><span class="string">    for(cp = slashClassName; *cp != &#x27;\0&#x27;; cp++)</span></span><br><span class="line"><span class="string">        if(*cp == &#x27;.&#x27;)</span></span><br><span class="line"><span class="string">           *cp = &#x27;/&#x27;;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">   startClass = env-&gt;FindClass(slashClassName);</span></span><br><span class="line"><span class="string">    ......</span></span><br><span class="line"><span class="string">    //找到ZygoteInit类的static main函数的jMethodId。</span></span><br><span class="line"><span class="string">   startMeth = env-&gt;GetStaticMethodID(startClass, &quot;</span>main<span class="string">&quot;,</span></span><br><span class="line"><span class="string">                                             &quot;</span>([Ljava/lang/String;)V<span class="string">&quot;);</span></span><br><span class="line"><span class="string">     ......</span></span><br><span class="line"><span class="string">     /*</span></span><br><span class="line"><span class="string">        ③通过JNI调用Java函数，注意调用的函数是main，所属的类是</span></span><br><span class="line"><span class="string">          com.android.internal.os.ZygoteInit，传递的参数是</span></span><br><span class="line"><span class="string">          “com.android.internal.os.ZygoteInit true”，</span></span><br><span class="line"><span class="string">          调用ZygoteInit的main函数后，Zygote便进入了Java世界！</span></span><br><span class="line"><span class="string">          也就是说，Zygote是开创Android系统中Java世界的盘古。</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">      env-&gt;CallStaticVoidMethod(startClass,startMeth, strArray);</span></span><br><span class="line"><span class="string">    //Zygote退出，在正常情况下，Zygote不需要退出。</span></span><br><span class="line"><span class="string">    if(mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</span></span><br><span class="line"><span class="string">       LOGW(&quot;</span>Warning: unable to detach main thread\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    if(mJavaVM-&gt;DestroyJavaVM() != 0)</span></span><br><span class="line"><span class="string">       LOGW(&quot;</span>Warning: VM did <span class="keyword">not</span> shut down cleanly\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">bail:</span></span><br><span class="line"><span class="string">   free(slashClassName);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/../../assets/blogImg/Android/framework/zygoteinit/runtimeInit-zygoteInit-systemserver.svg"></p><h3 id="ZygoteInit-分析"><a href="#ZygoteInit-分析" class="headerlink" title="ZygoteInit 分析"></a>ZygoteInit 分析</h3><p>根据上面的分析 ZygoteInit 的main 函数最终 由<code>env-&gt;CallStaticVoidMethod</code> 调用得到执行的，也就是从这里开始，通过 zygote 进入了 Java 世界。</p><p>在 ZygoteInit 的 main 函数中，主要做了以下几件事情：</p><ol><li>注册 zygote 用的 socket  <code>registerZygoteSocket()</code></li><li>预加载类和资源 <code>preloadClasses()、preloadResources()</code></li><li>启动 system_sever 进程</li><li>调用 <code>runSelectLoopMode</code> 函数，进入等待socket 连接和 sokcet 消息处理</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line">        <span class="comment">// 1. 注册zygote用的socket. 基于AF_UNIX类型，是一个本机socket</span></span><br><span class="line">        registerZygoteSocket();</span><br><span class="line">        <span class="comment">// 2. 预加载类和资源</span></span><br><span class="line">        preloadClasses();</span><br><span class="line">        preloadResources();</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 强制执行一次垃圾回收</span></span><br><span class="line">        gc();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(argv[<span class="number">1</span>].equals(<span class="string">&quot;true&quot;</span>))&#123;</span><br><span class="line">            startSystemServer(); <span class="comment">// 3. 启动system_server进程。该进程是framework的核心。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!argv[<span class="number">1</span>].equals(<span class="string">&quot;false&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(argv[<span class="number">0</span>] + USAGE_STRING);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ZYGOTE_FORK_MODE)&#123;</span><br><span class="line">            runForkMode();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            runSelectLoopMode(); <span class="comment">// 4. zygote调用这个函数，进入等待唤醒的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        closeServerSocket();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(MethodAndArgsCaller caller)&#123;</span><br><span class="line">        caller.run(); <span class="comment">//5.很重要的caller run函数，以后分析</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(RuntimeException ex)&#123;</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1、注册socket，建立 IPC 通信服务端—— registerZygoteSocket</strong></p><p>Zygote以及系统中其他程序的通信没有使用Binder，而是采用了基于AF_UNIX类型的Socket。registerZygoteSocket函数的使命正是建立这个Socket。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerZygoteSocket</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(sServerSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">        intfileDesc;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="comment">//从环境变量中获取Socket的fd，还记得第3章init中介绍的zygote是如何启动的吗？</span></span><br><span class="line"><span class="comment">//这个环境变量由execv传入。</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">env</span> <span class="operator">=</span> System.getenv(ANDROID_SOCKET_ENV);</span><br><span class="line">          fileDesc = Integer.parseInt(env);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//创建服务端Socket，这个Socket将listen并accept Client</span></span><br><span class="line">         sServerSocket= <span class="keyword">new</span> <span class="title class_">LocalServerSocket</span>(createFileDescriptor(fileDesc));</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、预加载类和资源</strong></p><p><strong>preloadClasses</strong> 方法就是根据 <code>preloaded-classes</code> 文件中的预加载类信息去加载类。</p><blockquote><p>preloaded-classes 文件由framework&#x2F;base&#x2F;tools&#x2F;preload工具生成，它需要判断每个类加载的时间是否大于1250微秒，超过这个时间的类就会被写到preload-classes文件中，最后由zygote预加载。</p></blockquote><p>preloadClass函数的执行时间比较长，这是导致Android系统启动慢的原因之一。对这一块可以做一些优化，但优化是基于对整个系统有比较深入了解才能实现的。</p><p><strong>preloadResources</strong> 和preloadClass类似，它主要是加载framework-res.apk中的资源。</p><p><strong>3、启动system_server</strong></p><p>startSystemServer。这个函数会创建Java世界中系统Service所驻留的进程system_server，该进程是framework的核心。如果它死了，就会导致zygote自杀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">startSystemServer</span><span class="params">()</span></span><br><span class="line">           <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException &#123;</span><br><span class="line">        <span class="comment">//设置参数</span></span><br><span class="line">       String args[] = &#123;</span><br><span class="line">            <span class="string">&quot;--setuid=1000&quot;</span>,<span class="comment">//uid和gid等设置</span></span><br><span class="line">           <span class="string">&quot;--setgid=1000&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,</span></span><br><span class="line"><span class="string">                            3001,3002,3003&quot;</span>,</span><br><span class="line">           <span class="string">&quot;--capabilities=130104352,130104352&quot;</span>,</span><br><span class="line">           <span class="string">&quot;--runtime-init&quot;</span>,</span><br><span class="line">           <span class="string">&quot;--nice-name=system_server&quot;</span>, <span class="comment">//进程名，叫system_server</span></span><br><span class="line">           <span class="string">&quot;com.android.server.SystemServer&quot;</span>, <span class="comment">//启动的类名</span></span><br><span class="line">        &#125;;</span><br><span class="line">       ZygoteConnection.<span class="type">Arguments</span> <span class="variable">parsedArgs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">int</span> pid;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//把上面字符串数组参数转换成Arguments对象。具体内容请读者自行分析。</span></span><br><span class="line">           parsedArgs = <span class="keyword">new</span> <span class="title class_">ZygoteConnection</span>.Arguments(args);</span><br><span class="line">           <span class="type">int</span> <span class="variable">debugFlags</span> <span class="operator">=</span> parsedArgs.debugFlags;</span><br><span class="line">          <span class="comment">//fork一个子进程，看来，这个子进程就是system_server进程。</span></span><br><span class="line">           pid = Zygote.forkSystemServer(</span><br><span class="line">                    parsedArgs.uid,parsedArgs.gid,</span><br><span class="line">                    parsedArgs.gids,debugFlags, <span class="literal">null</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      关于fork的知识，请读者务花些时间去研究。如果对fork具体实现还感兴趣，可参考</span></span><br><span class="line"><span class="comment">     《Linux内核源代码情景分析》一书。（该书由浙江大学出版社出版，作者为毛德操、胡希明）</span></span><br><span class="line"><span class="comment">      下面代码中，如果pid为零，则表示处于子进程中，也就是处于system_server进程中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//① system_server进程的工作</span></span><br><span class="line">           handleSystemServerProcess(parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//zygote返回true</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>4、 有求必应之等待请求——runSelectLoopMode</strong></p><p>当Zygote从startSystemServer返回后，将进入第四个关键函数：runSelectLoopMode。前面，在第一个关键点registerZygoteSocket中注册了一个用于IPC的Socket，不过那时还没有地方用到它。它的用途将在这个runSelectLoopMode中体现出来，请看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runSelectLoopMode</span><span class="params">()</span></span><br><span class="line"><span class="keyword">throws</span> MethodAndArgsCaller &#123;</span><br><span class="line">       ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">       ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">       FileDescriptor[] fdArray = <span class="keyword">new</span> <span class="title class_">FileDescriptor</span>[<span class="number">4</span>];</span><br><span class="line">      <span class="comment">//sServerSocket是我们先前在registerZygoteSocket建立的Socket</span></span><br><span class="line">       fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">       peers.add(<span class="literal">null</span>);</span><br><span class="line"> </span><br><span class="line">       <span class="type">int</span> <span class="variable">loopCount</span> <span class="operator">=</span> GC_LOOP_COUNT;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="type">int</span> index;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">               fdArray = fds.toArray(fdArray);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          selectReadable内部调用select，使用多路复用I/O模型。</span></span><br><span class="line"><span class="comment">          当有客户端连接或有数据时，则selectReadable就会返回。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">              index = selectReadable(fdArray);</span><br><span class="line">           &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">//如有一个客户端连接上，请注意客户端在Zygote的代表是ZygoteConnection</span></span><br><span class="line">               <span class="type">ZygoteConnection</span> <span class="variable">newPeer</span> <span class="operator">=</span> acceptCommandPeer();</span><br><span class="line">               peers.add(newPeer);</span><br><span class="line">               fds.add(newPeer.getFileDesciptor());</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="type">boolean</span> done;</span><br><span class="line">              <span class="comment">//客户端发送了请求，peers.get返回的是ZygoteConnection</span></span><br><span class="line">             <span class="comment">//后续处理将交给ZygoteConnection的runOnce函数完成。</span></span><br><span class="line">               done = peers.get(index).runOnce();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>runSelectLoopMode比较简单，就是：</p><ul><li>处理客户连接和客户请求。其中客户在Zygote中用ZygoteConnection对象来表示。</li><li>客户的请求由ZygoteConnection的runOnce来处理。</li></ul><h3 id="zygote-创建Java-世界总结"><a href="#zygote-创建Java-世界总结" class="headerlink" title="zygote 创建Java 世界总结"></a>zygote 创建Java 世界总结</h3><ol><li>创建 AppRuntime 对象，调用它的 start 方法</li><li>调用 startVm 创建 Java 虚拟机，然后调用 startReg 来注册 JNI 函数。</li><li>通过 JNI <code>CallStaticVoidMethod</code> 调用 com.android.internal.os.ZygoteInit 类的main 函数，进入 Java 世界。</li><li>调用 registerZygoteSocket 。通过 这个函数，可以响应子孙进程的请求，同时调用 preloadClasses 和 preloadResources 预加载类和系统资源</li><li>通过 startSystemServer 分裂一个子进程 system_server </li><li>调用 runSelectLoopMode 进入 等待唤醒</li></ol><h2 id="SystemServer-启动流程"><a href="#SystemServer-启动流程" class="headerlink" title="SystemServer 启动流程"></a>SystemServer 启动流程</h2><p>由上面的 zygote 启动初始化流程可知， SystemServer 是由 <code>Zygote.forkSystemServer</code> 函数通过系统调用 fork 出来的。</p><p><img src="/../../assets/blogImg/Android/framework/zygoteinit/zygote-systemserver.svg"></p><p>在 SystemServer 进程fork 成功后，便进入 handleSystemServerProcess(parseArgs) 函数，从此便进入 system_server 进程，执行相关初始化工作，并且调用 Java 世界的 com.android.server.SystemServer 。</p><p>接下来根据源码做进一步分析：</p><p><strong>ZygoteInit.handleSystemServerProcess</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleSystemServerProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">       ZygoteConnection.ArgumentsparsedArgs)</span></span><br><span class="line">      <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">        <span class="comment">//关闭从Zygote那里继承下来的Socket。 </span></span><br><span class="line">        closeServerSocket();</span><br><span class="line">      <span class="comment">//设置SS进程的一些参数。</span></span><br><span class="line">        setCapabilities(parsedArgs.permittedCapabilities,</span><br><span class="line">                   parsedArgs.effectiveCapabilities);</span><br><span class="line">        <span class="comment">//调用ZygoteInit函数。</span></span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.remainingArgs);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>RuntimeInit.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">zygoteInit</span><span class="params">(String[]argv)</span></span><br><span class="line">           <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">     <span class="comment">//做一些常规初始化</span></span><br><span class="line">     commonInit();</span><br><span class="line">     <span class="comment">//①native层的初始化。</span></span><br><span class="line">    zygoteInitNative();</span><br><span class="line">     intcurArg = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="comment">/* curArg */</span> ; curArg &lt; argv.length; curArg++) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">arg</span> <span class="operator">=</span> argv[curArg];</span><br><span class="line"> </span><br><span class="line">           <span class="keyword">if</span> (arg.equals(<span class="string">&quot;--&quot;</span>)) &#123;</span><br><span class="line">               curArg++;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!arg.startsWith(<span class="string">&quot;--&quot;</span>)) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg.startsWith(<span class="string">&quot;--nice-name=&quot;</span>)) &#123;</span><br><span class="line">               <span class="type">String</span> <span class="variable">niceName</span> <span class="operator">=</span> arg.substring(arg.indexOf(<span class="string">&#x27;=&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line">               <span class="comment">//设置进程名为niceName，也就是&quot;system_server&quot;</span></span><br><span class="line">               Process.setArgV0(niceName);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//startClass名为&quot;com.android.server.SystemServer&quot;</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">startClass</span> <span class="operator">=</span> argv[curArg++];</span><br><span class="line">       String[] startArgs = <span class="keyword">new</span> <span class="title class_">String</span>[argv.length - curArg];</span><br><span class="line">       System.arraycopy(argv, curArg, startArgs, <span class="number">0</span>, startArgs.length);</span><br><span class="line">       <span class="comment">//②调用startClass，也就是com.android.server.SystemServer类的main函数。</span></span><br><span class="line">       invokeStaticMain(startClass, startArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SystemServer调用了zygoteInitNative后，将与Binder通信系统建立联系，这样SystemServer就可以使用Binder了。zygoteInitNative中调用了onZygoteInit()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::<span class="built_in">self</span>();</span><br><span class="line">    <span class="keyword">if</span>(proc-&gt;<span class="built_in">supportsProcesses</span>())&#123;</span><br><span class="line">        proc-&gt;<span class="built_in">startThreadPool</span>(); <span class="comment">// 启动一个线程，用于Binder通信</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>invokeStaticMain 函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeStaticMain</span><span class="params">(String className, String[] argv)</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    <span class="comment">// 参数传入，className = &quot;com.android.server.SystemServer&quot;</span></span><br><span class="line">    ......</span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String[].class &#125;); <span class="comment">// 找到com.android.server.SystemServer类的main函数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(NoSuchMethodException ex)&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">catch</span>(SecurityException ex)&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ZygoteInit</span>.MethodAndArgsCaller(m, argv); <span class="comment">// 主动抛出一个异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invokeStaticMain竟然抛出了一个异常，它是在哪里被截获呢？是在ZygoteInit的main函数中。请看这段代码：</p><p><strong>注意：我们所在的进程是system_server。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argv[<span class="number">1</span>].equals(<span class="string">&quot;true&quot;</span>)) &#123;</span><br><span class="line">     <span class="comment">//SS进程中，抛出一个异常MethodAndArgsCaller</span></span><br><span class="line">    startSystemServer();</span><br><span class="line">     ......</span><br><span class="line">    <span class="keyword">catch</span>(MethodAndArgsCaller caller) &#123;</span><br><span class="line">     <span class="comment">//被截获，调用caller的run函数</span></span><br><span class="line">      caller.run(); </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么要主动抛出这样一个异常来执行main函数呢？</p><p>《深入理解Android 卷I》中是这样解释的：这个调用是在ZygoteInit.main中，相当于Native的main函数，也即入口函数，位于堆栈的顶层。如果不采用抛异常的方式，而是在invokeStaticMain那调用，则会浪费之前函数调用所占用的一些调用堆栈。</p></blockquote><h3 id="java-世界的-SystemServer"><a href="#java-世界的-SystemServer" class="headerlink" title="java 世界的 SystemServer"></a>java 世界的 SystemServer</h3><p>从上面的分析可知，在 invokeStaticMain 方法抛出异常后，然后在 ZygoteInit.main 中捕获异常，然后调用 MethodAndArgsCaller.run 函数，最终通过反射调用到 com.android.server.SystemServer类的main函数</p><p>下面将对 SystemServer 流程展开分析</p><p><strong>main 函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   ......</span><br><span class="line">    <span class="comment">//加载libandroid_servers.so</span></span><br><span class="line">   System.loadLibrary(<span class="string">&quot;android_servers&quot;</span>);</span><br><span class="line">  <span class="comment">//调用native的init1函数。</span></span><br><span class="line">  init1(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main 函数中主要做两件事情：</p><p>1、加载 libandroid_servers.so 动态库，这个库所包含的源码文件在文件夹framework&#x2F;base&#x2F;services&#x2F;jni下</p><p>2、调用native的init1函数。</p><p>init1是native函数，在com_android_server_SystemServer.cpp中实现。</p><p><strong>com_android_server_SystemServer.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">system_init</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">voidandroid_server_SystemServer_init1</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">system_init</span>();<span class="comment">//调用另外一个函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>system_init的实现在system_init.cpp中，它的代码如下所示：<br><strong>system_init.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">status_t</span> <span class="title">system_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//下面这些调用和Binder有关，我们会在第6章中讲述，这里先不必管它。</span></span><br><span class="line">   <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">   sp&lt;IServiceManager&gt; sm = <span class="built_in">defaultServiceManager</span>();</span><br><span class="line">   </span><br><span class="line">    sp&lt;GrimReaper&gt;grim = <span class="keyword">new</span> <span class="built_in">GrimReaper</span>();</span><br><span class="line">   sm-&gt;<span class="built_in">asBinder</span>()-&gt;<span class="built_in">linkToDeath</span>(grim, grim.<span class="built_in">get</span>(), <span class="number">0</span>);</span><br><span class="line">    charpropBuf[PROPERTY_VALUE_MAX];</span><br><span class="line">   <span class="built_in">property_get</span>(<span class="string">&quot;system_init.startsurfaceflinger&quot;</span>, propBuf,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(propBuf, <span class="string">&quot;1&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//SurfaceFlinger服务在system_server进程创建</span></span><br><span class="line">       SurfaceFlinger::<span class="built_in">instantiate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     ......</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//调用com.android.server.SystemServer类的init2函数</span></span><br><span class="line">   AndroidRuntime* runtime = AndroidRuntime::<span class="built_in">getRuntime</span>();</span><br><span class="line">   runtime-&gt;<span class="built_in">callStatic</span>(<span class="string">&quot;com/android/server/SystemServer&quot;</span>,<span class="string">&quot;init2&quot;</span>);</span><br><span class="line">   </span><br><span class="line"><span class="comment">//下面这几个函数调用和Binder通信有关，具体内容在第6章中介绍。</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;<span class="built_in">supportsProcesses</span>()) &#123;</span><br><span class="line">        ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line">       <span class="comment">//调用joinThreadPool后，当前线程也加入到Binder通信的大潮中</span></span><br><span class="line">       IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line">       &#125;</span><br><span class="line">    returnNO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init1函数创建了一些系统服务，然后把调用线程加入Binder通信中。不过其间还通过JNI调用了com.android.server.SystemServer类的init2函数，下面就来看看这个init2函数。</p><p>init2在Java层，代码在SystemServer.java中，如下所示：<br><strong>SystemServer.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">init2</span><span class="params">()</span> &#123;</span><br><span class="line">   Threadthr = <span class="keyword">new</span> <span class="title class_">ServerThread</span>();</span><br><span class="line">   thr.setName(<span class="string">&quot;android.server.ServerThread&quot;</span>);</span><br><span class="line">   thr.start();<span class="comment">//启动一个ServerThread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动了一个ServerThread线程。请直接看它的run函数。</p><p>在run 函数中，主要启动 系统线程、AMS、WMS、PMS 等各种service</p><h3 id="SystemServer-总结"><a href="#SystemServer-总结" class="headerlink" title="SystemServer 总结"></a>SystemServer 总结</h3><ol><li>ZygoteInit 调用 startSystemServer 创建 system_server 进程</li><li>SystemServer 调用 handleSystemServerProcess 完成自己的使命</li><li>handleSystemServerProcess 抛出异常，最终调用com.android.server.SystemServer的main函数。</li><li>main函数加载libandroid_server.so并调用native的init1函数。</li><li>init1函数通过JNI调用com.android.server.SystemServer类的init2函数。init2函数创建一个线程，用于加载各种service。</li><li>init1函数最终加入到Binder通信系统。</li></ol><h2 id="Zygote-的分裂"><a href="#Zygote-的分裂" class="headerlink" title="Zygote 的分裂"></a>Zygote 的分裂</h2><p>在 zygote fork 出 system_server 进程后，就通过 <code>runSelectLoopMode </code> 等待来自客户端的消息请求。接下来以启动Hom界面 作为分析案例。</p><p>在Application Framework层的ActivityManagerService准备就绪后，就会通知各个模块，继续执行上层应用</p><p><strong>ServerThread</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerService.self().systemReady(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">....</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>ActivityManagerService.AThread</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">systemReady</span><span class="params">(<span class="keyword">final</span> Runnable goingCallback)</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Start up initial activity.</span></span><br><span class="line">            mBooting = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (AppGlobals.getPackageManager().hasSystemUidErrors()) &#123;</span><br><span class="line">                 <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">                 msg.what = SHOW_UID_ERROR_MSG;</span><br><span class="line">                 mHandler.sendMessage(msg);</span><br><span class="line">             &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">// 调用 ActiviytStack.resumeTopActivityLocked 方法，准备启动 Lanucher 界面</span></span><br><span class="line">        mMainStack.resumeTopActivityLocked(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>ActivityStack.resumeTopActivityLocked</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">resumeTopActivityLocked</span><span class="params">(ActivityRecord prev)</span> &#123;</span><br><span class="line"><span class="comment">// Find the first activity that is not finishing.</span></span><br><span class="line"><span class="type">ActivityRecord</span> <span class="variable">next</span> <span class="operator">=</span> topRunningActivityLocked(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remember how we&#x27;ll process this pause/resume situation, and ensure</span></span><br><span class="line"><span class="comment">// that the state is reset however we wind up proceeding.</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">userLeaving</span> <span class="operator">=</span> mUserLeaving;</span><br><span class="line">mUserLeaving = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// There are no more activities!  Let&#x27;s just start up the</span></span><br><span class="line"><span class="comment">// Launcher...</span></span><br><span class="line"><span class="keyword">if</span> (mMainStack) &#123;</span><br><span class="line"><span class="comment">// 启动 Launcher</span></span><br><span class="line"><span class="keyword">return</span> mService.startHomeActivityLocked();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SystemServer 启动完成后，然后就启动一个 Home 应用程序，也即 Lanucher 。其中 Lanucher 在启动的过程中，会请求 PackageManagerService 返回已经安装的的应用程序信息，并将这些应用程序封装成一个快捷图标列表显示在系统屏幕上，这样用用便可以通过点击快捷图标来启动相应的应用程序。</p><h2 id="总结系统启动流程"><a href="#总结系统启动流程" class="headerlink" title="总结系统启动流程"></a>总结系统启动流程</h2><ol><li><p><strong>启动电源以及系统启用</strong></p><p>当按下电源时，引导芯片代码开始从预定义地方（固化ROM）开始执行，加载引导程序 BootLoader 到 RAM，然后执行。</p></li><li><p><strong>引导程序BootLoader</strong></p><p>引导程序 BootLoader 时Android 系统启动前的一个小程序，类似 BIOS，通过引导程序可以将系统引导加载到 RAM中拉起来运行。</p></li><li><p><strong>Linux 启动内核</strong></p><p>Linux 启动后会加载驱动、挂载根目录、计划表等等，但完成系统的设置后，会启动 第一个进程 init 进程，并查找加载 init.rc 文件。</p></li><li><p><strong>init进程</strong></p><p>init 会进行相关初始化运行，并且fork Zygote进程，然后根据 init.rc 运行 app_process, 并携带 “–zygote” 和 “–startSystemServer” 参数。</p><p>AndroidRuntime.cpp::start() 里将启动 JavaVM，并且注册所有 framework 相关系统 JNI 接口。</p><p>通过 CallStaticVoidMethod 调用 ZygoteInit.java::main() 函数初始化进入到 Java 世界。</p></li><li><p><strong>Zygote进程启动</strong></p><p>创建 JavaVM 并且注册 JNI 接口，创建 服务端 Socket，预加载常用Java 类库，以及系统的 resource 资源，同时GC 清理内存空间，启动 SystemServer，然后进入 selectSocketLoopMode 等待socket 客户端的消息连接和处理。</p></li><li><p><strong>SystemServer 进程启动</strong></p><p>启动 Binder 线程池和 SystemServiceManager，并启动各种系统服务。</p></li><li><p><strong>Lanucher 启动</strong></p><p>被 SystemServer 进程启动的ActivityManagerService 会启动 Launcher, Launcher启动后会将已经安装的应用程序的快捷图标显示到界面上。</p></li></ol><p>资料来源：</p><p><a href="https://www.cnblogs.com/lao-liang/p/5067312.html">https://www.cnblogs.com/lao-liang/p/5067312.html</a></p><p><a href="https://www.cnblogs.com/samchen2009/p/3294713.html">https://www.cnblogs.com/samchen2009/p/3294713.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;android 系统大致可以分为四层，由下往上分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux kernel 内核层，android 系统版本基于的Linux 内核版本不尽相同&lt;/li&gt;
&lt;li&gt;Libraries 层，这一层提供动态链接库（也叫共享库）、Android 运行时库、Dalvik 虚拟机等。从编程语言来看，这一层大部分都是 C或C++ 写的，所以也可以简单把这一层看成 Native 层&lt;/li&gt;
&lt;li&gt;Framework 层，这一层大部分都是 Java 语言编写。它是 Android 平台上 Java 世界的基石。&lt;/li&gt;
&lt;li&gt;Application 层，和用户直接交互的就是这些应用程序，他们都是 Java 开发。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://cxinxian.github.io/tags/Android/"/>
    
    <category term="Android framework" scheme="http://cxinxian.github.io/tags/Android-framework/"/>
    
  </entry>
  
  <entry>
    <title>Framework 之 Zygote</title>
    <link href="http://cxinxian.github.io/2019/09/20/Android/framework/Zygote/"/>
    <id>http://cxinxian.github.io/2019/09/20/Android/framework/Zygote/</id>
    <published>2019-09-20T13:02:06.000Z</published>
    <updated>2025-02-22T07:50:42.837Z</updated>
    
    <content type="html"><![CDATA[<p>本章节学习关于 Zygote 的内容知识</p><span id="more"></span><h3 id="一、Zygote-的作用是是什么？"><a href="#一、Zygote-的作用是是什么？" class="headerlink" title="一、Zygote 的作用是是什么？"></a>一、Zygote 的作用是是什么？</h3><ol><li><p>启动 SystemServer (通过Zygote 来启动，可以继承Zygote 的准备好部分资源，包括常用类，JNI函数、主题资源、共享库，从Zygote 继承过来不需要再重新加载)</p></li><li><p>孵化应用进程</p></li><li><p>创建DVM (Dalvik 虚拟机)  和 ART</p></li></ol><p>加载常用类、JNI函数、主题资源、共享库</p><p>zygote 启动之前的步骤：进程启动-&gt;准备工作-&gt;SocketLoop</p><h3 id="二、Zygote-的启动流程"><a href="#二、Zygote-的启动流程" class="headerlink" title="二、Zygote 的启动流程"></a>二、Zygote 的启动流程</h3><h4 id="2-1、进程是怎么启动的？"><a href="#2-1、进程是怎么启动的？" class="headerlink" title="2.1、进程是怎么启动的？"></a>2.1、进程是怎么启动的？</h4><p>系统 启动之后，第一个进程为 init 进程，init 进程启动后加加载 init.rc 配置文件。init.rc 配置文件中定义了需要启动的服务，如 Zygote，SystemManager 服务。init 进程加载配置后，通过 fork + execve 系统调用。</p><p><strong>init.rc 启动配置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">class main</span><br><span class="line">socket zygote stream 660 root system</span><br><span class="line">onrestart write /sys/android_power/request_state wake</span><br><span class="line">onrestart write /sys/power/state on</span><br><span class="line">onrestart restart media</span><br><span class="line">onrestart restart netd</span><br><span class="line">writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure><p>配置分析：</p><p>service zygote 表示 要启动的系统服务</p><p>因为进程的启动是通过 fork+execve 系统调用，需要传一个可执行程序路径+参数</p><p>则 <code>/system/bin/app_process</code> 表示 <em>可执行程序路径</em></p><p><code>-Xzygote /system/bin --zygote --start-system-server</code> 表示 <em>参数</em></p><p><strong>进程的启动方式有两种</strong></p><ul><li>fork + handle</li><li>fork + execve</li></ul><p><img src="/../../assets/blogImg/Android/framework/zygote/zygote-1.jpg" alt="zygote-1"></p><p>两种方式都是通过 <code>fork()</code> 函数调用创建子进程 ，<u>该函数被调用一次，但返回两次。其中一次返是子进程的返回，值为0；另一次返回是父进程返回，值为新进程（子进程）的id。将子进程id返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程id。</u></p><p>对应子进程来说，之所以 fork 返回0给它，是因为它随时可以调用 <code>getpid()</code> 来获取自己的pid；也可以调用 <code>getppid()</code> 来获取父进程的id。</p><p><u>fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是相互独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置</u></p><p>（两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。</p><p>fork 出来的子进程和父进程是继承关系，继承了大部分内容，并不是全部继承。</p><p>上图中 fork + execve 启动进程的方式，在 fork 子进程后，执行系统调用 <code>execve(path,argv,env)</code>  加载二进制程序，则从父进程继承的资源将会被新的二进制程序给替换掉。</p><p><strong>进程信号处理-SIGCHLD</strong></p><p><img src="/../../assets/blogImg/Android/framework/zygote/zygote-2.png" alt="zygote-2"></p><p>通常父进程 fork 出子进程后，如果子进程挂了，那么父进程将会受到 SIGCHLD 信号，比如 init 进程fork 出 zygote 进程，当 zygote 挂了，那么 init 进程会受到 SIGCHLD 信号，然后会重启 zygote 进程。</p><h4 id="2-2、Zygote进程启动之后做了什么？"><a href="#2-2、Zygote进程启动之后做了什么？" class="headerlink" title="2.2、Zygote进程启动之后做了什么？"></a>2.2、Zygote进程启动之后做了什么？</h4><p>Zygote 进程启动之后，主要执行分为两个部分，主要分为native部分和 java 部分</p><h4 id="2-2-1、native-部分"><a href="#2-2-1、native-部分" class="headerlink" title="2.2.1、native 部分"></a>2.2.1、native 部分</h4><p><img src="/../../assets/blogImg/Android/framework/zygote/zygote-3.png" alt="zygote-3"></p><p>Zygote 进程启动后，在 native 部分执行主要有三件事，1、启动Android虚拟机；2、注册Android的 JNI 函数；3、进入Java世界。其目的就是为后面执行Java 做准备。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    JavaVM *jvm;</span><br><span class="line">    JNIEnv *env;</span><br><span class="line">    <span class="comment">// 创建 虚拟机</span></span><br><span class="line">    <span class="built_in">JNI_CreateJavaVM</span>(&amp;jvm,(<span class="type">void</span> **)&amp;env, &amp;vm_args);</span><br><span class="line">    <span class="comment">// 查找 ZygoteInit 的Java类</span></span><br><span class="line">    jclass clazz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;ZygoteInit&quot;</span>);</span><br><span class="line">    <span class="comment">// 查找类中 Main 静态函数</span></span><br><span class="line">    jmethodID method = env-&gt;<span class="built_in">GetStaticMethodID</span>(clazz,<span class="string">&quot;Main&quot;</span>,<span class="string">&quot;([Ljava/lang/String;])V&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用静态函数</span></span><br><span class="line">    env-&gt;<span class="built_in">CallStaticVoidMethod</span>(clazz,method,args);</span><br><span class="line">    <span class="comment">// 消耗虚拟机</span></span><br><span class="line">    jvm-&gt;<span class="built_in">DestroyJavaVM</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2、Java-部分"><a href="#2-2-2、Java-部分" class="headerlink" title="2.2.2、Java 部分"></a>2.2.2、Java 部分</h4><p><img src="/../../assets/blogImg/Android/framework/zygote/zygote-4.png" alt="zygote-4"></p><p>主要有三件事：</p><ol><li>预加载资源，一些常用的类，主题相关资源、共享库，可以在子进程孵化时继承给他们。</li><li>fork SystemServer（单独一个子进程）</li><li>进入Loop 循环，等待 socket 消息，与 SystemServer 通讯。</li></ol><p>下面关于 framework 中 ZygoteConnection.java  的部分关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">runOnce</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 读取参数列表（是AMS 跨进程发过来的）</span></span><br><span class="line">String[] args = readArgumentList();</span><br><span class="line">    <span class="comment">// 启动子进程</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> Zygote.forkAndSpecialize();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// in child 子进程干活，执行java类的main函数，类来自于上边读取的参数列表，执行子进程其实就是 ActivityThread.main()</span></span><br><span class="line">handleChildProc(args,...);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、要注意的细节"><a href="#三、要注意的细节" class="headerlink" title="三、要注意的细节"></a>三、要注意的细节</h3><h4 id="3-1、Zygote-fork-要单线程"><a href="#3-1、Zygote-fork-要单线程" class="headerlink" title="3.1、Zygote fork 要单线程"></a>3.1、Zygote fork 要单线程</h4><p>因为不管父进程有多少个线程，但子进程在创建时就只有一个线程，那对子进程来说，其他多的线程就不见了。这样都会导致其他问题，死锁，或者状态不一致。</p><p>所以在创建子进程时会停掉主线程之外其他线程，等创建完子进程后在把其他线程重启。</p><h4 id="3-2、Zygote-的-IPC-没有采用-binder，而是使用本地-socekt"><a href="#3-2、Zygote-的-IPC-没有采用-binder，而是使用本地-socekt" class="headerlink" title="3.2、Zygote 的 IPC 没有采用 binder，而是使用本地 socekt"></a>3.2、Zygote 的 IPC 没有采用 binder，而是使用本地 socekt</h4><p>所有应用程序的binder 机制不是从 zygote 继承过来的，而是应用程序的进程启动之后自己启动的binder </p><h3 id="四、问题思考"><a href="#四、问题思考" class="headerlink" title="四、问题思考"></a>四、问题思考</h3><h4 id="4-1、孵化应用进程这种事为什么不交给SystemServer来做，而专门设计一个Zygote"><a href="#4-1、孵化应用进程这种事为什么不交给SystemServer来做，而专门设计一个Zygote" class="headerlink" title="4.1、孵化应用进程这种事为什么不交给SystemServer来做，而专门设计一个Zygote?"></a>4.1、孵化应用进程这种事为什么不交给SystemServer来做，而专门设计一个Zygote?</h4><p>我们知道，应用在启动的时候需要做很多准备工作，包括虚拟机，加载各类系统资源等等，这些都是非常耗时的，如果能在zygote里就给这些必要的初始化工作做好，子进程在fork 的时候就能直接共享，那么这样的话效率就会非常高。这个就是zygote 存在的价值，这一点 SystemServer 是替代不了的，主要是因为 SystemServer 里面跑了一堆系统服务，这些是不能继承到应用进程的。而且我们应用进程在启动的时候，内存空间处理必要的资源外，最后是干干净净的，不要继承一堆乱七八糟的东西。所以，不如给SystemServer 和应用进程里都要用到的资源抽出来单独放在一个进程里，也就是这 zygote 进程，然后 zygote 进程再分别孵化出SystemServer 进程和应用进程。孵化出来之后，SystemServer 进程和应用进程就可以各干各的事了。</p><h4 id="4-2、Zygote的-IPC-通信机制为什么不采用binder-如果采用binder-的话会有什么问题么？"><a href="#4-2、Zygote的-IPC-通信机制为什么不采用binder-如果采用binder-的话会有什么问题么？" class="headerlink" title="4.2、Zygote的 IPC 通信机制为什么不采用binder?如果采用binder 的话会有什么问题么？"></a>4.2、Zygote的 IPC 通信机制为什么不采用binder?如果采用binder 的话会有什么问题么？</h4><p>第一个原因，我们可以设想一下采用binder 调用的话该怎么做，首先 zygote 要启用 binder 机制，需要打开 binder 驱动，获得一个描述符，再通过 mmap 进行内存映射，还要注册binder 线程，这还不够，还要创建一个 binder 对象注册到 ServiceManager ， 另外 AMS 要向 zygote 发起创建应用进程请求的话，要先从 ServiceManager 查询 zygote 的 binder 对象，然后再发起 binder 调用， 这来来回回好几趟非常繁琐，相比之下，zygote 和SystemServer 进程本来就是父子关系，对于简单的消息通信，用管道或者 socket  非常方便省事。</p><p>第二个原因：如果 zygote 启用 binder 机制， 在fork 出 SystemServer，那么SystemServer 就会继承了 zygote 的描述符已经映射的内存，这两个进程在 binder 驱动层就会共享一套数据结构，这显然不行的，所以还得先给原来的旧的描述符关掉，再重新启用一遍binder 机制，这个就是自找麻烦了。</p><p><img src="/../../assets/blogImg/Android/framework/zygote/zygote-5.jpg" alt="zygote-5"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本章节学习关于 Zygote 的内容知识&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://cxinxian.github.io/tags/Android/"/>
    
    <category term="Android framework" scheme="http://cxinxian.github.io/tags/Android-framework/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu虚拟机编译ijkplayer</title>
    <link href="http://cxinxian.github.io/2018/11/10/Ubuntu-compile-ijkplayer/"/>
    <id>http://cxinxian.github.io/2018/11/10/Ubuntu-compile-ijkplayer/</id>
    <published>2018-11-10T12:21:29.000Z</published>
    <updated>2021-06-05T00:49:45.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近段时间项目开发中需要视频播放器，于是开始搜索相关资料了解到ijkplayer是一个很不错的开源的轻量级视频播放器，<br>支持播放本地网络视频，也支持流媒体播放。是Bilibili基于ffmpeg开发的，支持Android&amp;iOS。<br>虽然Vitamio也很强大，但只是面对个人开放，就pass好了，接下来就直接进入主题。</p><span id="more"></span><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>Ubuntu  18.04.1<br>至于怎么在虚拟机中安装Ubuntu就不说了，百度有一堆教程[手动捂脸]</p><h4 id="1-下载SDK、jdk、ndk-并配置环境"><a href="#1-下载SDK、jdk、ndk-并配置环境" class="headerlink" title="1.下载SDK、jdk、ndk 并配置环境"></a>1.下载SDK、jdk、ndk 并配置环境</h4><p>jdk 1.8.0_191<br>ndk r14b</p><p>用vim 打开profile文件配置环境变量<br><code>vim /etc/profile</code><br>如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#java</span><br><span class="line">export JAVA_HOME=/usr/devkit/java/jdk1.8.0_191</span><br><span class="line">export JRE_HOME=/usr/devkit/java/jdk1.8.0_191/jre</span><br><span class="line">export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOME/bin</span><br><span class="line"></span><br><span class="line">#ndk</span><br><span class="line">export ANDROID_NDK=/usr/devkit/ndk/android-ndk-r14b</span><br><span class="line">export PATH=$ANDROID_NDK:$PATH</span><br><span class="line"></span><br><span class="line">#sdk</span><br><span class="line">export ANDROID_SDK=/usr/devkit/sdk/android-sdk-linux</span><br><span class="line">export PATH=$&#123;PATH&#125;:$ANDROID_SDK/tools:$ANDROID_SDK/platform-tools</span><br></pre></td></tr></table></figure><p>保存文件并退出然后执行下面的命令让配置生效<br><code>source /etc/profile</code></p><hr><p>测试环境是否已经配置好，执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src="/assets/blogImg/Ubuntu-compile-ijkplayer/java-version.png" alt="图1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ndk-build -v</span><br></pre></td></tr></table></figure><p><img src="/assets/blogImg/Ubuntu-compile-ijkplayer/ndk-build-v.png" alt="图2"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android</span><br></pre></td></tr></table></figure><p><img src="/assets/blogImg/Ubuntu-compile-ijkplayer/android-sdkmrg.png" alt="图3"></p><p>如果git 和yasm没有安装的话需要执行下面的命令进行安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git</span><br><span class="line">apt-get install yasm</span><br></pre></td></tr></table></figure><h4 id="2-下载ijkplayer源码"><a href="#2-下载ijkplayer源码" class="headerlink" title="2.下载ijkplayer源码"></a>2.下载ijkplayer源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-android</span><br></pre></td></tr></table></figure><h4 id="3-初始化android并开始编译ijkplayer-Android"><a href="#3-初始化android并开始编译ijkplayer-Android" class="headerlink" title="3.初始化android并开始编译ijkplayer-Android"></a>3.初始化android并开始编译ijkplayer-Android</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ijkplayer-android</span><br><span class="line">./init-android.sh</span><br></pre></td></tr></table></figure><p>初始化过程会耗费不少时间，需要从网上拉取代码<br>此外如果视频播放需要支持Https协议，需要执行如下命令<br><code>./init-android-openssl.sh</code></p><hr><h4 id="4-配置模式"><a href="#4-配置模式" class="headerlink" title="4.配置模式"></a>4.配置模式</h4><p>在 ijkplayer-android&#x2F;config 目录下官方提供了三个编译FFmpeg的配置文件模板给我们使用：</p><ul><li>module-default.sh：默认，最后生成的文件同时支持ts格式的视频,例如一些电视台的m3u8 格式</li><li>module-lite-hevc.sh：相对于module-lite.sh多了hevc功能</li><li>module-lite.sh：如果你更喜欢较小的二进制大小的编解码器&#x2F;格式，不支持ts格式的视频</li></ul><p>如果需要支持直播流(rstp\rtp）、rmvb支持等等，可在模板文件中添加相应的配置，并替换原有的module.sh<br>下面就module-lite.sh 文件添加相关配置进行演示<br>打开该文件，找到<br><code>export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-protocol=rtp&quot;</code><br>修改为以下，就可以打开rtsp协议了。<br><code>export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-protocol=rtp&quot;</code><br>然后继续添加以下一行，打开rtsp音视频分离器<br><code>export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-demuxer=rtsp&quot;&quot;</code><br>然后执行以下命令，连接配置文件</p><ul><li>为避免出现缺少ID为8的codec的错误*，还需要添加下面代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-decoder=mjpeg&quot;</span><br><span class="line">export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-demuxer=mjpeg&quot;</span><br></pre></td></tr></table></figure><p>添加mkv、rmvb支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-muxer=matroska</span><br><span class="line">export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-muxer=matroska_audio</span><br><span class="line">export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-demuxer=matroska</span><br></pre></td></tr></table></figure><p>然后通过如下命令重新产生module.sh文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm module.sh</span><br><span class="line">ln -s module-lite.sh module.sh</span><br><span class="line">source module.sh</span><br></pre></td></tr></table></figure><hr><h4 id="5-开始编译"><a href="#5-开始编译" class="headerlink" title="5.开始编译"></a>5.开始编译</h4><p>编译之前先执行下命令清除一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd android/contrib</span><br><span class="line">./compile-openssl.sh clean</span><br><span class="line">./compile-ffmpeg.sh clean</span><br></pre></td></tr></table></figure><ul><li>编译各个平台openssl<br><code>./compile-openssl.sh all</code></li><li>编译各个平台ffmpeg<br><code>./compile-ffmpeg.sh all</code></li><li>编译各个平台ijkplayer</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ../</span><br><span class="line">./compile-ijk.sh all</span><br></pre></td></tr></table></figure><p>如果在编译过程中出现类似于以下错误,很有可能是没有安装python,<br>可通过<code>apt install python</code> 命令来安装就行了，接着在编译就OK了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">build on Linux x86_64</span><br><span class="line">ANDROID_NDK=/usr/devkit/ndk/android-ndk-r14b</span><br><span class="line">IJK_NDK_REL=14.1.3816874</span><br><span class="line">NDKr14.1.3816874 detected</span><br><span class="line">HOST_OS=linux</span><br><span class="line">HOST_EXE=</span><br><span class="line">HOST_ARCH=x86_64</span><br><span class="line">HOST_TAG=linux-x86_64</span><br><span class="line">HOST_NUM_CPUS=2</span><br><span class="line">BUILD_NUM_CPUS=4</span><br><span class="line">Auto-config: --arch=arm</span><br><span class="line">ERROR: Failed to create toolchain.</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;近段时间项目开发中需要视频播放器，于是开始搜索相关资料了解到ijkplayer是一个很不错的开源的轻量级视频播放器，&lt;br&gt;支持播放本地网络视频，也支持流媒体播放。是Bilibili基于ffmpeg开发的，支持Android&amp;amp;iOS。&lt;br&gt;虽然Vitamio也很强大，但只是面对个人开放，就pass好了，接下来就直接进入主题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://cxinxian.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>sqlite数据库升级</title>
    <link href="http://cxinxian.github.io/2018/08/05/sqlite%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%87%E7%BA%A7/"/>
    <id>http://cxinxian.github.io/2018/08/05/sqlite%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%87%E7%BA%A7/</id>
    <published>2018-08-05T15:35:02.000Z</published>
    <updated>2021-06-05T00:49:32.105Z</updated>
    
    <content type="html"><![CDATA[<p>在本篇文章中主要是记录在android 开发中需要对sqlite数据库进行更新的一些实践与总结。希望在往后的开发中遇到同样的问题时能够帮助自己快速的回想起来。</p><span id="more"></span><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在android开发中我们一般都会需要不停的对应用进行优化更新升级，添加新功能也好，界面优化也好，或者bug修复也好，都需要持续的在不影响原有功能正常使用的情况下对app 进行迭代更新。如果我们的app 使用到sqlite数据库，那么掌握对sqlite数据库更新的技巧是非常有必要的，比如，新功能需要新增数据表记录数据，或者在原有功能上做拓展，需要数据库新增字段进行支持等等。</p><h4 id="数据库升级分析"><a href="#数据库升级分析" class="headerlink" title="数据库升级分析"></a>数据库升级分析</h4><p>数据库升级大概就分为以下几种情形：</p><ul><li>1.表的增加</li><li>2.表的删除</li><li>3.表的修改<ul><li>3.1.字段增加</li><li>3.2.字段删除</li></ul></li></ul><p>通过图形示例，大致上，数据库的升级大概有以下几种情况， 有一个版本一个版本接着升级，也有跨版本升级的。</p><p><img src="/assets/blogImg/sqlite%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%87%E7%BA%A7/pic1.jpg" alt="pic1"></p><p>通常地，我们操作sqlite 数据库都需要继承 <strong>SQLiteOpenHelper</strong> 类并实现<code>onCreate、onUpgrade</code>方法，它是sqlite 数据库的管理操作工具类，主要作用有 打开或者关闭sqlite 数据库、创建、增、删、改、版本更新。</p><p>实际开发中，数据库的创建是通过在子类构造方法调用父类的构造实现。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造器.</span></span><br><span class="line"><span class="comment"> * 参数1：context 上下文</span></span><br><span class="line"><span class="comment"> * 参数2：数据库名称</span></span><br><span class="line"><span class="comment"> * 参数3：CursorFactory 游标工厂，主要是为了创建 cursor，默认为空</span></span><br><span class="line"><span class="comment"> * 参数4：version 当前数据库版本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context the context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyDbHelper</span><span class="params">(Context context)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(context, AppConstants.DBNAME, <span class="literal">null</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//第一次创建数据库的时候回调该方法</span></span><br><span class="line"><span class="comment">//当使用getReadableDatabase()方法获取数据库实例的时候, 如果数据库不存在, 就会调用这个方法</span></span><br><span class="line">    db = <span class="built_in">this</span>.getWritableDatabase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="首次安装"><a href="#首次安装" class="headerlink" title="首次安装"></a>首次安装</h5><p>用户在第一次安装的时候会执行<code>onCreate</code> 方法，在该方法中，我们可以创建数据表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(SQLiteDatabase db)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;CREATE TABLE &quot;</span> +</span><br><span class="line">        <span class="string">&quot;tb_student(&quot;</span> +</span><br><span class="line">        <span class="string">&quot;id INTEGER PRIMARY KEY AUTOINCREMENT, &quot;</span> +</span><br><span class="line">        <span class="string">&quot;name varchar(64),&quot;</span> +</span><br><span class="line">        <span class="string">&quot;studentNo varchar(64)&quot;</span> +</span><br><span class="line">        <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    db.execSQL(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有最开始只有一个学生表 <code>tb_student</code>， 作为第一个版本 <code>V1</code>，只有几个字段，分别是 id、name、studentNo 这三个字段。</p><h5 id="V1—-V2-升级"><a href="#V1—-V2-升级" class="headerlink" title="V1—&gt;V2 升级"></a>V1—&gt;V2 升级</h5><p>后面由于业务需要，应该记录学生地址信息，需要在表添加 address 字段。因此在升级APP的同时需要更新数据库的版本。此时会出现两种情况。</p><ul><li><p>case1: V1-&gt;V2（旧版本更新到新版本）</p><p>由旧版本更新到最新版本, 此时在 <strong>SQLiteOpenHelper</strong>  的子类中，会执行 <code>onUpgrade</code> 方法，但不会执行 <code>onCreate</code> 方法。</p></li><li><p>case2: 新用户直接安装V2</p><p>新用户直接安装V2或者卸载后重新安装APP，会执行 <code>onCreate</code> 方法，不会执行<code>onUpgrade</code> 方法</p></li></ul><p>在升级的过程中我们需要兼容这两种情况，那么改进后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(SQLiteDatabase db)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;CREATE TABLE &quot;</span> +</span><br><span class="line">        <span class="string">&quot;tb_student(&quot;</span> +</span><br><span class="line">        <span class="string">&quot;id INTEGER PRIMARY KEY AUTOINCREMENT, &quot;</span> +</span><br><span class="line">        <span class="string">&quot;name varchar(64),&quot;</span> +</span><br><span class="line">        <span class="string">&quot;studentNo varchar(64)&quot;</span> +</span><br><span class="line">        <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    db.execSQL(sql);</span><br><span class="line">    updateToVersion2(db);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="type">int</span> oldVersion, <span class="type">int</span> newVersion)</span> &#123;</span><br><span class="line">    updateToVersion2(db);     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库更新到版本2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateToVersion2</span><span class="params">(db)</span>&#123;</span><br><span class="line">    <span class="comment">// 表添加字段</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;ALTER TABLE tb_student ADD COLUMN address varchar&quot;</span>;</span><br><span class="line">    db.execSQL(sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="V2-V3-升级"><a href="#V2-V3-升级" class="headerlink" title="V2-&gt;V3 升级"></a>V2-&gt;V3 升级</h5><p>随着生产发展，业务需求也在不断的变化，对APP的提出更多要求时，我们需要实时地调整来服务好用户。比如需要记录用户的 年龄，性别信息是，这时我们的 <code>tb_student</code> 表需要添加 age、gender字段。而这时会出现三种情况。</p><ul><li>case1: 用户重装或者新用户安装</li><li>case2: 用户由V1-&gt;V3</li><li>case3: 用户由V2-&gt;V3</li></ul><p>由此我们会发现随着版本的迭代次数增加，用户更新APP的的情况也会增加。为了兼顾各个版本，因此我们需要适当的对上面的代码进行调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(SQLiteDatabase db)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;CREATE TABLE &quot;</span> +</span><br><span class="line">        <span class="string">&quot;tb_student(&quot;</span> +</span><br><span class="line">        <span class="string">&quot;id INTEGER PRIMARY KEY AUTOINCREMENT, &quot;</span> +</span><br><span class="line">        <span class="string">&quot;name varchar(64),&quot;</span> +</span><br><span class="line">        <span class="string">&quot;studentNo varchar(64)&quot;</span> +</span><br><span class="line">        <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    db.execSQL(sql);</span><br><span class="line">    onUpgrade(db,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="type">int</span> oldVersion, <span class="type">int</span> newVersion)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=oldVersion; i&lt;newVersion; i++)&#123;</span><br><span class="line">        <span class="keyword">switch</span> (i)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                updateToVersion2(db);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                updateToVersion3(db);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库更新到版本2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateToVersion2</span><span class="params">(db)</span>&#123;</span><br><span class="line">    <span class="comment">// 表添加字段</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;ALTER TABLE tb_student ADD COLUMN address varchar&quot;</span>;</span><br><span class="line">    db.execSQL(sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库更新到版本3</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateToVersion3</span><span class="params">(db)</span>&#123;</span><br><span class="line">    <span class="comment">// 表字段增加</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">addCol_age</span> <span class="operator">=</span> <span class="string">&quot;ALTER TABLE tb_student ADD COLUMN age varchar&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">addCol_gender</span> <span class="operator">=</span> <span class="string">&quot;ALTER TABLE tb_student ADD COLUMN gender varchar&quot;</span>;</span><br><span class="line">    db.execSQL(addCol_age);</span><br><span class="line">    db.execSQL(addCol_gender);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 for 循环从最开始的版本遍历到最新的版本，然后 switch 指定每一个版本对应需要更新的内容，可以无遗漏的把每一个落后的版本更新到最新的版本，兼容了一个一个版本的迭代以及跨版本迭代的问题，此外，也兼顾了新安装即最新版本。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在本篇文章中主要是记录在android 开发中需要对sqlite数据库进行更新的一些实践与总结。希望在往后的开发中遇到同样的问题时能够帮助自己快速的回想起来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://cxinxian.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>2017书单</title>
    <link href="http://cxinxian.github.io/2017/12/20/essay-Diary-one/"/>
    <id>http://cxinxian.github.io/2017/12/20/essay-Diary-one/</id>
    <published>2017-12-20T05:14:54.000Z</published>
    <updated>2021-06-05T00:47:00.264Z</updated>
    
    <content type="html"><![CDATA[<p>回首2017，很庆幸自己能够利用一些碎片时间来读一下书，也感激自己没有懈怠。</p><p>– 读书的意义是为了<br>看到更大的世界</p><span id="more"></span><ul><li>明朝那些事儿(done)</li><li>半小时漫画中国史(done)</li><li>目送：龙应台“人生三书”之三(pending)</li><li>摆渡人(done)</li><li>谁动了我的奶酪(done)</li><li>从你的全世界路过(done)</li><li>有情世界(pending)</li><li>浪潮之巅(pending)</li><li>大话设计模式(pending)</li></ul><p><img src="/assets/blogImg/essay-Diary-one/mmexport1515078864559.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;回首2017，很庆幸自己能够利用一些碎片时间来读一下书，也感激自己没有懈怠。&lt;/p&gt;
&lt;p&gt;– 读书的意义是为了&lt;br&gt;看到更大的世界&lt;/p&gt;</summary>
    
    
    
    
    <category term="随笔" scheme="http://cxinxian.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="写作" scheme="http://cxinxian.github.io/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>SQL备忘录一</title>
    <link href="http://cxinxian.github.io/2017/11/30/SQL-Memo/"/>
    <id>http://cxinxian.github.io/2017/11/30/SQL-Memo/</id>
    <published>2017-11-30T15:12:27.000Z</published>
    <updated>2021-06-05T00:49:23.222Z</updated>
    
    <content type="html"><![CDATA[<p>公司开始每周一次分享会，老前辈分享了些SQL方面的知识，值得记录。<br>于是我又重新拾起我的hexo。<br>回看这时间跨度也太长了…[手动捂脸]<br>感觉我错过来太多精彩没有记录下来，罪过罪过，还好现在也不算太晚。。。</p><span id="more"></span><h3 id="一、SQL优化"><a href="#一、SQL优化" class="headerlink" title="一、SQL优化"></a>一、SQL优化</h3><p>1、对查询优化，尽量避免全表扫描，优先考虑在<code>where</code>及<code>order by</code> 涉及的列上建立索引</p><p>2、避免在<code>where</code>字句中对字段进行<code>null、!=、&lt;&gt;</code> 判断或者or连接条件，否则引擎放弃使用索引而进行全表扫描。<br>    eg:<br>    <code>select * from A where column is null or column=0</code><br>    改成:<br>    <code>select * from A where  isnull(column,0)</code></p><pre><code>尽量不给字段留NULL，尽可能使用NOT NULL；因为当字段为 char(100) 型，建立字段时，空间就固定，不管是否有值(包含NULL)，都占用100个字符空间；如果是varchar可变长字段，null不占用空间。</code></pre><p>3、对in 和 not in 要慎用，否则也会导致全盘扫描<br>对于连续数据，能用between 就不用in<br>    eg:<br>    <code>select * from A where num in (1,2,3)</code><br>    改成：<br>    <code>select * from A where num between 1 and 3</code><br>大多时候用exists 代替 in<br><code>select num from A where num in(select num from B)</code><br>改为：<br><code>select num from A where exists(select 1 from B where num=A.num)</code></p><p>4、索引的创建要与应用结合考虑，建议大的OLTP表不要超过6个索引。</p><p>5、尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过index index_name来强制指定索引   如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=@num</span><br><span class="line">//可以改为强制查询使用索引：</span><br><span class="line">select id from t with(index(索引名)) where num=@num</span><br></pre></td></tr></table></figure><p>在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用。<br>要注意索引的维护，周期性重建索引，重新编译存储过程。</p><h3 id="二、SQL使用规范"><a href="#二、SQL使用规范" class="headerlink" title="二、SQL使用规范"></a>二、SQL使用规范</h3><p>1、尽量不使用游标，因为效率差；<br>2、如果操作数据超过1w,应当改写游标</p><h3 id="三、存储过程"><a href="#三、存储过程" class="headerlink" title="三、存储过程"></a>三、存储过程</h3><blockquote><p><strong>概念：</strong><br>存储过程Procedure是一组为了完成特定功能的SQL语句集合，经编译后存储在数据库中，用户通过指定存储过程的名称并给出参数来执行。<br>存储过程中可以包含逻辑控制语句和数据操纵语句，它可以接受参数、输出参数、返回单个或多个结果集以及返回值。</p></blockquote><p><strong>作用及优点：</strong></p><ul><li>增强数据的完整性</li><li>复杂业务规则和约束的一致实现</li><li>模块化设计</li><li>可维护性</li><li>降低网络通讯量</li><li>提高执行效率</li><li>较强的安全性</li></ul><p>由于存储过程在创建时即在数据库服务器上进行了编译并存储在数据库中，所以存储过程运行要比单个的SQL语句块要快。同时由于在调用时只需用提供存储过程名和必要的参数信息，所以在一定程度上也可以减少网络流量、简单网络负担。</p><p><strong>具体使用</strong></p><p>例子：更新用户密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> proc update_user_pwd</span><br><span class="line"><span class="variable">@usr</span> <span class="type">varchar</span>(<span class="number">50</span>), <span class="comment">--输入变量，接收用户名</span></span><br><span class="line"><span class="variable">@old_pwd</span> <span class="type">varchar</span>(<span class="number">500</span>),<span class="comment">--输入变量，接收旧密码</span></span><br><span class="line"><span class="variable">@new_pwd</span> <span class="type">varchar</span>(<span class="number">500</span>),<span class="comment">--输入变量，接收新密码</span></span><br><span class="line"><span class="variable">@res</span> <span class="type">int</span> Output   <span class="comment">--输出变量，输出结果标志 0：成功； -1：用户名错误； -2：旧密码错误</span></span><br><span class="line"><span class="keyword">As</span></span><br><span class="line">if <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> username <span class="operator">=</span> <span class="variable">@usr</span>)</span><br><span class="line">if <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> username <span class="operator">=</span> <span class="variable">@usr</span> <span class="keyword">and</span> passworld <span class="operator">=</span> <span class="variable">@pwd</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">update</span> tb_user <span class="keyword">set</span> passworld <span class="operator">=</span> <span class="variable">@new_pwd</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="variable">@usr</span></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@res</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@res</span> <span class="operator">=</span> <span class="number">-2</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@res</span> <span class="operator">=</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">return</span> <span class="variable">@res</span></span><br></pre></td></tr></table></figure><p>实现分页查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用row_number函数分页</span></span><br><span class="line">if OBJECT_ID (N<span class="string">&#x27;PROC_SELECT_BY_PAGE&#x27;</span>, N<span class="string">&#x27;P&#x27;</span>) <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">procedure</span> PROC_SELECT_BY_PAGE;</span><br><span class="line">gO</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> PROC_SELECT_BY_PAGE</span><br><span class="line">    <span class="variable">@startIndex</span> <span class="type">int</span>,</span><br><span class="line">    <span class="variable">@endIndex</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">    <span class="keyword">select</span>  <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> id,name,age,sex,<span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span>) <span class="keyword">as</span> rownumber <span class="keyword">from</span> tb_user) <span class="keyword">as</span> Temp</span><br><span class="line">    <span class="keyword">where</span> Temp.rownumber <span class="keyword">between</span> <span class="variable">@startIndex</span> <span class="keyword">AND</span> <span class="variable">@endIndex</span></span><br><span class="line">go</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--使用top 分页查询</span></span><br><span class="line">使用row_number函数分页</span><br><span class="line">if OBJECT_ID (N<span class="string">&#x27;PROC_SELECT_BY_PAGE_top&#x27;</span>, N<span class="string">&#x27;P&#x27;</span>) <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">procedure</span> PROC_SELECT_BY_PAGE_top;</span><br><span class="line">gO</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> PROC_SELECT_BY_PAGE_top</span><br><span class="line">    <span class="variable">@pageIndex</span> <span class="type">int</span>,</span><br><span class="line">    <span class="variable">@pageSize</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">    <span class="keyword">select</span> top(pageSize) <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">&gt;=</span> (<span class="keyword">select</span> <span class="built_in">max</span>(id) <span class="keyword">from</span> (<span class="keyword">select</span> top(pageSize<span class="operator">*</span>(pageIndex<span class="number">-1</span>)<span class="operator">+</span><span class="number">1</span> <span class="keyword">from</span> tb_user) id <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> id)<span class="keyword">as</span> Temp)</span><br><span class="line">go</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">点点滴滴就是积累</summary>
    
    
    
    <category term="SQL" scheme="http://cxinxian.github.io/categories/SQL/"/>
    
    
    <category term="SQL" scheme="http://cxinxian.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Windows下搭建git远程代码仓库</title>
    <link href="http://cxinxian.github.io/2016/08/07/git-copssh/"/>
    <id>http://cxinxian.github.io/2016/08/07/git-copssh/</id>
    <published>2016-08-07T14:35:00.000Z</published>
    <updated>2021-06-05T00:47:15.830Z</updated>
    
    <content type="html"><![CDATA[<p>前几天因开发需要，出现代码管理问题，考虑到github上托管私有代码要收费等问题<br>于是就动手开始研究搭建公司内网的git仓库，已经搭建好了，现在就和大家分享下我的搭建过程以及心得体会。</p><span id="more"></span><h3 id="所需软件及下载和安装"><a href="#所需软件及下载和安装" class="headerlink" title="所需软件及下载和安装"></a>所需软件及下载和安装</h3><p><a href="https://git-for-windows.github.io/">git(客户端和服务端都需要安装)</a><br><a href="https://www.itefix.net/copssh">copssh(安装在服务端)</a><br>至于git的安装不作详细的赘述了,可自行百度，其中要说的主要就是要记得在系统环境变量中作配置如（图1）</p><p><img src="/assets/blogImg/git-copssh/git-global-config.png" alt="图1"></p><p>安装完git和配置好之后接着就着重说下copssh的安装和配置</p><h4 id="copssh安装"><a href="#copssh安装" class="headerlink" title="copssh安装"></a>copssh安装</h4><p>下载好了copssh的安装包后直接双击安装后就弹出如（图2）的界面</p><p><img src="/assets/blogImg/git-copssh/copssh_install_1.png" alt="图2"></p><p>选好要按装的目录后就配置CopSSH默认的帐号密码如（图3）</p><p>（这一步会在你的电脑新增一个管理员帐号，这些参数就是管理员的用户名和密码，而且以后基本上是不会用到的）</p><p><img src="/assets/blogImg/git-copssh/copssh_install_2.png" alt="图3"></p><p>a、copssh安装完成后在开始面板中打开copssh</p><p><img src="/assets/blogImg/git-copssh/copssh_config.png" alt="图4"></p><p>b、新增用户</p><p><img src="/assets/blogImg/git-copssh/copssh_config_1.png" alt="图5"></p><p>c、选择用户(可以是当前系统用户，本例就选着刚安装copssh时创建的用户吧)</p><p><img src="/assets/blogImg/git-copssh/copssh_config_2.png" alt="图6"></p><p>d、接着就是默认好了</p><p><img src="/assets/blogImg/git-copssh/copssh_config_3.png" alt="图7"><br>e、公钥配置：公钥存放地点在copssh的安装路径下如：D:\copssh\ICW\home\git.ssh\，新建一个文件叫authorized_keys，用任意一个文件编辑器打开，把公钥拷贝进去即可。拷贝进去的公钥就会显示出来（图8）<br><img src="/assets/blogImg/git-copssh/copssh_config_key.png" alt="图8"></p><p>还有另外一种添加公钥的方式是点击add按钮产生密钥(此出省略几张图)<br><img src="/assets/blogImg/git-copssh/copssh_config_key_1.png" alt="图9"><br>然后你会发现在你的copssh的用户目录中发现产生一个密钥<br><img src="/assets/blogImg/git-copssh/copssh_config_key_3.png" alt="图10"><br>此时打开.ssh目录下的authorized_keys文件你会发现多了一个公钥<br><img src="/assets/blogImg/git-copssh/copssh_config_key_2.png" alt="图11"><br>在服务端产生了公钥之后接着就是在客户端配置私钥：<br>1、把服务端的私钥拷贝到客户端<br>2、客户端中，使用puttygen.exe加载私钥产生对应的公钥并保存</p><p>在配置完所有的信息后就可以用git base输入<br><code>ssh git@192.168.0.0</code><br>git是copssh中配置的用户名，192.168.0.0是IP地址</p><p>在登录成功后，若发现git命令行不起作用可做如下图操作<br><img src="/assets/blogImg/git-copssh/copssh_config_git.png" alt="图12"><br>1、打开copssh安装目录下的etc文件夹中的profile文件<br>2、添加<br><code>:/cygdrive/d/Git/bin:/cygdrive/d/Git/mingw64/libexec/git-core</code><br>(注意开始的分号)到变量PATH</p>]]></content>
    
    
    <summary type="html">耐心一点、坚持一点、总会有收获</summary>
    
    
    
    
    <category term="git" scheme="http://cxinxian.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + github + Coding 搭建个人博客快速入门</title>
    <link href="http://cxinxian.github.io/2016/06/03/hello-world/"/>
    <id>http://cxinxian.github.io/2016/06/03/hello-world/</id>
    <published>2016-06-02T16:13:00.000Z</published>
    <updated>2021-06-05T15:26:42.342Z</updated>
    
    <content type="html"><![CDATA[<p>从网上搜到大神的博客，看到觉得很好看，非常简洁，于是乎我也弄了一个个人博客，在此感谢大神门的热心分享。在我个人看来，只要引起我的兴趣的东西我都会去尝试一下，还好花的时间也不算很多，现在想想感觉弄这样的一个博客也不是很难，只要多花点心思就好了。</p><span id="more"></span><h3 id="一、关于Hexo的介绍"><a href="#一、关于Hexo的介绍" class="headerlink" title="一、关于Hexo的介绍"></a>一、关于Hexo的介绍</h3><p>Hexo 是一个基于Node.js的快速、简洁且高效的静态博客框架,<br>使用Markdown来编写文章，通过Hexo生成静态网页，最后部署到服务器上。</p><h3 id="二、环境准备"><a href="#二、环境准备" class="headerlink" title="二、环境准备"></a>二、环境准备</h3><ul><li>安装 <a href="https://nodejs.org/en/">node.js</a></li><li>安装 <a href="http://git-scm.com/download">Git</a><br>  作用：是把本地的Hexo生成的静态博客提交到github或者Coding上去</li></ul><h3 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h3><p>在安装完以上两个软件后，再你喜爱的文件夹内(如：E:\hexo)右键选择Git Bash here然后输入以下指令<br><code>$ npm install hexo -g</code><br>接着便是执行初始化指令，Hexo 即会自动在目标文件夹建立网站所需要的所有文件<br><code>$ hexo init</code><br>安装依赖包:<br><code>$ npm install</code><br>当初始化工作完成后，便可执行下面的指令了, <code>hexo g</code> 先是把Markdown文件生成静态网页，此时你会看到当前目录下会多出一个public文件夹;<br>而 <code>hexo s</code> 则是启动本地服务器，进行文章预览调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>此时在浏览器输入：<a href="http://localhost:4000/">http://localhost:4000</a> 就可以在本地预览你的个人博客了</p><h3 id="四、提交把博客到Github和Coding-平台"><a href="#四、提交把博客到Github和Coding-平台" class="headerlink" title="四、提交把博客到Github和Coding 平台"></a>四、提交把博客到Github和Coding 平台</h3><p>（注：前提条件是在这两个平台都有账号，如果没有可以自行注册）</p><h5 id="Github-创建Repository"><a href="#Github-创建Repository" class="headerlink" title="Github 创建Repository"></a>Github 创建Repository</h5><p>建立仓库，仓库名如【your_user_name.github.io】如图1所示<br><img src="/assets/blogImg/hello-world/git_repository.png" alt="图1"></p><h5 id="Coding-创建Repository"><a href="#Coding-创建Repository" class="headerlink" title="Coding 创建Repository"></a><a href="https://coding.net/">Coding</a> 创建Repository</h5><p>如图2所示创建项目<br><img src="/assets/blogImg/hello-world/git_coding.png" alt="图2"></p><h3 id="五、部署本地文件到github和Coding"><a href="#五、部署本地文件到github和Coding" class="headerlink" title="五、部署本地文件到github和Coding"></a>五、部署本地文件到github和Coding</h3><p>找到hexo目录下站点配置文件 _config.yml并保存<br>在_config.yml最下方，添加如下配置(注：hexo的配置文件中任何’:’后面都是带一个空格的)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: </span><br><span class="line">    github: git@github.com:username/username.github.io.git,master</span><br><span class="line">    coding: git@git.coding.net:username/username.git,master</span><br></pre></td></tr></table></figure><p>如果你没有配置过ssh公钥，则可能需要配置一下:<br>具体参考一下<a href="http://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html">github ssh配置</a><br>同理Coding的ssh配置和github差不多。</p><h3 id="部署到github和Coding上"><a href="#部署到github和Coding上" class="headerlink" title="部署到github和Coding上"></a>部署到github和Coding上</h3><p>再部署之前，先安装一下hexo-deployer-git这个模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>SSH公钥配置好了以后，执行以下命令部署到Github和Coding上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">生命在于折腾，花多点耐心，多点坚持，折腾出一个Hexo blog 总会有收获。给Hexo点赞。</summary>
    
    
    
    
    <category term="hexo blog" scheme="http://cxinxian.github.io/tags/hexo-blog/"/>
    
  </entry>
  
</feed>
